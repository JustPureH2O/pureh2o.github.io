{"meta":{"title":"JustPureH2O的博客","subtitle":"深水摸大鱼","description":"JustPureH2O的小窝","author":"JustPureH2O","url":"https://justpureh2o.cn","root":"/"},"pages":[{"title":"","date":"2025-02-02T11:02:21.008Z","updated":"2025-01-20T18:37:35.326Z","comments":true,"path":"404.html","permalink":"https://justpureh2o.cn/404.html","excerpt":"","text":"404 qwq 迷路啦~ 网络的尽头 虚无之地 飞回母星"},{"title":"移动端 Banner 信息","date":"2024-07-20T16:12:21.651Z","updated":"2024-11-20T04:52:12.104Z","comments":true,"path":"banners_mobile.html","permalink":"https://justpureh2o.cn/banners_mobile.html","excerpt":"","text":"桌面端 Banner 信息戳这里 1 图片地址：这里 碧蓝档案 小鸟游星野·テラー PID：120642947 2 图片地址：这里 碧蓝档案 橘光 PID：117347645 3 图片地址：这里 碧蓝档案 圣园未花 PID：98711243 4 图片地址：这里 碧蓝档案 橘光明 PID：117355676 5 图片地址：这里 PID：71663996 东方Project 博丽灵梦 6 图片地址：这里 PID：115879391 碧蓝档案 空崎日奈"},{"title":"关于","date":"2023-10-26T00:03:52.000Z","updated":"2025-01-21T00:01:19.145Z","comments":true,"path":"about/index.html","permalink":"https://justpureh2o.cn/about/index.html","excerpt":"","text":"Q：自我介绍？ 欢愉的追随者（确信） 2007年生，如今是一名普通的中学生。现居四川成都，目前正在为成都东辰服役…… 现在是一名命数已尽的OIer（指已经退役/AFO），在学校的压力下艰难补习常规课。如今身后已没有退路，由于三个火箭班中的第二名已经满员，此时退出竞赛班也就意味着进入真正意义上的的火箭平行班，也就必须忍受来自某出生年级主任的压力和名誉的损失。 爱好不是很多。最主要分为程序、整活、二次元和音乐四方面。 首先是程序：四年级自学过一段时间的 VB，初一时对 Minecraft 模组编程感兴趣，于是自学了 Java（也简单编过一些），但是（因为国内网络环境太好了）最终搁置了；在初二被某位尤爱摸鱼的“信息技术课程部主任”给提拔到 C++ 进阶班里“学习竞赛”（实际上那位主任上课连来都不来一次），到了高一才算真正开始 OI 之路。由于我本身喜欢折腾一些东西，初中时浅浅研究过一段时间的极域破解，但都不及高中时研究学生机房管理助手时的成就。 第二是整活：最开始只是在八九年级网课期间整一点表情包，后面接触到 PS 和 PR，整活的功底也比较深了。九年级开始整一些视频，到了高中，遇见了某位和我一样同爱整活的同学，因为看到学校的干饭盛况，就情不自禁整了一个东辰干饭实拍，但由于触犯到东辰高层的一些利益被学生会要求删除……本人也是目前教学区四楼干饭记录保持者（中午+下午，均26s，与本文初稿相比提升9s），现在哥几个正在计划来一条本人拍摄的沉浸式抢饭视频……跑操喊口号喜欢把“脚踏实地”吼成“脚踏东辰”；“东辰学子”喊成“东辰倒闭”；“挑战极限”说成“挑战东辰”（也是我们班的倒闭组常态）…… 第三是二次元：说实话番我很少看，主要还是二游的二创。初一时入坑东方，看过一部《东方万华镜》、同年入坑 《Blue Archive》、《原神》（的二创而并非游戏本身）；初二下期入坑《原神》（游戏本身），因为我本人比较喜欢这类开放大世界的游戏，所以直到如今都还在玩（最开始和我一同入坑的小伙伴们都跑去隔壁星穹铁道了）；初三上搞到了《重返未来》的开服号（退坑），紧接着初三下期抢了个《星穹铁道》的公测号，现在这个号是我和同学一起在玩（运气实在太好了导致我那位同学把自己的号都放弃了）；高一让某位同学帮我注册了个《Blue Archive》的国际服账号，但是没过几周国内就拿下了它的版号，因此现在在玩国服（说是玩但实际上都没怎么打开过，要我说还得是它的立绘/剧情更吸引我）；现在（高一下）那些朋友还有玩《物华弥新》、《暗区突围》、《三角洲行动》的……对于我本人，其实更想探索一下早期的起源引擎的作品（例如《传送门》二部曲，已通关）以及 给他爱5（或许会买给他爱6，等出来了再说，先攒点零花钱……）。 最后是音乐：比较喜欢听电子（具体可以看到网站下端的播放器歌单）。最喜欢的还是 Melodic Dubstep、有时会听 Uplifting Trance 等抒情性较强的曲风。 Q：网站建站史？ 早在九年级下、正式进入高中前的暑假，但具体日期忘记了，故以网站静态文件所在的Github仓库的第一次Action执行日期（2023/07/24）为建站日，主页。最开始这个网站是用来记录我初中的那些奇闻轶事，进竞赛班之后这个网站又变成了记录算法学习心得体会的技术性博客。偶尔也会学GGapa那样在网站里面传一些小随笔（不过随便暂时没想好是放在主页里还是另起一个新页面来放），但前提是我得真的有那闲心和灵感写这些随笔毕竟文笔有限写不出啥好文章来…… Q：突出成就/贡献？ 初二上期，双减刚刚出台（2021.9.10），发起举报东辰违规补课的运动，换来一周的正常放假（挺小丑的）。最离谱的是我作为我们班的举报运动发起人，甚至没被班主任制裁，反倒是那些跟风打了电话的人写了六百字检讨（有些被致电家长了）。我还依然记得当时紧急宣布周五下午放学时（一般周六中午放学）家长群里通知的是“为庆祝教师节，提前放学”。但是当天因为某位同学太过高兴把关键人物写进了一篇《消息一则》发在朋友圈里被家长发现然后告诉班主任了…… 高一上制作了一个成都东辰干饭实录，也算是为东辰涨了点流量……如下： 高一下期在两周之内连续抓获三次晚放学后在厕所里搞事情的男女，导致该厕所成为学生会每晚必查的地点之一。 Q：在东辰最令你难忘的事情？ 2022年6月29日， 下午最后一节课，还有两分钟下课（抢饭）。教室的某个角落突然传出一声气体泄露的“呲”声。两秒后，一股刺鼻的硫化物气味便直入鼻腔——教室一侧的某位同学误以为柜子里装着的瓶子里是饮料，殊不知那是养了整整六个月已经胀气的鸡蛋罐头（俗称臭水，我们叫烂昭昭，取自屈原《九歌·云中君》——“灵连蜷兮既留，烂昭昭兮未央”）。好在当时离下课不久，因而没有造成人员中毒。当时坐在一旁的英语老师改着卷子突然脸色就答辩了，最后那个瓶子被班主任勒令丢掉（但是最后被我们捡回来了，不出意外始作俑蛋现在还在那个瓶子里待着）。 Q：你的成绩，人生座右铭？ 成绩在班上排中间，三个火箭班（130多人）正常发挥的话（语数外物化生）能排 名左右？英语比较好，语文在中游，数学看状态，物理不太行，化学靠天意，生物过山车……顺便补充个历政地——历史秦始皇，政治国民党、地理不太强。 忠实的唯物主义者，不批判也不完全认同其他观念，言之有理即可接受；无神论者、无宗教信仰（非要说的话就是芙门✟）。 同时作为一个东辰活跃的法外狂徒，还践行着： 一日一惡 坚定不移、矢志不渝地走欢愉道路 Q：最让你自豪的事情？ 24年4月份清明节那会当了中国第一批游玩 You.Fo 的人之一（顺便还拉上了我的 OIer 好友） Q：最喜欢的一句话？ 「 Vanitas vanitatum omnia vanitas 」（因为是老婆说的） Q：有什么目标？ 高考给力点至少 往上吧，至少也得成都电子科大，C9清北努把力能上当然就上。"},{"title":"本站 Banner","date":"2024-04-20T17:04:26.891Z","updated":"2025-01-17T04:05:34.170Z","comments":true,"path":"banners/index.html","permalink":"https://justpureh2o.cn/banners/index.html","excerpt":"","text":"我知道你们是来看老婆的 移动端适配 Banners 请戳这里 1 图片地址：这里 崩坏·星穹铁道 流萤 游戏内截图 2 图片地址：这里 崩坏·星穹铁道 花火 游戏内截图 3 图片地址：这里 崩坏·星穹铁道 流萤&amp;星 游戏内截图 4 图片地址：这里 原神 芙宁娜 同人原创作品 5 图片地址：这里 原神 芙宁娜 同人原创作品 6 图片地址：这里 虚拟歌姬Vocaloid 初音未来·雪 同人原创作品 画师：Lunami Pixiv：雪·月 PID：65261833 7 图片地址：这里 原神 芙宁娜 同人作品 8 图片地址：这里 崩坏·星穹铁道 符玄 同人原创作品 9 图片地址：这里 崩坏·星穹铁道 黄泉&amp;砂金 游戏内截图 10 图片地址：这里 崩坏·星穹铁道 流萤 游戏内截图 11 图片地址：这里 崩坏·星穹铁道 剧情截图 12 图片地址：这里 崩坏·星穹铁道 流萤&amp;星 同人二创 PID：116220666 13 图片地址：这里 崩坏·星穹铁道 流萤&amp;星 同人二创 PID：116629910 14 图片地址：这里 蔚蓝档案 浦和花子 解包 15 图片地址：这里 蔚蓝档案 圣原未花 解包 16 图片地址：这里 蔚蓝档案 阿慈谷日富美 解包 17 图片地址：这里 蔚蓝档案 白洲梓（泳装） 回忆大厅 18 图片地址：这里 蔚蓝档案 狐坂若藻 回忆大厅 19 图片地址：这里 蔚蓝档案 月雪宫子 回忆大厅 20 图片地址：这里 蔚蓝档案 天童爱丽丝（女仆） 回忆大厅 21 图片地址：这里 蔚蓝档案 栗村爱莉 回忆大厅 22 图片地址：这里 蔚蓝档案 鬼方佳世子 回忆大厅 23 图片地址：这里 蔚蓝档案 vol3.伊甸园条约 剧情CG 24 图片地址：这里 崩坏·星穹铁道 知更鸟&amp;星期日 剧情内截图 25 图片地址：这里 蔚蓝档案 同人二创 26 图片地址：这里 蔚蓝档案 才羽绿 记忆大厅 27 图片地址：这里 蔚蓝档案 圣园未花 记忆大厅 28 图片地址：这里 蔚蓝档案 和乐千世 记忆大厅 29 图片地址：这里 原帖：X @kokola 蔚蓝档案 二创 30 图片地址：这里 原神 胡桃 二创 31 图片地址：这里 PID：117436869 蔚蓝档案 小鸟游星野 AI生成 32 图片地址：这里 碧蓝档案 小鸟游星野（临战） 记忆大厅 33 图片地址：这里 碧蓝档案 白洲梓 PID：90207887 34 图片地址：这里 原神 摄影 希穆兰卡 By JustPureH2O 35 图片地址：这里 碧蓝档案 三周年贺图 Yandre #1141489 36 图片地址：这里 碧蓝档案 白洲梓 AI PID：116291715 P4 37 图片地址：这里 ProjectKV 原帖：X @DynamisOne 38 图片地址：这里 碧蓝档案 普拉娜 游戏内截图 39 图片地址：这里 碧蓝档案 伊落玛丽 PID：116865185 40 图片地址：这里 碧蓝档案 葛叶 PID：111691496 41 图片地址：这里 碧蓝档案 鬼方佳代子&amp;浅黄睦月 原帖：Danbooru 42 图片地址：这里 碧蓝档案 砂狼白子 原帖：Danbooru 43 图片地址：这里 东方Project 博丽灵梦 44 图片地址：这里 45 图片地址：这里 46 图片地址：这里"},{"title":"所有分类","date":"2025-02-02T11:02:21.018Z","updated":"2024-08-10T05:19:59.676Z","comments":false,"path":"categories/index.html","permalink":"https://justpureh2o.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2025-02-02T11:02:21.052Z","updated":"2024-04-12T01:16:59.954Z","comments":true,"path":"friends/index.html","permalink":"https://justpureh2o.cn/friends/index.html","excerpt":"","text":"loadQexoFriends(\"qexo-friends\", \"https://admin.justpureh2o.cn\")"},{"title":"所有标签","date":"2023-10-26T00:56:08.000Z","updated":"2024-06-22T17:10:12.022Z","comments":false,"path":"tags/index.html","permalink":"https://justpureh2o.cn/tags/index.html","excerpt":"","text":""},{"title":"此页面的扩展内容","date":"2024-08-04T23:46:45.907Z","updated":"2024-08-08T05:42:28.936Z","comments":true,"path":"extension/index.html","permalink":"https://justpureh2o.cn/extension/index.html","excerpt":"","text":"Blue Archive 值日生侧边栏 源代码：ba_showcase.js 样式：ba_showcase.css 每日在侧边栏随机显示一个BA角色，点击可切换该角色的其他对话。支持 URL 带参切换，具体参数值如下表： 参数 名称 效果 ?student=0 圣园未花 ?student=1 白洲梓 ?student=2 小鸟游星野（临战） ?student=3 橘光 ?student=4 鬼方佳代子 ?student=5 下江小春 ?student=6 生盐诺亚 ?student=7 天童爱丽丝"},{"title":"说说","date":"2024-03-08T05:47:55.818Z","updated":"2024-06-22T17:10:12.040Z","comments":false,"path":"talks/index.html","permalink":"https://justpureh2o.cn/talks/index.html","excerpt":"","text":"showQexoTalks(\"qexot\", \"https://admin.justpureh2o.cn\", 5)"}],"posts":[{"title":"网图溯源导论","slug":"tutorial-trace-an-image-properly","date":"2025-01-26T21:09:59.995Z","updated":"2025-01-26T21:23:31.722Z","comments":true,"path":"articles/50805/","link":"","permalink":"https://justpureh2o.cn/articles/50805/","excerpt":"","text":"前言 “主播主播，抖音上下载的美图确实很多，但就是太吃清晰度了。有没有更加高效精准的原图搜索方法？” “有的兄弟，有的！这么强的搜索方法当然不止一个，一共有九个，全都是当前世纪 T0.5 的强势搜索方法……掌握一到两个搜索方法，全网的美图都能给你找到源头……” Google Lens/谷歌智能镜头 基本使用 需要科学上网工具 地址：Google 直接根据提示上传本地图片或者是在输入框输入图片的链接后点击搜索即可。之后你会看到类似于下图的界面： 可以使用上面的四角来框选识别区域；同时也可以在上端输入框里面输入图片描述来更加精确地定位原图。请注意搜索结果可能会受所在区域的影响，即梯子的代理服务器所在地区可能影响搜索结果。 请注意，如果你使用的是社交媒体的截图，请将图片两端的点赞评论以及顶端无关内容删去后再上传以获得更佳效果（节省梯子流量）。 可以点击框选区域下端的“完全匹配的结果”来缩小范围。 得到的结果是这个形式的，我们可以看到源站、发布的时间、分辨率以及一个小预览图。可以发现此处的图片来源是推特（X）。如果是搜索动漫图片，建议只看以下几个站点的结果以节省工作量： Pixiv/PixivBox/BoBoPic/Danbooru/Gelbooru/Yande/Konachan。这些都会提供高清原图（除非仍然是二次转载），或者是原图的相关信息（链接、画师、PID 等）。 X。尤指搜索结果标题里带有“on X: ”字样的结果（例如上图），它会指向带有这个图片的帖子本身；如果不含上述字样，那么这张图片有可能是用户的头像等不太清晰的图片，可以考虑用它做二次搜索。 接下来一般就可以定位到原图了。 优劣总结 本方法的优点在于：谷歌的强大图像识别能力以及它存储的海量的搜索结果使得它在大部分情况下能够给出精准且丰富的搜索结果，在国外社交媒体和交流网站（上述的几个站点）上被多次转载过的图片效果最佳。 但是它仍然有缺陷：小众的图片、某用户生成的 AI 图片（基本上只在小范围内传播）等很难在谷歌上找到来源。谷歌对国内网站结果的爬取较少，导致它在对仅大陆内传播的图像资源的搜索能力较差。如果谷歌未能返回你预期的结果，不妨试试以下介绍的其他方案。 课后练习 定位以下图片（答案见全文末）： SauceNAO+Pixiv.re 基本使用 SauceNAO 需要科学上网工具，Pixiv.re 不需要 地址：SauceNAO（官方）、SauceNAO（中国站，搜索时仍然会重定向到前者的地址）、Pixiv.re（P 站反代，需要在网址后输入 PID 访问，具体用法 见下） 点击“Select Image”上传图片，或者是在输入框里输入图片 URL 来搜索。同样需要事先将图片无关内容清除掉，否则可能影响搜索结果。 一般来说这个网站会自动隐藏低相似度的结果，所以如果没有任何结果或者不是原图，那么就请放弃这个方法。在右侧可以看见图片的相关信息（PID、画师等），以及导向其他站点的链接（上图中就有 Danbooru 和 Gelbooru）。 拿到 PID 后 ，可以直接去 P 站下载，也可以去它的镜像站 Pixiv.re 下载。具体流程如下： 复制根目录地址 https://pixiv.re/ 在最后一个斜杠后面拼接 PID 和文件后缀，本例中为 https://pixiv.re/116629910.jpg。如果这个 PID 下有多张图片，假设这是第五张，那么地址就是 https://pixiv.re/XXXXX-5.jpg。 图片加载完成后，长按/右键下载即可。 优劣总结 优点：直接导向原图，操作简单。 缺点：很多新图搜不到，有些较老的图片也搜不到，搜索效果不稳定；对图片质量要求较高。 小红书 跳脱思维框架的前奏…… 基本使用 进入，点击搜索框，点击相机图标上传待搜图片即可。 优劣总结 优点：如果以上几种方法都没啥用，可以试试在小红书查。因为这些图片大概率只在大陆传播，且很多都是 AI 图。 缺点：仅局限在小红书已有帖子内。 课后练习 定位以下图片（答案见文末）： 淘宝/京东/天猫 他正在给我们提供搜图的新思路！ 基本使用 同小红书，点击相机图标上传图片，可以通过框选有效区域来识别。上述方法均失效时可以考虑这个方案。 优劣总结 优点：对模糊/遮挡的图像识别较好，适合搭配上述其他方法进行二次搜索。 缺点：局限在对应 APP 的商品范围内，不能很好的综合线上的结果。 课后练习 定位以下图片（答案见文末）： 请定位背景的紫毛 Yandex Images 需要科学上网工具 基本使用 地址：Yandex Images 由于 Yandex 在大陆不提供以图搜图服务，因此需要连接代理后再试。 使用方法同 Google Lens。 优劣总结 优点：上面都搜不到可以试试这个。 缺点：和百度、搜狗差不多，基本上搜不到结果。 课后练习 答案 Google Lens/谷歌智能镜头 要点：善用框选工具，删去图片中无用的信息 第一个——日奈：PID 105466693；或 Danbooru（找到原图即可） 第二个——玛丽：PID 125897012（找到原图即可） 第三个：Danbooru（找到原图即可） 小红书 第一个——梓：小红书原贴 淘宝/京东/天猫 要点：框选有效区域；搭配谷歌等进行二次搜索。 第一个——优香：Yande；或者 Konachan（找到原图即可）","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://justpureh2o.cn/tags/%E6%95%99%E7%A8%8B/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"[公告 2025.01.23] 网站功能更新","slug":"broadcast-250123","date":"2025-01-22T17:20:52.404Z","updated":"2025-01-22T18:14:01.542Z","comments":true,"path":"articles/31517/","link":"","permalink":"https://justpureh2o.cn/articles/31517/","excerpt":"","text":"2025 年 1 月 19 日至 23 日，本网站经历了一轮重大功能更新，现将这些修改按 HTML 元素罗列如下： 页面左下角看板娘 页边过窄时自动隐藏，窄屏设备中将不再显示，“过窄”具体指 window.innerWidth * 0.17 的值大于文章主体元素 l_body 在页面上的左边距，即看板娘接近挡住文章正文时。 设置渐隐动画，浏览器中可通过拖拉开发者模式窗口查看效果。 打印模式下自动隐藏。 行间公式 设置了行间公式块居中显示，并添加 2em 的外边距，优化观感。 代码块 设置了代码块二级字体。对于中文注释将自动采用“汉仪将军”字体（正文字体）。 友链 更改 StairsUponTemple、Brilliant11001 的博客地址；GGapa、Lucas2011、Aventurine_stone、HYLW、StairsUponTemple 的友链副标题；HYLW 的博客名称。 关于页 更改了部分措辞以适配实际状况。 添加了一个内嵌视频。","categories":[],"tags":[{"name":"公告","slug":"公告","permalink":"https://justpureh2o.cn/tags/%E5%85%AC%E5%91%8A/"}]},{"title":"圆锥曲线 常用二级结论附证明过程","slug":"math-conic-curve-secondary-conclusions","date":"2025-01-17T05:26:06.364Z","updated":"2025-02-02T03:01:14.463Z","comments":true,"path":"articles/61430/","link":"","permalink":"https://justpureh2o.cn/articles/61430/","excerpt":"","text":"前言 做这篇文章最初的缘由，似乎也早已忘却了，大抵是期中时拍拍脑子生出的主意，然终竟无法再考究了……然而既已入年，我想自己许是有些寂寞而无所事事了。恰逢 A 君邀我做一篇圆锥曲线的文章，他仿佛有点谑我的意思，欲以此指代方才过去的令人悲哀的数学考题，我举起手机只是说： “假如一道圆锥曲线填空压轴，它是没有常数且万难算出的，考场上有许多没背二级结论的高中生，见到就跳过了，然而是舍小保大，并不感到挂科的悲哀。现在你教他们背二级结论，说动了想冲高分的几人，使这不幸的少数者来受知晓结论而仍解不出的可能挂科的苦楚，你倒以为对得起他们么？” “然而几个人既然背了，你不能说决没有解出这个题的希望。” 是的，我虽然自有我的确信，然而说到希望，却是不能抹杀的。因为希望是在于将来，决不能以我之必无的证明，来折服了他之所谓可有，于是我终于答应他也做圆锥曲线的文章了。 二零二五年一月十七日，记于成都 椭圆 基础二级结论 若无特殊说明，椭圆标准方程 均满足 ，焦点在 轴上。且若无特殊指明，“椭圆 ”均指上述的椭圆 。 通径 在椭圆 中，与焦点所在轴垂直的焦点弦被椭圆截得线段的长称作其通径。椭圆的通径长 。 评析：直接将横坐标 代入即可解得纵坐标，通径长为纵坐标绝对值的二倍。 证明： 横坐标 代入椭圆解析式： 得到 。 因为在椭圆中有 ，因此 ，椭圆离心率还可以表示成 。代入得： 此时 。 证毕。 圆周定理 在椭圆 中， 是椭圆上关于原点对称的两点， 是椭圆上异于 的一点。那么直线 的斜率之积为 。 评析：也不需要什么特殊的技巧，就是设点硬算。这个结论是必背的经典二级结论之一。 证明： 设 。那么两直线斜率之积可以表示为 ，即： 三点都在椭圆上，代入椭圆解析式得关系式： 将 和 用 表示出来： 证毕。 拓展变形：我们默认椭圆的焦点位于 轴，那万一焦点在 轴上呢？首先我们需要保证较大的分母为 ，较小的为 ，例如 ，此时 ，现在的两直线斜率之积为 ，即 ，分子分母调换了！做题时一定要注意，证明方法同上。 广义垂径定理/中点弦公式 在椭圆 中， 为椭圆上两点， 为弦 的中点，那么直线 与直线 的斜率之积为 。 评析：处理中点的方法一共有两个——常规联立法和点差法。此处我们使用第一种，因为韦达定理可以很轻松的表示出中点的坐标；同时设出直线 代表我们可以只用一个 表示其斜率，由于 过原点，表示它的斜率也是容易的。那我们就开始吧。 证明： 设直线 。斜率不存在时无意义，故斜率一定存在。联立方程： 得： 根据韦达定理得： 因此 。得到斜率乘积为 。 证毕。 拓展变形：易错点与上一个结论相同，焦点所在坐标轴改变后，乘积会从原先的 变成 。 焦半径公式 令 为椭圆 的左右焦点， 为椭圆上一点，那么 。其中 ，即椭圆的离心率。 评析：这个结论其实就是椭圆第二定义的变形式，不信你看。 证明： 先证 。对于 来说，对应的准线为直线 。根据椭圆第二定义有： 再证 。其实根据椭圆第一定义 即可推出它，但是我们继续用第二定义推导。此时对应的准线是直线 ： 证毕。 拓展变形：焦点在 轴上时，结论变为 。 焦点三角形相关 椭圆的左右焦点 与椭圆上一点 组成的三角形 称作这个椭圆的焦点三角形。 本节中出现的角 若无特殊说明均指代 。 取值范围 焦点三角形 中，。 评析：前两个非常好证，他们理论上在 与左右端点重合时取到最值，但是此时 三点共线，因此不是三角形，所以是开区间。对于第三个，乘积的取值范围，则需要基本不等式。 证明： 根据基本不等式有： 证毕。 周长 焦点三角形 的周长 。 评析：根据椭圆的第一定义来的，。 面积 焦点三角形 的面积 。 评析：出现角度和面积，我们需要想到正/余弦定理。根据正弦定理的三角形面积公式 以及余弦定理的 ，我们可以解决大部分与边长和角度有关的圆锥曲线证明/求值问题。 证明： 由正弦定理得，。 在 中运用余弦定理：，得到 。 同时根据完全平方公式，，代入上式移项解得 ，根据面积公式可得 。 证毕。 拓展变形：三角函数的半角公式（附证明）。 ——正/余弦半角公式 根据余弦倍角公式的变形式 ，将 换成 ， 换成 即得 ，。 同理，对于正弦函数，有 。 ——正切半角公式 由正切函数定义可得 ，利用三角函数的升幂，也就是上面导出正余弦半角公式时使用的余弦倍角公式，分子分母同乘 可得：。 因此证明面积公式时出现的 可以换成 。三个公式汇总起来就是： 内切圆 焦点三角形 的内切圆半径为 ，已知半径也可求出顶角 。 评析：这一条其实也没什么，主要是正弦定理的运用。因为在三角形中 ，其中 就是内切圆半径。将 所对的边 的长度代入即可证得该结论。 离心率公式 令焦点三角形 的底角 ，那么椭圆的离心率 。 评析：有角有边，当然考虑正余弦定理。 证明： 易知此时 。根据正弦定理有 。在椭圆中又有 ，那么 。 代入连等式中，得到 ，根据后两项可以解出 ，此时代入第二项得到 。 此时 。 证毕。 双曲线 基础二级结论 若无特殊说明，双曲线标准方程 ，满足 ，焦点在 轴上。且若无特殊说明，“双曲线 ”均指上述的标准双曲线 。 通径 在双曲线 中，与焦点所在轴垂直的焦点弦被双曲线截得线段的长称作其通径。双曲线的通径长 。 评析：与椭圆证法相同。 证明： 将横坐标 代入得 。因为双曲线满足 ，可以推导出 。那么 ，得到 。此时通径长为 。 证毕。 圆周定理 在双曲线 中， 是双曲线上关于原点对称的两点， 是双曲线上异于 的一点。那么直线 的斜率之积为 。 评析：双曲线有关二级结论的证明思路和椭圆基本相同，这里我们沿用椭圆的证明方法继续硬算。 证明： 设 ，那么： 三点都在双曲线上，得到： 代入得： 证毕。 拓展变形：焦点所在坐标轴改变时同样要变成 。 广义垂径定理/中点弦公式 在双曲线 中， 为双曲线上两点， 为弦 的中点，那么直线 与直线 的斜率之积为 。 评析：同样使用椭圆的证明方法 证明： 令直线 ，斜率不存在时无意义，故斜率存在。联立直线和双曲线方程： 得到：。韦达定理得 。 得到中点坐标 ，此时斜率之积表示为： 证毕。 拓展变形：焦点在 轴上时对应的乘积是 。 焦半径公式 令 为双曲线 的左右焦点， 为双曲线上一点， 在右支上时有 ；在左支上时有 。 评析：双曲线第二定义的变形 证明： 当 在右支时，根据第二定义，有 ，得到 ，然后根据双曲线中 可得 。 同理可以证得左支公式。 证毕。 拓展变形：焦点在 轴上时要把 换成 。 渐近线相关 过原点且在无穷远处与双曲线的距离无限趋近于 的两条直线叫做这个双曲线的渐近线。焦点在 轴上时渐近线的解析式为 ；若在 轴上则为 ，即 。 焦点-渐近线距离 双曲线的焦点与任意一条渐近线的距离均为 。 评析：使用点到直线的距离公式证明。 证明： 左焦点 ，到渐近线 的距离为： 证毕。 焦点三角形相关 双曲线的左右焦点 与双曲线上一点 组成的三角形 称作这个双曲线的焦点三角形。 本节中出现的角 若无特殊说明均指代 。 周长 焦点三角形 的周长为 。 评析：根据前面所证明的焦半径公式可得这个结论。 面积 焦点三角形 的面积为 。 证明： 正弦定理得：。余弦定理得：，得到 。根据完全平方公式，有 ，联立可得 ，解得 。代入面积公式得 。 证毕。 拓展变形：余切的半角公式证明。 离心率公式 令焦点三角形 的底角 ，那么双曲线的离心率为 。 证明： 由正弦定理，，不妨假设当前 在右支上，那么 ，即 。解得 。此时有 。得到 。 证毕。 抛物线基础二级结论 若无特殊说明，抛物线标准方程 均满足 ，焦点在 轴正半轴。且若无特殊指明，“抛物线 ”均指上述的抛物线 。 通径 抛物线的通径长为 。 评析：抛物线中只要涉及到焦半径相关的内容，都要第一时间想到焦半径长等于该点与准线的距离从而进行转化，这样可以简化计算。 证明： 横坐标 代入，得到焦半径为 ，通径为二倍焦半径，即 。 证毕。 焦点弦定理 抛物线 的一条焦点弦交抛物线于 两点，那么直线 与直线 的乘积为定值 。 评析：我们可以恰当选择直线的横截式和斜截式来方便计算。在本例中，由于抛物线方程的二次项在 上，并且直线过 轴上的定点，我们自然地选择横截式来进行计算。 证明： 令直线 ，联立抛物线方程 得： 根据韦达定理，得： 斜率的乘积表示为： 证毕。 拓展变形：事实上，证明过程中由韦达定理导出的关系式 和 在实践中更为常用一些。 两点弦公式 抛物线 上两点 和 组成的弦 的斜率为 。 评析：适时避开繁琐的高次计算是非常有用的。 证明： 因为两点在抛物线上，因此坐标满足： 所以斜率可以表示为：。 证毕。 焦半径公式 抛物线 的焦点弦 分别在第一象限和第四象限交抛物线于 两点，直线 与 轴的夹角是 ，那么 。 评析：直接看不太容易，来一张图辅助一下： 证明： 由抛物线定义知：，移项可得 。同理可证得 。 此时 。 证毕。 椭圆-双曲线共焦点问题 在本章中，我们默认存在一个椭圆 与 共焦点。若无特殊说明， 为两圆锥曲线在第一象限内的交点，。如下图： 焦半径 共焦点的椭圆和双曲线满足 。 评析：注意利用好椭圆和双曲线的定义。 证明： 在椭圆中，有 ；在双曲线中，有 ，两式相加得 ，相减得 。由此得到： 证毕。 离心率与角的关系 共焦点的椭圆和双曲线满足 评析：同样是有角有边，考虑正/余弦定理。这个结论可以帮助你快速解决诸如 等式子的最值问题。 证明： 借用上一节的焦半径结论，并综合余弦定理，可以得到： 证毕。 拓展变形：正余弦函数的升幂/降幂公式。 由余弦的二倍角公式 ，得到 。即证得降幂公式。事实上，余弦的二倍角公式就是升幂公式。 蒙日圆 椭圆 上任意两条互相垂直的切线焦点的轨迹组成了一个圆，称作蒙日圆/外准圆。椭圆 的蒙日圆为 。如下图： 若无特殊说明，两切线交于 ，且与椭圆分别交于点 和 ，与蒙日圆分别交于点 和 。 轨迹方程 椭圆 对应的蒙日圆方程为 。 评析：没有感情，只有设点。 证明： 切线斜率不存在时，，显然在圆 上。 切线斜率存在时，设 ，则根据垂直关系有 。 联立 与椭圆方程，并根据相切关系得： 同理可得 。 联立两直线方程得到 ，此时 。因此 在圆 上。 证毕。 几何性质 其一 蒙日圆上一点 引出的两条切线交蒙日圆于 两点，直线 过原点。 评析：无 证明： 根据圆内直径所对的圆周角恒为直角的关系，可得 为蒙日圆直径，即 三点共线、 过原点。 证毕。 广义垂径定理 为蒙日圆上一点，过 作椭圆 的两条切线 ，切点为 ，连接 ，则 。 评析：利用圆锥曲线的切点弦方程即可快速解决。 证明： 令 ，那么 。根据圆锥曲线的切点弦公式，得到切点弦 ，得到 。相乘即得结果 。 证毕。 拓展变形：椭圆交点所在坐标轴变化后仍然会变成 。同时根据结果和中点弦公式可以得知 与 的交点 为 中点。 几何性质 其二 蒙日圆上一点 向椭圆引两条切线 和 ，交椭圆于 ，交蒙日圆于 ， 交 于 点，有 。 评析：利用几何关系进行证明。前置是上面的广义垂径定理和几何性质一。 证明： 根据蒙日圆，得到顶角 。根据上面广义垂径定理得到的 为 中点的关系，结合直角三角形斜边上的中线定理，可以得到 ，所以 。同样在大直角三角形 中类似地又有 ，因此 。同位角相等，两直线平行。 证毕。 拓展变形：根据这条性质，广义垂径定理可以推广成 。 几何性质 其三 从蒙日圆上一点 向椭圆 引两条切线 ，切点为 。那么 。 评析：运用切线公式和已知的垂直条件快速解题。 证明： 令 ，则根据切线公式得 ，斜率为 ，乘积为 。同理可以证得 。 综合以上两式 ，得 ，根据蒙日圆的切线垂直条件 ，得到 。 证毕。 阿基米德三角形 抛物线的某条弦 ，过 的两条抛物线的切线相交于 点，三角形 称作这个抛物线的阿基米德三角形。如下图： 和 都是这个抛物线的阿基米德三角形。 若无特殊说明，本章中的抛物线 均指代抛物线 。 几何性质 其一 阿基米德三角形在抛物线上的弦的中点为 ，那么该弦所对的顶点 满足 。 评析：巧妙运用切线方程解决问题。 证明： 令弦的端点 ，点在抛物线上得 。根据切线方程得 ，同理得 ，联立解得交点 。中点得 ，得到 。 证毕。 几何性质 其二 当阿基米德三角形在抛物线上的弦过顶点 时，该弦所对顶点的运动轨迹为 。 评析：利用切点弦公式，或者是几何性质一可以证明。此处选用几何性质一进行证明。 证明： 令底边 ，根据几何性质一得顶点 。因为定点 在 上，应有 ，即： 因此 在直线 上。 证毕。 拓展变形：此结论的推论有——当底边过焦点时，顶点的轨迹为抛物线准线；底边过 轴定点 时，顶点轨迹为直线 。 几何性质 其三 当阿基米德三角形的底边过焦点时，阿基米德三角形的顶角为 ，即 。 评析：可以借助几何性质一来快速解决。 证明： 令 ，由几何性质一可得 。两切线斜率之积为： 最后联系到抛物线焦点弦定理中 （设直线代入韦达定理得出）可以得到斜率之积为 ，即两直线垂直。 证毕。 几何性质 其四 在阿基米德三角形中，恒有 。 评析：几何法搭配解析几何解题较为快速。 证明： 过 分别作准线的垂线 ，垂足为 ，连接 ，，如下图： 令 ，根据切线公式可得 ，得到斜率 。由垂直得 ，因此 斜率为 ，乘积为 ，有 。 在抛物线中，有 ，根据直角三角形 HL 型全等得 ，进而有 ，再次可 SAS 证得 。仿照上述全等推导可证得 。那么 。 根据几何性质一可得，，就有 ，，因此 ，进而得到 。 证毕。 几何性质 其五 在阿基米德三角形中，有 。 评析：根据性质一得出的点的坐标代入计算即可验证。 证明： 根据性质一可得 ，距离公式可得 。 同时，在抛物线中满足 ；同理有 。相乘： 证毕。 几何性质 其六 底边 长为 的阿基米德三角形的面积最大值为 。 评析：利用三角形面积等于底乘高除以二，再对高的长度进行放缩即可。 证明： 如图： 为 在 边上的高， 为 中点。令 。 易知 ，在 时等号成立。。 根据性质一，，，。 此时 ，当且仅当 时取得等号。 证毕。 新定义曲线 伯努利双纽线 平面内一点 到 轴两定点 的距离之积为定值 的曲线叫做伯努利双纽线（简称双纽线），其解析式为 。若定点在 轴上则为 。 伯努利双纽线 的图像如下： 轨迹方程 评析：设点计算。 解： 令 ，，可得： 拓展变形：定点在 轴上时同理。 顶点极值 双纽线上下四个顶点为 。 评析：可利用二次方程判别式，来求解其极值。 证明： 令直线 ，联立得 。根据图像对称性可知，若交点存在，则必为一对或两对绝对值相等的值。用二次项 换元四次项 得 ，整理得 换元后的方程仅有一个实根，则 ，即： 反解得此时横坐标为 ，即曲线的上顶点为 。同时不难发现其左右顶点为 。 证毕。 整点 在双纽线上，且横纵坐标均为整数的点叫做整点。 评析：首先根据上面给出的方法计算出顶点极值，接着在整数范围内套公式计算。 例如章头给出的双纽线 ，结合上一节算出横纵坐标的取值范围 。由于 的范围较小，枚举 方便些。 时， 在图像上，只有 符合要求； 时，解方程 ，换元可得 ，开根不可能得出整数。枚举完毕，整点仅 。 切记不要忘记原点也在图像上。 带旋圆锥曲线 / 非标准型圆锥曲线 旋转变换 点 绕原点逆时针旋转 角后的新坐标为 ，顺时针旋转 角后的新坐标为 。 评析：如果你了解线性变换的相关知识，你就会知道这其实是乘旋转矩阵得到的结果。但如果你不知道，我们可以不用线性代数知识，现场推导一番。 证明： 令 ，假设 与 轴正半轴所成角为 ，那么 ，整理得 。由几何关系和旋转可得，。以 推导为例： 同理可得 ，再如上算出 点坐标，即证得成立。 证毕。 拓展变形： 如何将这一点运用到圆锥曲线上来呢？我们根据这个原理，联想到圆锥曲线的旋转本质上是将曲线上每一个点都做旋转变换，每个点的横纵坐标变换都满足如上规则。因此如果将圆锥曲线写成一个函数形式 ，那么对应的逆时针旋转就是将函数变为 ，顺时针同理。 当然，旋转后的圆锥曲线与原圆锥曲线的形状是相同的。这意味着圆锥曲线的离心率等由其本身形状所决定的量不会发生改变，但是垂径定理、圆周定理将不再适用。","categories":[{"name":"文化课","slug":"文化课","permalink":"https://justpureh2o.cn/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"文化课","slug":"文化课","permalink":"https://justpureh2o.cn/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"}]},{"title":"竞赛赋（并序）","slug":"feelings-related-to-oi","date":"2025-01-04T06:21:49.845Z","updated":"2025-01-04T16:33:26.948Z","comments":true,"path":"articles/29837/","link":"","permalink":"https://justpureh2o.cn/articles/29837/","excerpt":"","text":"竞赛赋 甲辰冬月十四，余与诸生从师外出而行退役之礼，相谈甚悦。然颇感竞赛之事，乐中生涩，戚然惋叹；念生涯一载悲喜，情涌而溢；视后生善学能思，审而后行，赞意不止；望东辰瘴晦毕见，择才尽废，不知所言。凡喜、憾、恸、诽四情深切，欲却之而不遂。是故致志此篇，以为竞赛辞藻之绝笔作也。 言及竞赛，虽曰迁升保送之至道，然余竟不敢苟同。私以为竞赛者，千军悬战于独木也。独木易泮，杂兵劣骑亦与之坠矣。保送之言诚矣，然略其艰；迁升之论亦真，然省其苦。凡数、理、化、生、信五子者，皆非易得。 数者演天地之行，物者究万物之理，化者点土石为金，生者析命之臧否。数者，以理析物也——天下之行、至微之动、未元之形，皆可以数毕覆之；物者，涵巨细之动也——星运光转、浪沫浮沉、温冻之候，尽演之于纸上；化者，辟物于太虚也——气相氤氲、水溢四隅、固其金银，皆自石出；生者，探命之源也——阴阳演序、搏脉送血、肺之张翕，可以示也。 至于信者，思辨操纵之术也——智高者盖败于机器之操纵，善纵者或溃于思智，岂非此理耶？故欲工于信竞者，先致足智、兼修操纵；致智需己有材，平日愈精之；操纵者，勤练则几可成之。微此二者，安闻先人竞赛之盛迹？由此观之，智得纵明，可工也。 竞赛之徒，作业之患常有。二者兼善，诚神人也。然诸生终非神人，语数外物化生之择常有。余以为，舍物而保数、去生而存化、屏英而就语，实为至道。物理者，数之枝节也，近节而离根，非智也；生物者，化学之于命理也，趋小而舍大，非明也；英语者，蛮夷之语也，不通国语，何谈精之？且数、理、化、生四科，竞赛所学足可书之少顷之间，或暂略之。然信息未于常规之列，因之亦有效。 余入赛一岁有余，数理化信四赛为塾凡三十余者。省一仅一，省二、三，兼以未获者若干。或曰：“为学若久，宜多一等，颓靡至此，以君之材，岂非异耶？”此言诚然，然东辰异地，淆或主次。明言竞赛之重，暗则弃赛应试。生徒苦之，然上不顾，求之兼善，颠也。所谓师者，非尽其则，有甚者全然不顾，倚偶然之功，傲极忘本。虽曰“师不必贤于弟子”，然其不解人惑、坑骗以圈民财、要誉而损生徒。师者若此，宜唾之且袪之若攻疾者然。 缘竞赛成败，固出于人，然物况不可尽略也。修身之识，次配以周身之净，并贤师、同辈高才者，得胜之基备矣。若空持其才，顾无律己之念，终荒废其业，出头难矣；若有才克己，然遇无良念之师，私欲害人，出头亦难矣。审吾辈三十者，岂非此二类耶？ 译文 （公历）2024 年 12 月 14 日，我和各位（信息）竞赛生外出参加退役仪式，交谈十分愉快。然而我对竞赛之事感触颇深，快乐中生出苦涩之情，感伤地叹惋；想起竞赛一年来的悲伤与喜悦，情感翻涌而满溢；看到下一届竞赛生善于学习、能思考，审视清楚（情形）后才行动，（我的）赞美之意不绝；看到东辰肮脏丑陋的一面全部显现，挑选出的有才之人全被东辰所浪费，不知道该说些什么。综合喜悦、感慨、悲伤、怨悱四种深切的情感，（我）想要除去这些情感却没能成功。因此在这篇文章中表达自己的意志，把它作为竞赛生涯中的绝笔之作。 说到竞赛，虽然说它是降分保送大学的最好方式，然而我最终也不敢苟且同意。我认为竞赛就像是千军万马在独木桥上交战。独木桥容易断裂，杂兵和劣马都与它一起坠落（到深渊）。（说竞赛能）保送的话确实是真的，然而却省略了它的艰难；降分录取的话也是真的，然而省略了它的艰苦。数理化生信息这五个竞赛，（保送或降分录取）都是难以达到的。 数学竞赛推演天地的运行，物理竞赛研究万物的道理，化学竞赛将土石变成黄金，生物竞赛分析生命的福祸。数竞是用道理分析物体（的竞赛）——世界的运行、微小物体的运动、从未出现的形态，全都可以用数字覆盖；物竞涵盖了极大和极小物体的运动——星辰和光线的运动与流转、海浪浮沫的沉降浮起、温暖和冰冻的气候，都能在纸上推演出来；化竞从虚空中开辟新的物质——气体弥漫、液体四下溢出、金银的坚固，都能从石头中（显现）出来；生竞探索生命的起源——阴阳按次序运转，血脉搏动送出血液、肺的一张一合，都可以展示出来。 到了信竞，（它）是思维和操纵的技术——有智力的人可能在操作机器的方面失败，善于操作的人也可能在思维方面输给别人，难道不是这个道理吗？因此想要在信息竞赛方面取得成效，先要获得足够的知识、同时训练操纵；获得知识需要自己有一定天赋，平常（在练习中）更加精进；操纵的技巧勤于练习就可以几乎精通。如果没有这两点，从哪里听说学长竞赛的盛大事迹呢？由此可见，知识和操纵都通晓，就可以（在这方面）有成效。 我参加竞赛已经一年多了，数理化信息四科竞赛的学生组成的共三十多人的班级。仅有一个省一等奖，省二等奖、三等奖，以及没获奖的人有很多。有人说：“（你们）学了（竞赛）这么久，应该有很多一等奖，像这样萎靡不振，按照你们的才能，难道不会让人感到奇怪吗？”这话说对了，然而身处东辰这样的怪地方，（东辰）混淆主次。表面上说竞赛的重要，私下里又舍弃竞赛（让竞赛生）去（复习）考试。老师和学生对此都很苦恼，然而上级领导不管这些，要求学生（竞赛和常规课）都好，是糊涂（的行为）。那些所谓的“竞赛教练”，没有尽职尽责，更有甚者完全不管学生，依靠偶然得来的功名，极其骄傲忘记了本职。虽然说“老师不一定要比学生贤明”，但是他解答不了疑惑、坑骗（家长）来圈集普通人的财产、为博取名誉而损害老师和学生的利益。像这样的教练，应该唾弃并且像治病那样祛除他。 追寻竞赛成败（的根本原因），固然出自于学生本人，然而客观环境也不能完全忽略。修养自身的学识，接下来搭配环境的清净健康，加上贤明的教练、有才能的同学，取得成绩的基础就完备了。如果只有才能，却没有自律的观念，最终只会荒废竞赛学业，很难出成绩；如果有才能、并且能自我约束，然而遇见没有好念头的教练，（他的）私欲祸害学生，也很难出成绩。再来审视我们这三十多个竞赛生，难道不是因为这两种情况（才没出成绩）吗？","categories":[{"name":"鲜花","slug":"鲜花","permalink":"https://justpureh2o.cn/categories/%E9%B2%9C%E8%8A%B1/"}],"tags":[{"name":"鲜花","slug":"鲜花","permalink":"https://justpureh2o.cn/tags/%E9%B2%9C%E8%8A%B1/"}]},{"title":"望君莫守旧时憾，焦原春来又青青","slug":"post-oi-period-conclusions","date":"2024-12-13T22:47:39.505Z","updated":"2025-01-19T16:34:32.567Z","comments":true,"path":"articles/27270/","link":"","permalink":"https://justpureh2o.cn/articles/27270/","excerpt":"","text":"序 甲辰冬月十四，余与诸生从师外出而行退役之礼，相谈甚悦。然颇感竞赛之事，乐中生涩，戚然惋叹；念生涯一载悲喜，情涌而溢；视后生善学能思，审而后行，赞意不止；望东辰瘴晦毕见，择才尽废，不知所言。凡喜、憾、恸、诽四情深切，欲却之而不遂。是故致志此篇，以为竞赛辞藻之绝笔作也。 ——《〈竞赛赋〉序》 选择信息竞赛，无非是我先前在计算机方面有一定基础（并非算法方面）、同时有一部分原因是学校和老师，后者具体表现在年级单独开设竞赛班、并安排最好的师资力量进行常规课教学。正是看中了后者，尽管错过了九年级下与高一上期衔接的暑假集训和竞赛班报名，我最终还是和已经做了两年同班同学的 @Brilliant11001（XYF）；九年级的同班同学 @HYLW（WWH）；九年级虽然不在同一个班但是也经常一起混的 @Stairs_upon_temple（GZ）；还有一个外校招过来的平行班竞赛大佬 @Aventurine_stone（YYC） 进入了高 2023 届信息竞赛队，并与高 2022 届的学长相识。虽然认识时间短暂，但是凭着两届九人强大的自来熟能力（主要还是 GZ 极大拉进我们之前的关系），我们很快打成了一片。在此先对高 2022 届的信息竞赛生表示衷心祝愿（高考得胜、未来可期），于下照次列出他们的洛谷账号： 起 言至竞赛，虽曰迁升保送之至道，然余竟不敢苟同。私以为竞赛者，千军悬战于独木也。独木易泮，杂兵劣骑亦与之坠矣。保送之言诚矣，然略其艰；迁升之论亦真，然省其苦。凡数、理、化、生、信五子者，皆非易得。数者演天地之行，物者究万物之理，化者点土石为金，生者析命之臧否。信者，思辨操纵之术也——智高者盖败于机器之操纵，善纵者或溃于思智，岂非此理耶？故欲工于信竞者，先致足智、兼修操纵；致智需己有材，平日愈精之；操纵者，勤练则几可成之。微此二者，安闻先人竞赛之盛迹？由此观之，智得纵明，可工也。 ——《竞赛赋》 相信大家学竞赛，多多少少也是受了“竞赛保送/降分/少年班论”的影响（纯热爱党请忽略之）。但是，残酷的事实又会迎头给你来上一记闷棒。保送的难度有多大想必不用多说，尤其是身处强省、却缺少较为系统化的竞赛训练体系的同学们，可能学了几年，还是入不得省队、甚至省一等也没得到。最终也只得是空乏其身、（竞赛生涯）郁郁而终。此外，不难发现，五大学科竞赛只有信息技术是不属于高考科目的，也就是说信息竞赛对文化课的帮助几乎为零……因此，在最终选择踏入这条路前，好好掂量轻重得失、必要时可以选择退赛及时止损。但假若你真的踏入了这条残酷的赛道、并决定坚持走下去，那就尽自己所能、勿要留下任何遗憾。 如《竞赛赋》所言，学习信息竞赛、并取得佳绩，起决定性作用的两个因素是“思辨”与“操纵”。前者不必多说，即拥有强大的竞赛思维，当然也包含敏锐的题目直觉；后者则泛指包括敲代码、调试等人机交互方面的事情。对于思维，具备一定的天赋是很吃香的，这代表你可以在比别人更高的起点开始、用更迅捷的步伐前进；而操纵这块，多加练习就几乎能够达到理想效果。 就本届（2023 届）竞赛生来讲，YYC 和 XYF 的思维较强，在操纵方面也毫不逊色；GZ 在思维方面有时存在瑕疵，但整体来说不影响解决题目，只是有时会忽略细节（例如 2023 年 NOIp 他就因为没打 return 0 结果总分直接返回零，详情请见记录1和记录2）；WWH 和我基本没啥思维，这导致只要是套路不明显的题目，我们基本上都会挂，于是我们空留一个会打字的表面功夫。WWH 本人倒是比较擅长动态规划，而且不断在冒出新点子，思维活跃度是在线的。我本人则是思维完全不足，每次都是最后发题解才感慨自己的不足。思维题已经在信竞占据了主导地位，希望下一届的同学们一定要好好提升自己的思维，如果天赋较差，那就尽可能多去用练习填补；同时提升自己的代码能力，这样一来对竞赛将有巨大帮助。 承 起初神创造 NOIp 2024。In the beginning God created NOIp 2024 NOIp 2024 是空虚混沌。渊面黑暗。神的灵运行在考纲上。And NOIp was without form, and void; and darkness was upon the face of the deep. And the spirit of God moved upon the face of the syllabus 神说，要有贪心，就有了贪心。And God said, Let there be greedy; and there was greedy. 神看贪心是显然易证的，就把动规贪心分开了And God saw the greedy, that it was apparently easy; and God divided the greedy from DP. 神称贪心为 T1，称动规为 T2。有 T1，有 T2，这是头两题。And God edited greedy as T1, and the DP he assigned as T2. And edit and the assign were the first two problems. 神说，四道题要能区分，将题分为签到和难题。And God said, Let NOIp be selective, and let it divide from the easiest and the easier. 神造就出容斥，将容斥以前的签到题，容斥以后的难题分开了。事就这样成了。And God made T3, and divided the problems which were ahead of T3 and which were behind T3: and it was so. 神称容斥为 T3。有T1 T2、有T3，是前三题。And God called T3 traverse. And the T1, T2 and T3 were the top three problems. 神说，天下的数据结构要汇集在 T4，使队爷露出来。事就这样成了。And God said, Let T4 be gathered together with data structures, and let the genius appear: and it was so. 神称前三题省一题，称数据结构的聚处为树上查询。神看是好的。And God called T1 T2 T3 basics; and the gathering together of the data structures query; and God saw that it was good. 神说，得奖率要发生降落，和提升的省一线，并上涨的省二线，各从其类，竞赛都难着点。事就这样成了。And God said, Let the award be less, the first award increasing points, the second award ascending lines after his kind, which difficulty is damnly high; and it was so. 于是得奖率降了，和省一省二线提升，各从其类，竞赛变难了。神看着是好的And the award was less, lines got increased after his kind, which difficulty is damnly high; and God saw that it was good. 有四题，有得奖率，是 NOIp 2024And the four problems and the award were the NOIp 2024. ——《创 NOIp 2024 记》 或许你已经知道了，高 2023 届的信竞生们迎头撞上了信息竞赛改革的第一年。CSP-S 提高组第一题的简单其实是一发大糖衣炮弹，意图让我们对 NOIp 2024 放松警戒，也被它得逞了……或许你已经从其他人那里听说，高 2023 届竞赛班的四人的总成绩只比外招竞赛生一人的成绩仅高 5 分……据完全统计，高 2023 届的最终成绩是一个四等加三个三等加一个二等…… 我认为最可惜的是 Brilliant11001，他的努力有目共睹。在 CSP-S 力斩一等之后他便紧接着投入了冲击 NOIp 一等的复习当中。但是由于上文所述“贪心的显然”，他被 T1 卡住、影响了心态，最终没时间去想 T2。赛后还被小灵通骗了一手，直接从预估二等变成三等。尽管有些伤人（据 Brilliant11001 本人所说，他 emo 了一整晚），我还是要将同学写的一首小词放在下面，以表惋惜/劝勉意： 如梦令·岁末赠小又 现代 槿泽 信竞两年无果，恋爱三载终空。把酒莫言欢，旧事不入新梦。一凡、一凡，前路尚且漫漫。 词中“一凡”是 Brilliant11001 的名，因押韵要求故未省略。 Aventurine_stone 的猜结论能力也是公认的强大，然而在杀掉 T1 T2 得到二百分后并没有能在后两题拿到一分。正当我们所有人以为 200 分已经足够省一时，现实又在用 220 这个数字狠狠扯去了这个念头。 我和 HYLW 自不必多说，菜就是菜，然而后者留得一手好 DP 思维在，T2 还是得了 15 分。最后一位可能是心态崩了没发挥好，不再赘述了。 从今年（2025）开始，信息竞赛预计将经历一轮难度上调。事实上，五大竞赛都在这两年陆续完成了改革，我有个化竞哥们告诉我，考试前四天才出的学术论文，考试时就作为考题出现了。由此可见：难度大是共性。而单针对于信息竞赛，则是下调的得奖率。信息竞赛可能再也不是你老师或者是营销号嘴里的“得奖容易”的竞赛了（估计要变成生物竞赛了），因此，对于想要或正在学习信息竞赛的后人，我的忠告是：三思而后行、审慎再审慎。 还有，千万不要在考试前住全季酒店，任何竞赛生都不要，否则全班全寄，亲测为真 合 正文最后，我想用一首词来劝慰苦学 OI、收获却不尽人意的后辈们： 蝶恋花·退役后 鹰翔长空墨客吟，谁见峭壁，血淋雏鹰翼。佳俊归封狼居胥，败者隐去心戚戚。 草叶风过簌簌音，秋来烈火，空余灰与烬。望君莫守旧时憾，焦原春来又青青。 确实，只有先驱强人才会被铭记、失利隐退之人又为谁所传颂？我的班主任有时对我们说成都七中和成外的竞赛生有多么厉害、有多少人又被 985、211、C9 甚至清北提前录取，当然他的本意是想让我们好好学竞赛，有朝一日也能抓住这样的机会。但是面对那些竞赛强校出来的天赋型选手，我们连省一都很困难，更别说打进省队、甚至国赛了。 当然，说起我自己，整个竞赛生涯只获得了两个三等奖（平常互相打趣，说成六个一等奖）。有一首词是为我画像的，它说： 如梦令·生涯回首 去年誓夺一等，初赛未捷目送。百日磨兵戈，惨败显然易证。三等、三等，妈的还是三等。 因此，我建议正在成都东辰苦学竞赛的人不要把自己的资本全梭哈在竞赛上。在成都东辰，走出来还得靠文化课水平。如果你们这一届还有单独开设的竞赛班的话，想必都已经配备了最好的师资力量。竞赛走不出来，那就固守文化课，我相信这应该是成都东辰所有竞赛生最终的归宿吧…… 对于退赛后的生活，我的建议是：一定要找老师补课。我去 NOIp 前只停了一周的课，然后生物就讲了一整章，结果我至今都不会，晚上返校还要默写那一块的内容。退役后成绩下降是常有的事，你只需要快速摆正状态，重新投入常规课学习即可。 跋 本文作于 2024 年 12 月 14 日下午，退役的第二周；终于 2025 年 1 月 1 日，新年的第一天。笔者在和 2023 届（我所在的一届）与 2024 届的信息竞赛生一同吃完退役饭后对我的一年半竞赛生涯的所感。受同届竞赛生的博客文章 @HYLW 致未来·我们都是历史 的启发，于此发表一篇我个人对竞赛生涯的总结与对未来的展望、以及对下一届乃至今后成都东辰所有信息竞赛生的劝慰与勉励。","categories":[{"name":"鲜花","slug":"鲜花","permalink":"https://justpureh2o.cn/categories/%E9%B2%9C%E8%8A%B1/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"鲜花","slug":"鲜花","permalink":"https://justpureh2o.cn/tags/%E9%B2%9C%E8%8A%B1/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.cn/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"},{"name":"NOIp","slug":"NOIp","permalink":"https://justpureh2o.cn/tags/NOIp/"}]},{"title":"CF 755D - PolandBall and Polygon 题解","slug":"solution-cf755d-polandball-and-polygon","date":"2024-11-27T04:32:36.654Z","updated":"2024-11-27T05:55:53.363Z","comments":true,"path":"articles/755/","link":"","permalink":"https://justpureh2o.cn/articles/755/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：CF 755D 题目难度：提高+/省选- 给出一个 边形，和距离 。 第一次连接 和 ，第二次连接 和 ，依次进行 次，每次结束后输出 边形被分割成了几个区域。 ，保证 和 互质。 今天模拟赛 T2 原题，赛时多测卡线段树加上多测没清空喜爆零。同机房大佬 Brilliant11001 用 惊天地泣鬼神纯数学做法 A 的，在此表示深深膜拜 %%%。 为了取模方便，本文是 0-index 的。 首先，根据互质关系可得，本题无需考虑重边的情况。因为在 0-index 下，题目可以看作是 向 连边，因此只有满足 时才可能出现重边，这要求 ，而 （互质），所以 ，且是 的倍数时才会出现重边，对应 次操作之后。本题中只考虑前 次操作，因而不存在重边问题。 手搓可以发现第一个规律： 具有对称性，即 和 作为步长时的答案是相同的，只是连边顺序相反而已。 接着研究，发现第二个规律——连边带来的贡献是当前边与已有边的相交次数加一。我们的核心任务就是维护当前边会与多少已连接的边相交。 假设当前待连的边是 。仔细观察样例可发现，其实相交线段个数就是 到 （注意顺序，不是 到 ）间内每个点的度数之和（多边形本身的边不计入度数）。因此对于每次操作，我们获得区间 内所有点已经连出边的总数即可，注意特判右端点是否越过节点 。贡献的产生如下图： 线段树的常数还是很大的，建议使用树状数组（或者上边大佬的数学做法）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define N 1000010using namespace std;typedef long long ll;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; ll sum;} tree[N &lt;&lt; 2];void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum;}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int uid) { if (tree[idx].size == 1 &amp;&amp; tree[idx].l == uid) { tree[idx].sum++; return; } int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (uid &lt;= mid) modify(le(idx), uid); if (uid &gt; mid) modify(ri(idx), uid); pushup(idx);}ll query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sum; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; ll ret = 0; if (l &lt;= mid) ret += query(le(idx), l, r); if (r &gt; mid) ret += query(ri(idx), l, r); return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, k; cin &gt;&gt; n &gt;&gt; k; k = min(k, n - k); build(1, 0, n - 1); int pos = 0; ll section = 1; for (int i = 1; i &lt;= n; i++) { int L = (pos + 1) % n, R = (pos + k - 1 + n) % n; // 左右端点 ll sum = R &lt; L ? query(1, 0, R) + query(1, L, n - 1) : query(1, L, R); // 获得区间内每个点连出去多少条边，注意判断是否跨过节点 0 modify(1, pos); // 为当前的线段端点累加 1 modify(1, (pos + k) % n); section += sum + 1; // 图形总数 pos = (pos + k) % n; // 跳到下一个位置 cout &lt;&lt; section &lt;&lt; ' '; } return 0;} AC 记录","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"基础数据结构 树状数组","slug":"algorithm-fenwick-tree","date":"2024-11-21T18:19:01.819Z","updated":"2024-11-28T15:53:49.079Z","comments":true,"path":"articles/29882/","link":"","permalink":"https://justpureh2o.cn/articles/29882/","excerpt":"","text":"前言 我在第一次决定学树状数组前就预先接触过线段树的基本概念和操作，当时只觉得树状数组能做到的事情线段树也能做到。不仅如此，线段树朴素的二分思想在我看来是易于树状数组的 lowbit 规律的，综上种种，那时我便跳过了树状数组的学习。而如今接触到了各种线段树无法轻易解决的问题（偏序、逆序对等），才记起树状数组的各种好，经过再三斟酌，我决定还是简单学习一下树状数组。 基本概念 二进制分解 迄今为止我们已经接触过很多数字分解法，例如斐波那契数列的齐肯多夫表示法、基于算术基本定理的质因子拆分法、多重背包中用到的二进制分解法。在树状数组中，依然是信息学喜闻乐见的二进制来为之赋能，可以说树状数组就是完全搭建在二进制分解的基础上的。 对于一个自然数 ，它一定可以被分解为若干二次幂的和。即 。 根据这点，把 划成若干区间： 区间的大小分别为 。观察每个小区间的右端点 ，它们的二进制分解形式就是右端点的和式 ，那么这个区间的大小就是 ，幂数也就是 的二进制分解中最小元素的幂数，进而， 的二进制 0/1 表示中 1 的最小位置。 lowbit 算符 得到了规律，我们自然想要求出二进制最低位 1 的位置，实践中常用 lowbit 函数，它的定义是 x &amp; -x。根据计算机处理负数的知识——负数的二进制相当于各位取反再加 1。较高位（比最低位 1 更高的所有位）在进行按位与运算时都会被消成 0，而较低位（不比最低位 1 更高的所有位）取反后均是 1，加上 1 之后会不断进位直到最低位 1 的位置（取反后为 0，进位后为 1），按位与运算就可以保留下这一位而消去其他位。结果就是 。例如：，因为 ；，因为 。 在 系统中，标准库还提供一个函数 ffs，即 Find First bit Set，它返回最低位 1 的位置，相当于对 lowbit 取以二为底的对数。 更多位运算相关库见 [奇技淫巧] C++ 编程小寄巧 GCC 内建函数的巧用 树状数组 来源：洛谷 @DWHJHY 树状数组 FENWICK TREE 结合图示，我们把树状数组节点的几个性质讲解一下： 除根节点外，节点 的父节点是 。反之，满足 的所有节点 都是 的子节点。 节点 的子节点数为 。 令 ，不断递归计算 直到结果为 前的最后一个 值与先前的所有 值作为树状数组下标求和得到的总和即等于 的前缀和。（具体见区间查询部分） 树的深度为 ，当节点数不足 2 的整数次幂时结构为森林。 其实树状数组可以不用建树，而是直接维护前缀和。当我们对树状数组插入数据时（假设原数组为 ，树状数组为 ），像线段树的上传操作一样，我们从子节点开始不断向父节点进行更新，也就是不断对下标加上当前下标的 值直到超出 的范围。 123void modify(int u, int x) { for (int i = u; i &lt;= n; i += lowbit(i)) c[i] += x; // 不断跳到父节点并累加值} 在统计时，用 和 的前缀和相减获得区间总和。 12345int query(int r) { int ret = 0; for (int i = r; i; i -= lowbit(i)) ret += c[i]; // 根据性质 3，求得 [1,r] 区间内的前缀和 return ret;} 以上两种便是树状数组的基本操作。 简单维护策略 前缀和 例题：CF755D 难度：提高+/省选- 给出一个 边形，和距离 。 第一次连接 和 ，第二次连接 和 ，依次进行 次，每次结束后输出 边形被分割成了几个区域。 互质，。 注意到每次连边对总区域数的贡献是该线段与已有线段的相交次数加一。我们的问题就转化成计算相交线段的个数。观察可得它其实就是端点 到 间经过的所有点的度数之和（多边形本身的边不计入度数），因此维护一个线段树/树状数组，每次询问 内的和，再对两端点的值加一即可。 题解同步于本站 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 1000010#define lowbit(x) (x &amp; -x)using namespace std;typedef long long ll;ll c[N];int n;void modify(int u) { for (int i = u; i &lt;= n; i += lowbit(i)) c[i]++;}ll query(int R) { ll ret = 0; for (int i = R; i; i -= lowbit(i)) ret += c[i]; return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int k; cin &gt;&gt; n &gt;&gt; k; k = min(k, n - k); ll section = 1; int pos = 1; for (int i = 1; i &lt;= n; i++) { int R = pos + k; // 获得右端点 ll sum; if (R &gt; n) R %= n, sum = query(R - 1) + query(n) - query(pos); // 如果跨过 0 节点，特判 else sum = query(R - 1) - query(pos); // 正常前缀和 modify(pos); // 更改两个端点 modify(R); section += sum + 1; pos = R; cout &lt;&lt; section &lt;&lt; ' '; } return 0;} 实测树状数组的时间大约是线段树的四分之一。 差分 例题：P4939 Agent2 难度：普及/提高- 在线段树维护区间种类数一节中，我们已经探讨过利用差分数组和前缀和来解题的具体原理，树状数组亦然。树状数组维护可差分信息和小常数的天生特性使得它在这类题目中表现良好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define N 10000010#define lowbit(x) (x &amp; -x)using namespace std;typedef long long ll;int start[N], ed[N];int n;void modifyS(int u) { for (int i = u; i &lt;= n; i += lowbit(i)) start[i]++;}void modifyE(int u) { for (int i = u; i &lt;= n; i += lowbit(i)) ed[i]++;}int queryS(int u) { int ret = 0; for (int i = u; i; i -= lowbit(i)) ret += start[i]; return ret;}int queryE(int u) { int ret = 0; for (int i = u; i; i -= lowbit(i)) ret += ed[i]; return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int m; cin &gt;&gt; n &gt;&gt; m; while (m--) { int op, l, r; cin &gt;&gt; op &gt;&gt; l; if (op == 0) { cin &gt;&gt; r; modifyS(l); modifyE(r); } else cout &lt;&lt; queryS(l) - queryE(l - 1) &lt;&lt; endl; } return 0;} 区间加+单点查询 例题：CF44C Holidays 难度：普及/提高- 如果本题没有保证 的话，它将会更加复杂。 轻易可以看出，我们需要对给出的区间进行区间加一，结束后枚举每个点的值是否恰好是 。在线段树区间加等差数列一节中，我们给出了将原序列转化为差分序列、将区间加等差数列转化成区间两端点的单点操作的解决方案。本题要求区间加一个常数列，即特殊的等差数列。实际维护方法和线段树是相同的——左端点加上首项，右端点右侧第一个点减去末项，本题中首项末项均为 。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define N 110#define lowbit(x) (x &amp; -x)#define START 0#define END 1using namespace std;int n;int c[N];void modify(int u, int x) { for (int i = u; i &lt;= n; i += lowbit(i)) c[i] += x;}int query(int u) { int ret = 0; for (int i = u; i; i -= lowbit(i)) ret += c[i]; return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int m; cin &gt;&gt; n &gt;&gt; m; while (m--) { int l, r; cin &gt;&gt; l &gt;&gt; r; modify(l, 1); if (r &lt; n) modify(r + 1, -1); //树状数组其实无需判断边界，但是线段树是必需的 } for (int i = 1; i &lt;= n; i++) { if (query(i) ^ 1) { cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; query(i) &lt;&lt; endl; return 0; } } cout &lt;&lt; \"OK\" &lt;&lt; endl; return 0;} 权值树状数组 普通的树状数组维护的信息（原序列前缀和/差分）有时不能满足我们的多样化需求，此时权值树状数组便应运而生。它类似于桶，通过维护原序列中每个数的出现次数来化简一些比较棘手的问题。在原序列值域很大，或者是只关心元素间相对大小关系时十分有用。 逆序对 例题：P1908 逆序对 难度：普及/提高- 逆序对的定义是：对于给定的一段正整数序列，逆序对就是序列中 且 的有序对。给定一段长度为 的数列，求出逆序对的数量。 我们只关心元素间的大小关系，符合权值树状数组的使用范畴，因此离散化并建立之。接下来是如何处理逆序对的问题。 考虑将待插入数列升序排序（第二关键字为下标升序）然后依次插入。假如原序列中 最小，它将被第一个插入，具体是在树状数组的 位置增加 并向上更新。数字是从小到大插入的，因此逆序对只会出现在 位后面， 减去 内的前缀和即为答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define N 500010#define lowbit(x) (x &amp; -x)using namespace std;typedef long long ll;typedef pair&lt;ll, int&gt; PII;ll c[N];PII a[N];int rnk[N];int n;bool cmp(const PII &amp;l, const PII &amp;r) { return l.first == r.first ? l.second &lt; r.second : l.first &lt; r.first;}void add(int u, int x) { for (int i = u; i &lt;= n; i += lowbit(i)) c[i] += x;}ll query(int l) { ll sum = 0; for (int i = l; i; i -= lowbit(i)) sum += c[i]; return sum;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].first, a[i].second = i; sort(a + 1, a + n + 1, cmp); for (int i = 1; i &lt;= n; i++) rnk[a[i].second] = i; ll ans = 0; for (int i = 1; i &lt;= n; i++) { add(rnk[i], 1); ans += i - query(rnk[i]); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 区间第 k 大问题 例题：P1168 中位数 难度：普及+/提高 权值树状数组的一个强力应用就是求解区间第 大。 由题可知，有 个元素的数列的中位数就是它的第 大元素。我们只需在读入奇数个数时输出已有区间的第 大即可。因而问题简化成求解区间第 大。首先对输入数据离散化，然后据此建立权值树状数组。 在权值树状数组上，我们要求最小的 使得 且 成立，此时第 项即为所求。一般来说，我们会想到二分 ，这样的时间复杂度是 ，数据大时无法通过。 此时我们借助树状数组下标之间的关系，进一步优化二分过程。事实上，我们选择用倍增来替代二分。这个做法其实是基于树状数组下标与 lowbit 值之间的恒等关系：对于区间 ，它的区间和是 。 具体流程如下： 令区间 的前缀和 ，待求答案 。 让 从 开始倒序循环到 。 ，检查此时的 是否超出边界 ，或者是 的前缀和 是否非严格大于 。若是，则撤销此次倍增，还原 ；否则保留更改，同时 。 循环结束后，返回 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define N 100010#define lowbit(x) (x &amp; -x)using namespace std;typedef long long ll;int n;int a[N], b[N];ll c[N];int cnt = 0;void modify(int u, int x) { for (int i = u; i &lt;= cnt; i += lowbit(i)) c[i] += x;}int query(int k) { ll s = 0; int x = 0; for (int i = log2(cnt) + 1; i &gt;= 0; i--) { // 倍增 x += 1 &lt;&lt; i; // 尝试倍增 if (x &gt; cnt || s + c[x] &gt;= k) x -= 1 &lt;&lt; i; // 不符合要求，撤销倍增 else s += c[x]; // 保留倍增，更新前缀和 } return x + 1;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = a[i]; sort(a + 1, a + 1 + n); cnt = unique(a + 1, a + 1 + n) - a - 1; for (int i = 1; i &lt;= n; i++) b[i] = lower_bound(a + 1, a + 1 + n, b[i]) - a; // 排序去重离散化 for (int i = 1; i &lt;= n; i++) { modify(b[i], 1); if (i &amp; 1) cout &lt;&lt; a[query(i + 1 &gt;&gt; 1)] &lt;&lt; endl; } return 0;} 三元序列问题 例题：P10589 楼兰图腾 难度：普及+/提高 根据乘法原理，对于某个点 ，它能构成的符合要求的 V 形三元组的总数是它左侧严格大于它的点的数量乘以它右侧严格大于它的点的数量，反之亦然。问题转化成了如何维护某个点左右两侧比它大/小的点的总数。 同样是先离散化建立两个权值树状数组，一个维护左侧信息、另一个维护右侧信息。在维护左侧相关信息时按正序添加节点。因为权值线段树维护一段升序序列，因此先加入（在左侧）、且比当前点小的点的数量就是 的前缀和；对应的，因为已经添加了 个数，在左侧又有 个数小于等于 ，那么在左侧且比它大的数就共有 个。这也是树状数组维护逆序对的思路。 维护右侧点就换个顺序，倒序添加节点。基本思路和维护左侧节点相同。维护右侧比它小的节点数时，显然就是前缀和；而求解右侧比它大的节点数时，因为右侧已经有 个节点，又有 个比它小，那么相减即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define N 200010#define lowbit(x) (x &amp; -x)using namespace std;typedef long long ll;int n;int a[N], b[N];int L1[N], R1[N], L2[N], R2[N];int c1[N], c2[N];void modify(int c[], int u, int x) { for (int i = u; i &lt;= n; i += lowbit(i)) c[i] += x;}int query(int c[], int u) { int ret = 0; for (int i = u; i; i -= lowbit(i)) ret += c[i]; return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = a[i]; sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; i++) b[i] = lower_bound(a + 1, a + 1 + n, b[i]) - a; for (int i = 1; i &lt;= n; i++) { modify(c1, b[i], 1); L1[i] = query(c1, b[i] - 1); // 左侧比它小 L2[i] = i - query(c1, b[i]); // 左侧比它大 } for (int i = n; i; i--) { modify(c2, b[i], 1); R1[i] = n - i - query(c2, b[i]) + 1; // 右侧比它大 R2[i] = query(c2, b[i] - 1); // 右侧比它小 } ll ans1 = 0, ans2 = 0; for (int i = 1; i &lt;= n; i++) { ans1 += 1ll * L2[i] * R1[i]; ans2 += 1ll * L1[i] * R2[i]; } cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; endl; return 0;} 维护动态规划 在动态规划中，善用各种数据结构，有时可以将暴力转移的时间复杂度除以一个 。例如单调数据结构优化、斜率优化等。这里将介绍树状数组在维护动态规划权值上的一些应用。 k 元严格上升子序列计数 例题：UVA12983 The Battle of Chibi 难度：普及+/提高 设状态为 表示长度为 且以 结尾的 元最长上升子序列的个数。转移就是 ，但是总时间复杂度是 的，不能接受。 注意到 产生贡献当且仅当 。可以先将 离散化，当一个状态 完全转移完之后，我们把它的值加到 对应的位置上。运算 时，就可以把排名前 的和加入进来，刚好就涵盖了所有小于 对应的 的值。因此建立树状数组维护即可，时间复杂度成功降落到 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define N 1010#define MOD 1000000007#define lowbit(x) (x &amp; -x)using namespace std;typedef long long ll;int n;int a[N], b[N];ll c[N], dp[N][N];void modify(int u, ll x) { for (int i = u; i &lt;= n; i += lowbit(i)) c[i] += x;}ll query(int u) { ll ret = 0; for (int i = u; i; i -= lowbit(i)) ret += c[i]; return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t; cin &gt;&gt; t; for (int x = 1; x &lt;= t; x++) { memset(dp, 0, sizeof dp); int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = a[i]; sort(a + 1, a + 1 + n); unique(a + 1, a + 1 + n) - a - 1; for (int i = 1; i &lt;= n; i++) b[i] = lower_bound(a + 1, a + 1 + n, b[i]) - a + 1; // 让排名全严格大于 1 for (int i = 1; i &lt;= n; i++) { memset(c, 0, sizeof c); // 树状数组记录每个 i 对应的值，因此 i 变化后树状数组也要清空 if (i == 1) modify(1, 1); // 相当于 dp[0][0] = 1 for (int j = 1; j &lt;= n; j++) { dp[i][j] = (dp[i][j] + query(b[j] - 1)) % MOD; // 无需再枚举之前比它小的点，直接加上贡献即可 modify(b[j], dp[i - 1][j]); // 将小于 b[j] 的点的贡献加入树状数组 } } ll sum = 0; for (int i = 1; i &lt;= n; i++) sum = (sum + dp[m][i]) % MOD; // 对所有长度为 m 的序列个数求和 cout &lt;&lt; \"Case #\" &lt;&lt; x &lt;&lt; \": \" &lt;&lt; sum &lt;&lt; endl; } return 0;} ```","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"P11280 - Jom & Terry 题解","slug":"solution-p11280-jom-and-terry","date":"2024-11-16T00:51:08.970Z","updated":"2024-11-16T00:51:09.392Z","comments":true,"path":"articles/11280/","link":"","permalink":"https://justpureh2o.cn/articles/11280/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P11280 题目难度：普及/提高- Terry 和 Jom 在一个 个点 条边的有“根”无向连通图上博弈（图的根为 ），遵循以下规则： Terry 先手； 两人轮流在图上移动，每次只能走一条边（也可以睡觉，啥都不干）； Terry 不能走到 Jom 所在的结点（我们认为只有 Terry 自投罗网时才会被抓到，即如果 Terry 先移动到结点 后 Jom 在同一回合也移动到 是合法的）。 每次询问给定 Terry 和 Jom 的起点 ，你需要回答 Terry 能否到达点 。 为了避免题面命名给个人理解带来的混乱，本题解将用“猫”（Jom）、“鼠”（Terry）来区分二者。 我们的目的是让鼠无论如何都能在猫之前到达 ，因此我们先考虑猫的最优策略——当猫使用最优策略都无法抓到鼠时，那必定有鼠必胜。 鼠的唯一目的地是 ，因此猫只需先到 点，然后等着它就好了。于是猫一定会沿着到根的最短路径前行，而鼠为了不被抓住也会沿着距离根最短的那条路径行进。我们只需在最开始预处理出每个节点到 的最短距离即可。预估时间复杂度是 的 。 注意不要把 Terry 和 Jom 搞混了；输出量较大，慎用 endl（时间膨胀一倍多）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define N 1000010using namespace std;struct Edge { int to, ne;} edges[N &lt;&lt; 1];int h[N], idx = 0;int dep[N];int n, m, r;void add(int u, int v) { idx++; edges[idx].to = v; edges[idx].ne = h[u]; h[u] = idx;}void bfs() { queue&lt;int&gt; q; q.push(r); dep[r] = 0; while (!q.empty()) { int t = q.front(); q.pop(); for (int i = h[t]; ~i; i = edges[i].ne) { int j = edges[i].to; if (dep[j] &gt; dep[t] + 1) { dep[j] = dep[t] + 1; q.push(j); } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(dep, 0x3f, sizeof dep); memset(h, -1, sizeof h); int q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; r; while (m--) { int u, v; cin &gt;&gt; u &gt;&gt; v; add(u, v); add(v, u); } bfs(); cin &gt;&gt; q; cout &lt;&lt; \"I'm here!\" &lt;&lt; endl; while (q--) { int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (dep[a] &lt;= dep[b] ? \"Terry\" : \"Jom\") &lt;&lt; '\\n'; } return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"搜索算法","slug":"搜索算法","permalink":"https://justpureh2o.cn/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"P11253 [GDKOI2023 普及组] 小学生数学题","slug":"solution-p11253-xxs-math-problem","date":"2024-11-09T02:00:33.445Z","updated":"2024-11-09T02:00:33.798Z","comments":true,"path":"articles/11253/","link":"","permalink":"https://justpureh2o.cn/articles/11253/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P11253 题目难度：普及/提高+ 题目来源：广东 2023 求出和式 的值， 开始我以为这只是一道快速幂的大水题， 敲了一个快速幂然后测试了一下大样例，发现 T 飞了。于是我又用上了不知从哪道题里学来的十进制快速幂，结果还是不行。最后我又类比十进制快速幂写了个百进制快速幂，希望能过一些点，最后还是全 T…… 注意到维护阶乘的复杂度是 ，实际上该题的瓶颈在于如何快速求出 内每个数的 次幂。其次，注意到 ，也即 ，显然是一个积性函数。 又发现线性筛在筛去合数时有一个乘积的形式，于是我们可以借用这个思路，在筛去合数的同时维护这个函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define MOD 998244353#define N 20000010using namespace std;typedef long long ll;int n, k;int cnt = 0;ll prime[N], p[N];bool st[N];ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res % MOD;}ll inv(ll x) { return qpow(x, MOD - 2);}void sieve() { p[1] = 1; for (int i = 2; i &lt;= n; i++) { if (!st[i]) { prime[++cnt] = i; p[i] = inv(qpow(i, k)); } st[i] = true; for (int j = 1; i * prime[j] &lt;= n; j++) { if (prime[j] &gt; p[i] || j &gt; cnt) break; st[i * prime[j]] = true; p[i * prime[j]] = p[prime[j]] * p[i] % MOD; // 维护积性函数 if (i % prime[j] == 0) break; } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; k; sieve(); ll fac = 1; ll ans = 0; for (int i = 1; i &lt;= n; i++) { fac = fac * i % MOD; // 线性维护阶乘 ans = (ans + fac * p[i] % MOD) % MOD; // 计算 } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"线性代数 简明教程","slug":"linear-algebra-explicit-tutorial","date":"2024-11-01T19:37:31.738Z","updated":"2024-12-28T16:40:10.534Z","comments":true,"path":"articles/9306/","link":"","permalink":"https://justpureh2o.cn/articles/9306/","excerpt":"","text":"前言 本文是 所著《线性代数》（原书第十版）的简要总结与算法竞赛方面的扩充，适合线性代数入门者学习并把握线性代数的基本概念和内容。 需要注意的是：本教程中的矩阵表示方法可能与你在课上或是其他教程中看到的有些许出入。为了兼具美观和统一，单行行向量用圆括号包围，变量顶部用向量符号标记，如行向量：，其余情况均以方括号包围；向量/一般变量用单一小写字母或符号表示，矩阵则用大写字母表示，如 矩阵 。 第一章 矩阵与方程组 相信大多数人入门线性代数的第一堂课就是学习如何利用矩阵求解线性方程组的吧。矩阵作为一个仅由数字和括号组成的表示方法，既避免了书写各种未知数符号的麻烦，也能一眼看出各未知量之间的数量关系，实属上乘的表示方法。矩阵的一些特殊性质也可以帮助我们解决一些难以解决的问题。 第一节 方程组与矩阵的互相转化 假设我们有一个方程组：。首先将所有未知数提到等号左侧，常数全部移到右侧。我们暂时先忽略掉等号右边的常数项。我们将每行未知数的系数提取出来，放入矩阵的第一行，矩阵的第一行就表示方程组中第一个方程的未知数系数（没有默认为 0），以此类推到下边几行，最终你会得到一个列数与未知数个数相等、行数与方程个数相等的矩阵。本例中它长成这个样子： 如此得到的矩阵叫做系数矩阵，顾名思义，它只表示了原方程组的系数，而忽略了常数项。 它同时也是一个 矩阵。 一般地，对于一个 矩阵（），它有 行 列。 此时，如果我们加上等号右侧的常数项，原先的 矩阵会变成 的。 人们为了区分常数和系数，选择在书写时将常数加入到最右侧那一列，并且在最右一列的前面加上竖线分隔系数，如此得到的矩阵叫做增广矩阵。 本例中 的增广矩阵形式 写作： 当矩阵元素不明时，我们为了简便表示矩阵本身，采用字母 + 下标 + 括号的方式。例如一个 矩阵 ，可以写作：。 第二节 矩阵的基本运算 一. 矩阵加法 构造相同的矩阵，即两个矩阵行列数相同，称这样的两个矩阵是同型的。 矩阵加法仅限两个同型矩阵，相加时同一行同一列的元素相加即可（增广矩阵同理）。 例如： 矩阵加法满足：结合律、交换律 二. 矩阵减法 矩阵减法是矩阵加法的逆运算，因此对于两个矩阵的形式要求同上，只是相同位置的元素相减而已。 矩阵减法满足：结合律、交换律 三. 标量乘法/矩阵数乘 矩阵的数乘也很简单，让矩阵中每个元素乘以这个数就可以了。 例如： 矩阵数乘满足：交换律、结合律、分配律 四. 矩阵转置 将原矩阵的行变成新矩阵的列，称为矩阵的转置。 直观理解就是顺时针旋转 90 度后再水平镜像过去。转置用上标 表示。 例如：，则 矩阵的主对角线（左上 - 右下）元素转置前后不变，且具有可逆性 []、数乘不变 []、分配律 []。 转置后恰好就是它自身的矩阵称为对称矩阵。它是自转置的，即 。对称矩阵的元素恰好关于主对角线对称，且是一个 的方阵。 五. 矩阵乘法 该内容将在第二章涉及。 第三节 消元 按照一般思路（就是我们在小学学的方法），我们会选择通过方程互相加减各自的倍数，达到消去未知数的目的。这种方法在矩阵上同样适用，而且它有一个贼高坤的名称：高斯消元法（Gaussian Elimination）。 回忆一下我们从出生就会用的消元原理，我们的目标就是让每个未知数都对应一个常数项，那么它的值就可以直接用常数除以系数的方式求出。矩阵中也是如此，为了能够化简出可直接求解的矩阵，我们在此引入初等行变换的概念： 交换某两行 把矩阵的某一行同乘以一个非零的数 把某行的若干倍加和到另一行 这三条很容易理解。第一条：相当于交换方程组顺序，不影响计算；第二条：相当于对某一行方程放缩某倍，它等价于原方程；第三条：相当于前两条的融合，也是消元的关键一招。这三条规则在之后的初等矩阵内容中会再次出现。 首先从一个例子讲起，让读者感受一下初等行变换的魅力： 考虑这个方程组： 按照如上所述，将它转写成增广矩阵的形式： 我们总结一下常用的消元原理，应用到矩阵上就是： 枚举每一列 ，选出无序组中第 列系数绝对值最大的一行 ，并移到无序组的最上边。（变换规则一） 行通过自乘，将第 列的系数变成 ，并标记 为有序。（变换规则二） 通过加减有序组中某一行的非零倍，将之后所有行的第 列系数化为 。（变换规则三） 令矩阵 （有序组用绿色表示） 枚举第一列，。开始时，所有行均无序。选出绝对值最大的那一项，本例中为第二行，进行移动，原矩阵变为： 第二步，自乘并标记有序，因此第一行除以 ，原矩阵就变成了： 第三步，将无序组的第 列消成 。本例中，我们让第二行减去二倍第一行；第三行直接减去第一行，得到： 枚举第二列，此时 。第一步，选出第二列系数绝对值最大的那一行，移到无序组最上端。本例中无需移动，自乘 ，标记有序，原矩阵为： 最终的最终，第三行减 倍第二行，得到我们心心念念的化简后的矩阵： 为什么把矩阵化简成这种金字塔型的形式呢？你会发现：最后一行仅有一个带系数的未知数 ，我们直接求，。向上一行，现在 相当于常数，移到常数中与 合并， 也可直接求了……经过如上的反代操作，三个未知数都会被求出来。至此我们才发现这个三角形矩阵的魅力之处。 一般地，对于一个矩阵，如果它的非零系数呈阶梯形分布，则称这类矩阵为行阶梯形矩阵。将非零系数挑出来，它们组成的是一个上三角形矩阵；对应地，零项就会组成下三角矩阵。上三角矩阵通常以 表示、下三角矩阵通常用 表示。 原方程组有唯一解： 在这里，我没有给出代码实现。因为对于一些特殊情况，化简出的矩阵不能很好地被计算机处理，更适合算法竞赛体质的高斯消元模板将在本章第五节给出。 第四节 秩 类比一元二次方程的实数根存在性判别法 —— 判别式法，即对于一元二次方程 ，实数根的个数 。那么，矩阵方程是否也有类似的根存在性判别方法呢？ 答案是有的，而且不止一种，这意味着“矩阵是否有解” 这样的问题会有多种解决方案。现在介绍的是最为简单常用的一种——秩。 在线性代数中，一个矩阵 A 的列秩是 A 的线性独立的纵列的极大数目。类似地，行秩是 A 的线性无关的横行的极大数目。即如果把矩阵看成一个个行向量或者列向量，秩就是这些行向量或者列向量的秩，也就是极大无关组中所含向量的个数。 ……咱们抛掉这种看也看不懂的高级语文句法，听我给你总结： 通俗来讲，把一个矩阵化成最简形式（特指行阶梯形）后，非零行的个数就是矩阵的秩。这其实是秩的最大线性无关组的定义。再次白话总结：如果存在三个行向量（列向量一样的，保证所有向量都是行 / 列向量即可）：。根据高中数学中立体几何的知识 —— 和 显然是共线的，这两个向量就是线性相关的。如果对于一组 维向量，可以成为 维空间的一组基底向量，那么它们就是线性无关的。 矩阵 的秩用 表示，或者用 、、 等表示。 现在明白了吧，如果一个矩阵的某两行线性相关，它们都会被初等行变换第三条狠狠薄纱 —— 在乘或除以一个非零数后相减，其中一行就会被全部消成 0，从方程组角度来看就是 ，带什么值都成立（相当于去重了一个方程）。 当然上边这一段也有表述不准确之处，假设有一个增广矩阵 。初等行变换第三条秒了第一、第二行，然而事情有些不对劲了…… 第二行不乐意了，它还存留这最后一点倔强，好像在说：“你总结的不对呢真是雑鱼”。但是明眼人都看得出来， 这种事情是绝对不可能发生的，也就是无解。按照刚刚说的，这个增广矩阵的秩 ，可是它对应的系数矩阵 的秩 ，就有 且 ，于是我们就找到了矩阵无解的一个条件了。也就是 。 再考虑有无穷解的情况：无非就是出现了 的情况，此时 可以代任何值。与无解不同，这次的最简行阶梯形矩阵，无论是系数矩阵还是增广矩阵形式，它们的秩都是相同的，并且都浪费了至少一行方程式。我们知道：一个三元一次方程组是无法用相异的（行向量形式表示下不共线）两个方程解出唯一值的，相反，解形如： 表明 由 确定、而 又由 确定，然而这俩都不确定，导致这两个数可以取无穷多的值，也就导致矩阵有无穷组解。综上：矩阵有无穷组解的充要条件是 （ 为未知数个数）。 最后就是有唯一解：如果一切进行顺利的话，既没有全零行，也没有无解行。那么此时系数矩阵和增广矩阵的秩会相同，且等于未知数个数，即 。 总结，假设一个由 个未知数组成的最简行阶梯形矩阵 、以及它的增广矩阵 。矩阵解的个数由如下规则导出： 解的个数 例 1.4.1 Delivery Mathematics 快递员的数学题 「稻妻狛荷屋的人气跨国快递员绮良良在送货途中遇到了一个难题，你作为无所不知无所不晓的旅行者自然是乐意地接下了她的委托。当你来到委托地点时，你发现这是一道解谜题目……」 稻妻号称最难的方块解谜是一组由 个正方体可旋转方块组成的阵列，击打其中的某个方块会使得与之相关联的其他方块共同旋转一个特定角度。在这个谜题中，每个方块每次仅能水平顺时针旋转 90 度，传动方式在下图给出。问若要使所有方块同时朝向北方，需要如何击打方块？给出任意可行解，但需要保证每个方块旋转的次数不超过 4（不击打也可以，相当于次数为 0）。 由于钟离先生远在海那一头的璃月喝茶听评书、宵宫也正忙着制作夏日祭的烟花而无法抽身、香菱在万民堂做饭、安柏在侦察蒙德郊区、芙宁娜忙着吃蛋糕…… 总之没有其他人召唤物能帮你解决这个问题，你只能凭借自己的力量解开这个谜题。 图1.3.1 问题分析：首先我们要搞清楚传动规则，我们会发现当你击打了一个方块，包括它在内、再按顺时针方向数两个方块都在旋转相同的角度。这也是这道题被称作难题的原因之一，只用想象力是很难想象的出来的…… 于是为了用代数方法解决该问题，我们选择用四个未知数、四个方程表示每个方块操作后的状态，问题解决的标志既为四个方块的状态均为 （ 表示北方）。 算法设计：考虑到单个方块每旋转四次就相当于一次循环，因此我们重定义方向标，从北开始，顺时针方向将方位标记为 。这么做可以避免一些复杂的取模运算。接着我们根据传动规则表示每个方块的状态，令方块 1-4 被击打次数分别为 。以方块 1 为例：击打自己、3 号和 4 号都会导致 1 号顺时针旋转 90°，再算上 1 号初始朝向为 ，得到：。其他方块以此类推，解析出的方程组对其求解即可。这样的矩阵一定有唯一解，每个未知数都以 表示，将一个自然数代入 值即可解出答案。 解：设方块 1-4 的击打次数分别为 ，设朝向从北方按顺时针方向分别为 。 根据传动规则，有如下线性方程组： 增广矩阵形式为： （化简过程略），行阶梯形式为： 因为系数矩阵的秩与增广矩阵的秩相同且都等于未知数个数 ，因此矩阵有唯一解 。易知 的合法值满足 的数学关系，此处求最小值，令 ，得到 。 因此，最佳方案是暴击击打 2 号和 3 号方块各两次。 后日谈：有些读者可能会问，这个难道不是有无穷解吗？为什么上边说这个矩阵只有唯一解？其实这个矩阵确实只有唯一解，因为 ，造成它有无数组解的原因是 这个自然数。我们在开头只为这个矩阵设定了四个未知数 ，因此矩阵只有四个元，因而有唯一解。事实上，这个问题也可以转化成同余高斯消元，在普通高斯消元的基础上变除法为乘逆元即可。 对于有 （质数）个有效旋转面的方块，详见洛谷 P10315，顺便推一下 我的题解。 第五节 计算机高斯消元 一. 实数高斯消元 基本思路与手推时相同： 找到当前列元素绝对值最大的那一行，并移动到无序组的上端。 将这一行的第一个元素除成 。 此时需要进行一个神秘步骤：让除开当前行和第 列为零之外的所有行都用当前行消元一次。 如果有唯一解，我们会得到一个主对角线全为 的增广矩阵，此时每个未知数的结果就是右侧的常数。如果无解，还是像手推那样判断。如果存在无数组解，输出解的方法如下： 枚举每一行，找到当前行第一个非零元素，并记录它的结果为右侧常数。该行的其余元素作为自由元，不作操作（或赋值为任意值） 重复操作直到遍历到全零行。 我们会发现上三角矩阵中同一列可能有多个非零系数，这意味着上层方程组的结果依赖于下层的求解，如果出现自由元将会十分棘手。用上述方法将矩阵进一步化为对角矩阵后，就不会存在这种依赖关系了，因而判断和输出变得简单了许多。 核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940int gauss() { int rank = 0; // 秩 for (int c = 1, r = 1; c &lt;= n; c++) { int t = r; for (int i = r; i &lt;= n; i++) { if (abs(matrix[i][c]) &gt; abs(matrix[t][c])) t = i; // 找出主元绝对值最大的那一行 } if (abs(matrix[t][c]) &lt; EPS) continue; // 非零才能消成1 if (t != r) swap(matrix[t], matrix[r]); // 交换 for (int i = n + 1; i &gt;= c; i--) matrix[r][i] /= matrix[r][c]; // 主元消成1 for (int i = 1; i &lt;= n; i++) { // 反复消元，成为对角线矩阵 if (abs(matrix[i][c]) &gt; EPS &amp;&amp; i ^ r) { // 当前行不消，若当前位已经是零了也不消 for (int j = n + 1; j &gt;= c; j--) { matrix[i][j] -= matrix[i][c] * matrix[r][j]; // 消成零 } } } r++; rank++; } if (rank &lt; n) { // 无解or无数组解 for (int i = rank + 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) { if (abs(matrix[i][j]) &gt; EPS) return NO_SOLUTION; // 无解 } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (abs(matrix[i][j]) &gt; EPS) { ans[j] = matrix[i][n + 1]; // 无数组解，找到主元并直接赋值，剩余的自由元自动赋值为0 break; } } } return INFINITE_SOLUTIONS; } for (int i = 1; i &lt;= n; i++) ans[i] = matrix[i][n + 1]; // 有唯一解，此时常数项即为答案 return UNIQUE_SOLUTION;} 复杂度 。 二. 同余高斯消元 上一节的例题就是同余高斯消元的一个典例，我们需要求解模 意义下 元非齐次线性方程组的特解（即每个未知数的解均在 之内）。本质上和上面的高斯消元是一样的，不同的一点是我们需要把除法换成逆元，而且需要对减法取模格外小心；对于 不为质数的情况，还需要额外考虑是否存在逆元。代码与上面雷同，不放了。 复杂度 。 三. 异或高斯消元 适用于方程组和奇偶性相关联的时候，此时列出的方程组是异或和起来的。鉴于方程组的系数只有 ，我们的判断和消元也会简单许多，只需判断当前元素是否为 。实践时一般使用 bitset 来优化时间复杂度。 12345678910111213141516171819202122232425262728293031323334353637383940414243int gauss() { int rank = 0; // 矩阵的秩 for (int c = 1, r = 1; c &lt;= n; c++) { int t = r; for (int i = r; i &lt;= n; i++) { if (matrix[i].test(c)) { // 找到绝对值最大的行（只要第一个系数是 1 即可） t = i; break; } } if (!matrix[t].test(c)) continue; // 跳过零行 if (t ^ r) swap(matrix[r], matrix[t]); // 交换到第一行 for (int i = 1; i &lt;= n; i++) { // 与普通高斯消元的不同之处，对 1~n 行全部消元 if (matrix[i].test(c) &amp;&amp; i ^ r) { // 当前行不消，零行不消 matrix[i] ^= matrix[r]; // 异或代替减法进行消元 } } r++; rank++; } if (rank &lt; n) { // 秩小于 n，可能是无数组解、有可能无解 for (int i = rank + 1; i &lt;= n; i++) { if (matrix[i].test(n + 1)) return NO_SOLUTION; // 存在类似于 0=k 的矛盾情况，无解 } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) { if (matrix[i].test(j)) { // 无数组解，找到主元并赋值 ans[j] = matrix[i][n + 1]; break; } } } return INFINITE_SOLUTIONS; } for (int i = 1; i &lt;= n; i++) ans[i] = matrix[i][n + 1]; // 有唯一解，对角矩阵每个未知数的解就是常数项的值 return UNIQUE_SOLUTION;} 复杂度 。 洛谷习题： P3389 [模板] 高斯消元法 P2455 [SDOI2006] 线性方程组 P4035 [JSOI2008] 球形空间产生器 P10315 [SHUPC2024] 原神，启动！ P6126 [JSOI2012] 始祖鸟 P2447 [SDOI2010] 外星千足虫 第二章 矩阵乘法 第一节 什么是矩阵乘法 你经常能在各种线性代数的书上看到这样一串定义式：。这对于自学者（比如说我自己）其实是非常不友好的。他们在举例计算时很容易被 绕进去，不仅计算速度慢不说，还很容易出错…… 那我在此举出一个简记方法： 将左边的矩阵的每一行看作每个未知数都代了确定值的方程、右边的矩阵每一列看作是前者方程的未知数系数。二者相乘本质上就是让未知数和系数匹配上，并计算出结果放入结果矩阵的特定位置。这个特定位置也有讲究，假如选择了前一个矩阵的 行和后一个矩阵的 列进行运算，求和过后的答案应该放在答案矩阵的 位置。看以下例子来加深理解： 图2.1.1 那么什么样的矩阵才能进行乘法运算呢？答案是一个 和一个 的矩阵。观察规律，我们发现前矩阵的列数需要等于后矩阵的行数。根据如上概括的矩阵乘法的意义——即搭配未知数与系数。显然，当后一个矩阵的列数大于前一个矩阵的行数时，我们进行系数配对时就会发现多出几个失配的系数。矩阵乘法国不养闲人，这种单身汉显然是不可以光天化日下大摇大摆出来遛弯的。因此保证其中一个矩阵的行数等于另一个矩阵的列数后方可相乘。 类比四则运算的乘法，矩阵乘法是否也有结合律、分配律和交换律呢？很遗憾，不完全是，前二者是矩阵乘法运算所具备的性质、但最后那个交换律不是。不是所有的矩阵相乘都满足乘法交换律。但是还是有满足交换律的特例：同型零矩阵相乘、一个矩阵（可逆）和它的逆矩阵相乘，矩阵乘法满足交换律的充要条件证明过于复杂烧脑，此处不做陈述主要是我也不会证满足交换律的充要条件 qwq……。 证明：一般矩阵不满足乘法交换律 假设一般矩阵 ，一般矩阵 ，则 可以进行，因为 的行数和 的行数均为 。得到的乘积 是一个 矩阵；反过来， 无法进行，因为 的列数不等于 的行数，即 。 假设 。 和 均可进行，假设乘积为 。当 时，根据矩阵乘法的计算式，得到 ；当 时，根据计算公式得 。一般情况下，。得证。 矩阵和数字一样，也有幂次方的计算。特殊地，任意 非零矩阵的零次幂都是一个 的单位矩阵。主对角线的值全是 1，其余元素均为 0 的矩阵叫做单位矩阵，用字母 表示；零矩阵的任何非零正整数次幂都是一个零矩阵，零矩阵的元素全部是 0，用字母 表示。一个 的单位矩阵是这样的：。在算法设计中，经常用类似于大数快速幂（位运算版本）的方式快速计算矩阵的幂次方。 例 2.1.1 Akasha Browser with Irminsul Kernel 世界树搜索引擎 你作为刚刚清除了须弥世界树痼疾的英雄旅行者，突然对虚空终端的运作方式有了兴趣。你从大贤者那里了解逼问到，虚空终端实质上是一个仅显示搜索结果的前端程序，但关键词搜索功能却是基于须弥地下空间的世界树。带着这个疑问，你再次来到了世界树前，见到了小吉祥草王大人，希望能让她告诉你世界树的运作方式…… 背景知识： 很多浏览器的检索功能都依赖于矩阵运算，这里属于最简单的一种——我们只需要矩阵的乘法运算（某些情况下会用到转置，甚至正交性）。然而随着科技的快步发展，数据量的快速增加，这种方式如今只在很小的范围内被使用（由于码量小思维简单，它有时会在个人博客的关键词搜索功能中被用到）；目前广泛使用的一种是向量相似性搜索，它本质上是在一定范围内搜索与目标向量辐角最为接近的已有向量，在“矩阵的几何表示” 章节中会涉及到。这里介绍的是简单匹配搜索。 问题分析：因为矩阵乘法本质上是未知数和系数的配对求值，我们需要构造一个方法来使得“搜索内容” 和“已有内容” 配对。并且搜索引擎总会返回与你搜索的内容最为相似的结果，搜索“比尔・盖茨”，第一条肯定是关于他个人的介绍，而绝对不可能是一则寻狗启示……因此，我们设计的矩阵必须能在经历一轮运算后能够正确返回每个关键词出现的频率（简单点说就是出现次数），这样虚空终端才能对频率进行排序，并返回频率最大的那个结果。 算法设计：不妨考虑这样几个矩阵 —— 其中一个存储关键词、另一个存储搜索内容。比如我需要将几篇论文（为方便使用英文表示，并且假设词根相同的单词为同一个单词，即不考虑词汇变形）《Basic Structure of Elemental Monuments》（元素方碑的底层构造）、《Junior Elemental Reaction》（初等元素反应）、《Advanced Elemental Theory》（高等元素论）、《Architectural Structure in the Mausoleum of King Deshret》（赤王陵的建筑结构）以及《Advanced Sumeru Linguistic Analysis》（高等须弥语音学解析）。我们在此次挑选一些关键词存储（方便读者观察）：Structure、Element、Junior 和 Advanced。为每篇论文编号 1-5，矩阵如下图： 图例2.1.1 假如热爱学习的艾尔海森来到了教令院的大图书馆，它想测试一下这全新开发的文献查询系统，输入了 Advanced 一词。假设已录入数据库就是以上形式，我们如何构造一个“查询矩阵” 来和数据库矩阵进行运算呢？ 首先根据矩阵乘法的前提要求，这个查询矩阵必须是四行。不妨让每行代表我们的词库词语，艾尔海森输入的是 Advanced—— 即对应数据库矩阵的第四列（未知数），我们要配对它的系数，因此它必须在第四行，才能保证系数正确匹配未知数。同理，查询矩阵的第一行对应 Structure、第二行 Element、第三行 Junior。他输入了一个 Advanced，因此我们的查询矩阵如下图： 图例2.1.2 乘法的目的是将二者匹配起来，得到的结果如下图： 图例2.1.3 返回矩阵的数字代表关键词在对应数据库项中的出现次数，也就是说，如果此时再加入一篇论文《Advanced Usage of the Word Advanced》（“Advanced” 一词的进阶用法），返回矩阵的最后一行（第六行）会出现一个 。经过虚空终端的一轮排序，它自然就会来到第一位的位置。如果要分别查询两个不同关键词，在查询矩阵右侧再加一列即可，返回矩阵中多出的一列就是新关键词的出现次数；如果需要同时查询两个关键词，在同一列对应位置写入 即可…… 例 2.1.2 Light Novel Query 轻小说查询 八重堂的主编八重神子最近在为轻小说的事情发愁…… 并不是因为销量不够，正相反：八重堂最近推出了一项跨国销售项目，各种经典作品被远销往了枫丹廷。这就牵涉出一个问题 —— 枫丹的市民们不想远离枫丹城区、横穿须弥沙漠、翻越璃月高山、躲避稻妻雷暴就为了看一看有哪些轻小说符合自己的独特口味…… 于是八重神子找到了见多识广的你，希望你能帮她做出一套轻小说内容检索系统。当然作为报酬给你的原石和摩拉是肯定是不会少的…… 当然，这套系统有一定要求。因为有很多轻小说为了吸引读者，取的标题和内容是完全对不上号的，神子的想法是做一套正文内容检索 —— 每本轻小说的总字数在出版时就统计好了，但是苦于稻妻的信息存储技术不是很发达，神子希望存储在数据库矩阵里的数据尽可能小。请问该如何设计符合要求的存储算法？ 问题分析：每本书中特定的词可能重复出现成百上千次（同样用英文单词表示，且同词根不同词形的两个词算作同一个单词参与计数），我们的要求是让数据尽可能小，既然总字数都已经给出了，我们不妨使用指定词出现的频率来表示这个词的出现次数（单词出现次数 = 全书总词数 × 出现频率）。这样的搜索方法叫做相对频率搜索。 算法设计：大致原理和例 2.1.1 里的一模一样，只是数据库矩阵存储的不再是出现总次数，而是对应词的相对频率。因而图例 2.1.3 可以变化为如下形式： 图例2.2.1 明显一看，第三篇文章出现 Advanced 的频率最高，应该优先返回。但是这个例子并不是很好（明明说了按内容搜索你还在这搜索标题），但是当加入大量的正文内容时，这个方法的优势也就体现出来了。这里由于篇幅原因就不举过于复杂的例子，本例仅作对相对频率搜索的原理的理解。 第二节 初等矩阵与矩阵递推 假设存在一个 的单位矩阵 ，对 只进行一次初等行变换得到的矩阵叫做初等矩阵，通常用 表示。一个矩阵的行变换和列变换都可以用初等矩阵的乘法进行。 仅交换了两行的单位矩阵称作第 I 类初等矩阵（只进行了初等行变换第一条），将它左乘到一个矩阵前，可以进行相应的行运算；右乘到一个矩阵后可以进行相应的列运算。比如，一个第 I 类初等矩阵 （交换第一、二行），和一个 矩阵 。左乘就是 （交换一、二行）；右乘就是 （交换一、二列）。 仅将某一行乘以一个非零倍数的矩阵叫做第 II 类初等矩阵（只进行了初等行变换第二条），左乘行运算、右乘列运算。例如一个第 II 类初等矩阵 （第一行乘 3）和一个 矩阵 。（第一行乘 3）；（第一列乘 3）。 仅将某一行的非零倍加到另一行上的矩阵叫做第 III 类初等矩阵（只进行了初等行变换第三条），同样是左乘行运算、右乘列运算，但是有一点点小不同，不要根据思维定势随便写答案！例如一个第 III 类初等矩阵 （第二行乘 2 加到第一行）和祖传的矩阵 。（第二行的 2 倍加到第一行）；（第一列的 2 倍加到第二列）。注意初等矩阵的行列变换与乘法后矩阵的行列变换，哪一行/列乘了倍数、哪一行/列被加上了！ 因此我们可以不必使用高斯消元，仅使用初等矩阵乘法也可以达到将普通矩阵消元变成最简行阶梯形矩阵！而且它可以进行列运算，甚至比高斯消元法更高级一点。 接下来是我们的矩阵递推。大家都知道斐波那契数列，它的前两项均为 1，此后的每一项都是前两项之和，即 。大多数信息竞赛生在学习到递归算法时都会被要求写程序求解斐波那契数列的某一项，当然代码也非常的简单，如下： 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;long long fib(int n){ if (n == 1 || n == 2) return 1; return fib(n - 1) + fib(n - 2);}int main(){ int n; cin &gt;&gt; n; cout &lt;&lt; fib(n) &lt;&lt; endl; return 0;} 这段代码其实就是照搬了上面的通项公式，但是递归有个弊端就是效率和内存，当 为百万级别、甚至十亿级别时它就显得很小丑了。那么我们如何用矩阵加速计算呢？我们用斐波那契数列的递推来向读者介绍矩阵递推的操作方法： 首先我们将通项公式变成我们想要求的形式，为了便于输出，要求结果矩阵的第一个元素就是答案，因此结果矩阵就是：。又因为 ，并且 。我们还需要保证初始矩阵在经历一轮变换前后，始终都是同型的，这里是 的矩阵，操作后也应该是 的矩阵。于是我们的递推矩阵应该是一个 矩阵。不妨将递推矩阵 的每一行从上至下分别表示为 和 的系数，由以上二式可得：。别急，左边还有一列未填满 —— 我们希望每次操作都会把矩阵元素整体向左移一个位置，就好像一个滑动窗口（但不是单调队列），我们的第一列也可以求出来了。最终就是 那么求数列第 项 —— 每次右乘 都相当于多求出一项，并且当 只被乘了一次时，结果矩阵的第一个元素是 。因此要让第 项来到第一个位置，我们需要进行 次乘法， 也就是 的第一行第一列元素。可以写出如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define MOD 1000000007#define N 15using namespace std;typedef long long ll;int n = 2; // 递推矩阵行列数均为2struct Matrix { ll mat[N][N]; Matrix() { memset(mat, 0.0, sizeof mat); // 初始化时内部变量自动置零，无需每次定义变量时再置零 } void I() { for (int i = 1; i &lt;= n; i++) mat[i][i] = 1; // 构造2×2单位矩阵 }};Matrix operator*(const Matrix&amp; l, const Matrix&amp; r){ // 重载乘法运算符，实现矩阵乘法 Matrix res; for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { // res.mat[i][j] = (res.mat[i][j] + l.mat[i][k] * r.mat[k][j] % MOD) % MOD; // 取模用这个 res.mat[i][j] += l.mat[i][k] * r.mat[k][j]; } } } return res;}Matrix qpow(Matrix a, ll b){ Matrix res; res.I(); // 单位矩阵相当于实数运算中的 1，因此任何矩阵乘以一个单位矩阵的结果都是这个矩阵 while (b) { if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; } return res;}int main(){ int a; cin &gt;&gt; a; Matrix A; A.mat[1][1] = A.mat[1][2] = 1; // 初始矩阵 Matrix M; M.mat[1][2] = M.mat[2][2] = M.mat[2][1] = 1; // 递推矩阵 A = A * qpow(M, a - 1); cout &lt;&lt; A.mat[1][1] &lt;&lt; endl; return 0;} 它的时间复杂度可以做到 ， 是 的长/宽，这里是 ； 是幂。因此这里的时间复杂度是矩阵快速幂的 ，比朴素斐波那契递推的 强了不少！ 例 2.2.1 Lost Control! Blubberbeast's Reproduction 膨膨兽泛滥危机 由于枫丹水质的大幅改善，膨膨兽的天敌数量锐减，枫丹城区近海的膨膨兽也得到了更多的食物，进而开始大量地繁殖。水质改善的第一年，已登记的膨膨兽数量是 头，恰好是斐波那契数列的第 项。第二年，膨膨兽数量没有变化，之后的每一年，膨膨兽数量都是前两年之和的 ，已知膨膨兽的平均寿命是 15 年、枫丹廷近海能承载的最大膨膨兽数量是 万只。那么请问 年后近海的膨膨兽数量是多少？这 年内枫丹廷是否需要向近海投放膨膨兽的天敌以遏制后者疯狂繁殖？（结果出现出现小数则向上取整） 问题分析：这是一道标准的矩阵快速幂递推问题，它基于斐波那契数列递推、却比它更高级。首先，它的初始值不再是 而是 ，其次，从第三项起，每一项都是前两项和的一个倍数，这里是 。那我们怎么构造递推矩阵 来解决问题呢？ 算法设计： 已知初始矩阵 。根据题目描述很容易写出通项公式：。我们要保证初始矩阵经过一次递推后，得到的新矩阵与初始矩阵同型，因此根据矩阵乘法定义，我们的递推矩阵必须是一个 矩阵。于是拿出祖传单位矩阵模板 开始构造递推矩阵！ 对于前项和的问题，前面已经给出了，因而我们的递推矩阵变成了 ；接下来解决倍数问题 —— 根据通项公式， 和 的系数都是 ，我们构造递推矩阵时也要考虑到这一点，当 时，递推公式展开如下：。如果第一行代表 的系数、第二行代表 的系数 ，第二列显然应该同时乘以 0.85，左边一列的作用是使原矩阵整体向左移一个位置。最后我们的递推矩阵就是 。直接将初始矩阵右端乘以递推矩阵的幂次方就可以了。注意因为初始矩阵的右侧是第二年的膨膨兽个数，乘以递推矩阵本身，会让第二年的膨膨兽个数移到结果矩阵的前端，要想让第一项变成第 年的个数，递推矩阵的幂必须是 ，即 。 代码实现上，仅需将 矩阵和 矩阵的初始值改变就可以了。 最终结果：875076。结果小于 90 万，因此不需要投放天敌。 后日谈：那如果将系数改变为 呢？输出的结果将是 977427，接近 100 万了。可见其增长速度之恐怖。 洛谷例题： P3390 [模板] 矩阵快速幂 P1962 斐波那契数列 P1349 广义斐波那契数列 P1939 矩阵加速（数列） P3216 [HNOI2011] 数学作业 第三章 矩阵的逆 第一节 浅谈矩阵的逆 “逆” 这个词相信你早已听说过：同余意义下存在乘法逆元，大多数矩阵也存在逆矩阵。“逆” 普遍用来描述不同意义下的“倒数” 的概念，倒数一般满足 的性质，即本体 × 本体的逆 = 单位一。矩阵中的“单位一” 是单位矩阵 ，也因此我们的逆矩阵需要满足这个式子：，并且这个式子倒过来也必须成立（为数不多的满足矩阵乘法交换律的情况之一）。 如果对于一个矩阵 ，存在另一个矩阵 ，使得： 成立。则称矩阵 是可逆的，或称之为非奇异的，矩阵 是矩阵 的逆矩阵，通常表示成 。特殊地，单位矩阵 的逆矩阵是它本身，即 ；零矩阵 不可逆，或称之为奇异的，即不可能存在矩阵 ，使得 。 这一点类比实数运算： 的倒数永远是它本身、 没有倒数，因为分母为 ，没有意义；，同时 。 第二节 行列式 行列式是一种函数，写出来有点像矩阵的绝对值。它可以用来判断一个矩阵是否有解、也可以定量分析线性变换对原向量的影响。矩阵 的行列式通常用 或者是 表示。这一节主要介绍行列式判断矩阵是否可逆。同时，行列式也可以用来判断方程组是否有解。 定义 矩阵 的行列式为 。特殊地， 矩阵的行列式就是 的值。当一个矩阵的行列式为 时，它是奇异的、也就是不可逆的；反之则非奇异/可逆。 那我们在上边只提到了两种尺寸的方阵，那对于 、、以至于 的方阵又该怎么办呢？答案是分而治之——分治！ 第三节 代数余子式展开/ 展开 我们拿出祖传的 矩阵 ，我们随机在其中挑选一位受害者。我个人看第二行第一列的 元素不太顺眼，作为矩阵 的定义者，我有权利将它变成自己所喜欢的样子，因此我把元素 拿掉。可是拿掉以后它还是个 ！于是我将它所在的那一行以及那一列全部剔除，把剩下的元素按照原来的相对顺序靠拢，组成一个新的 矩阵 。现在整个矩阵没有 元素了，看上去清爽多了。 像上边这样，将 阶行列式中元素 （）所在的第 行、第 列所有元素删去，剩下元素组成的新 阶行列式叫做原行列式的余子式，用 表示。 代表它是删去原矩阵第 行和第 列得到的余子式。它通常将一个高阶行列式拆分为一个个低阶行列式便于计算，这其中就是用到了分治（子问题递归）的思想。 我们要计算整个 矩阵的行列式，就需要拆开余子式。最终分治成多个 的矩阵求其行列式并加和起来。有一个定理： 当 时，一个 的方阵的行列式可以表示成任意行/列的余子式展开，即： 这样的计算方式称作代数余子式展开，或 展开。 日常做题时，通常选取 最多的那一行/列进行展开以减少计算量。 第四节 矩阵的逆 第一节解释清楚了逆矩阵的概念，那么如何求逆矩阵呢？首先是前提——判断矩阵是否可逆！我们引入矩阵行等价的概念： 如果一个矩阵 能经过有限次初等行变换得到另一个矩阵 ，则称 与 是行等价的。 比如说你交换一个矩阵的两行（初等行变换第一条）得到的矩阵本质上还是原来的矩阵，因为如果当你把变换前后的矩阵拆分成一个个行向量，它们在坐标系上的关系不变（交换两行向量不变，同乘非零向量共线）。联系到第二节的初等矩阵知识，初等行变换可以转化为矩阵左乘初等矩阵，定义可以转换为如下的数学语言： 如果存在矩阵 和矩阵 ，使得 成立，则称 与 是行等价的；相应的，初等矩阵右乘就对应两个矩阵列等价。 矩阵行等价有反身性、传递性。例如： 与 行等价， 与 行等价，则以下两条均成立： 与 行等价 与 行等价 相应的，若有方程组，使得 。在等号两端同时乘一个符合乘法运算条件的矩阵 ，新的方程 与先前的方程的解相同。第二个方程与第一个方程就是一组等价方程组。 当且仅当 与 是等价方程组时，增广矩阵 与 行等价。 这个推论的证明需要用到一个定理： 若 为一个初等矩阵，则它是非奇异的，且 和 是同类型矩阵。 证明：根据初等矩阵的定义，它是由单位矩阵 经过单次初等行变换而来。根据行变换类型的不同，分为三种情况讨论： 第一种， 为第 I 类初等矩阵。假设它由单位矩阵交换第 和第 行而来，左乘同样的 矩阵，进行相应行运算 —— 右边的 矩阵将交换 行，因为 原本就是 交换 行得来的。因此左乘后原式 ，根据逆矩阵的定义： 的逆矩阵就是它本身，即 ，因此二者同类型，都是第 I 类初等矩阵。 第二种， 为第 II 类初等矩阵。假设 是 的第 行乘一个非零数 而来，构造新的初等矩阵 ，若想使得 ，用于进行行运算的左矩阵必须要让第 行乘上 回到 。因此 的第 行同乘以非零数 ，得到 。因此二者都是第 II 类初等矩阵。 第三种， 为第 III 类初等矩阵，且是 的第 行加上第 行的 倍得到的。因此构造初等矩阵 ，作为左矩阵，它的效果是让右矩阵的第 行减去 倍第 行，因此 ，且是 将第 行乘 加到第 行得到的。二者同为第 III 类初等矩阵。定理得证。 两个非奇异矩阵等价的条件是：假设 为一个 的方阵，所以下面三条命题等价： 是非奇异的 只有平凡解 与 行等价 在矩阵运算中， 的零解 就是这个方程的一个平凡解。（因为实在是太显而易见了所以很平凡） 证明：首先证第一条可以导出第二条。假设 为非奇异方阵， 是方程的一个解。因此 。因为 是 的一个解，因此 ，原式 。因而原方程仅有平凡解。 再证第二条可以导出第三条。 可以化简成行阶梯形矩阵 ，方程变为 。因为严格三角形矩阵可以通过变换得到单位矩阵 ，所以需要证明 是否是严格三角形矩阵。如果 的主对角线出现了 ，那肯定不是严格三角形矩阵。因为阶梯形矩阵要保证每一行都比它的上一行前边的 元素多，因为 是方阵，到最后一行时只能全部为 。此时矩阵有无数组解，因为实际上他只列出了 个方程，最后一行的方程不被计入系数矩阵和增广矩阵的秩，导致 。因此有无数组解；反之若 的主对角线全不为 ，它可以被化简成单位矩阵 （使用高斯消元即可）。因此 与 行等价、 与 行等价，传递得 与 行等价。 最后证第三条可以导出第一条。根据行等价的定义，必有 。根据方才证明的结论：初等矩阵是非奇异的，根据单位矩阵的性质：单位矩阵也是非奇异的。因而 也是非奇异的，且 。得证。 根据第三条，我们就可以知道一个求逆矩阵的方法了：既然 ，我们给等号两端同时乘一个 ，得到 。因此 又与 行等价。前两个方程是一对等价方程，我们换元，假设 ，两个方程如下：。因此增广矩阵 可以被化简为 。我们只需高斯消元将分隔线左侧化成 ，右侧自然就是逆矩阵 了。 例 3.4.1 How Aranaras Measure Timeflow 兰那罗的时间观念 你在须弥冒险时，遇到了森林可爱的孩子们 —— 兰那罗。这些小小的生物有着与世无争的纯净心灵、以及大大的胸怀。你们一同冒险，击败了桓那兰那故土的污秽化身，拯救了须弥森林。然而，在和兰那罗对话期间，除开他们奇妙的比喻之外，还有一件事情是你久久无法忘怀的 —— 他们的时间单位。你听过最多的是“种子长成大树”、“太阳升起又落下”、“落落梅从出生到长大”、“大树长成雨林”…… 假如你们经过很长一段时间的交谈，你渐渐明确了各种时间描述词之间的数学关系，关系如下文所述。请你求出每个描述词所对应的时间间隔。 已知大树长成雨林的时间是种子长成大树的 倍。 树木从种子长成大树的期间，落落莓已经生长过整整 次了（由种子出生到果实成熟和从成熟到下一颗种子扎根生长的时间相同）。 兰那罗从种子长成大树期间，普通人已从黑发少年变为白发苍苍的老人了。 普通人从青年到老年的时间足够让三颗种子先后成长为大树。 一片树木生长成为雨林，不仅足够让 个人先后从少年变为老年，而且还需要额外的 年时间完全长成一片健康的雨林。 请问“大树长成雨林”、“树木从种子长成大树”、“兰那罗从种子变成大树”、“落落莓从扎根到成熟” 以及“普通人从少年到老年” 所经过的时间各是多少年？（四舍五入到最近整数，单位：年） 问题分析：既然各个描述词对应时长的倍数关系都已给出，我们可以两两列出方程组求解。这里我们用到矩阵的逆来方便求出方程的解。 算法设计：首先将各个描述词用未知数表示出来，再用数学关系表示出题干中各个描述词的关系，如此得到的 5 个方程恰好能使矩阵有唯一解。因为一般的方程 可以写成 的形式，所以求出 的逆矩阵，再对常数项组成的列向量进行左乘即可。 解：设“大树长成雨林”、“树木从种子长成大树”、“兰那罗从种子变成大树”、“落落莓从扎根到成熟” 以及“普通人从少年到老年” 的时间分别为 年。根据题干描述。可以得到如下关系： 整理得： 对应系数矩阵 。常数矩阵 ，未知数矩阵 。对应方程为 。 两侧同时乘以 得：。根据逆矩阵求法，初始矩阵为： 高斯消元后，将 消成 形式，得： 的逆矩阵就是： 根据方程 ，得到 ，此时： 解得： 因此，“大树长成雨林” 的时间是 年、“树木从种子长成大树” 需要 年、“兰那罗从种子变成大树” 需要 年、“落落莓从扎根到成熟” 需要 年、“普通人从少年到老年” 需要 年。 最后，森林会记住一切。 第五节 行列式的性质 感谢初等矩阵的加持，我们需要记背的知识点又多了不少呢…… 我们在第三节说了，用余子式计算矩阵行列式时，需要按照同一列或者是同一行展开。为什么不能沿对角线或者是其他花里胡哨的顺序算余子式呢？下面有个引理告诉你原因： 设 为 的方阵， 表示 的代数余子式，则： 不难发现， 的情况就是沿同一列的余子式展开。假如 ，原式就是沿第一行、从第一列到第 列元素的余子式之和。而这恰好是一个矩阵的余子式展开（人家行列式就是这么算出来的，肯定是对的），因而结果等于 。当 时，就是上边说的花里胡哨的展开。为了证明它，我们假设一个新的矩阵 。它的第 行被替换成原 矩阵的第 行，这样的话这个余子式展开就是 的正确的余子式展开，也就是说它的结果等于 。然而 有两行是相同的，也就是说它不可逆（最简阶梯形的最后一行全为 0），因而 ，结果也就是 。 假如 ，那如果有一个初等矩阵左乘它进行行变换，乘积的行列式是否也等于 呢？接下来就来探究这个问题： 假如 为一个 的第 I 类初等矩阵，且是单位矩阵交换第一、二行得来的。假设 为一个 的方阵。那么 ，那么 ，而 ，所以 。 推广到 矩阵，假设 方阵 是 交换一、三行得来的。那么按照第二行展开余子式就是：。 根据 矩阵行列式的性质有 。 因此对于 的方阵，交换其中两行对行列式的影响是改变其符号。其余两类矩阵自行证明，总规律如下： ，且 是第类初等矩阵且是第类初等矩阵是第类初等矩阵 也就是说，交换矩阵两行，其行列式变号；对某一行乘以一个数 ，行列式的值也乘 ；将某一行减去另一行的非零倍，行列式不变。至此我们便将行列式把初等行变换联系起来了。在算法中，我们不必去计算余子式，而是通过简单的高斯消元来计算行列式。事实上，利用代数余子式，其时间复杂度大约是 的；而利用高斯消元求解行列式，时间复杂度就是高斯消元的 。我们又有如下定理： 对于一个 的上三角形矩阵，其行列式 。 对角线矩阵也是同理，计算它们的行列式只需要将主对角线上的元素累乘起来。当矩阵对应的方程组无解或者是有无数组解时，其行列式就一定是 。 第六节 行列式在高中数学中的应用 这一节的内容是 2024 年 11 月份新加入的。是适合高中生体质的快速解题技巧。 一. 向量叉乘/平行四边形面积 例题详见：2024 年新高考一卷 T16。 高中立体几何学了向量数量积/点乘，定义如下： 其中 是两向量间的夹角。结果为标量（实数）。 类比点乘，我们定义叉乘为： 模长为 ，方向与参与运算的所有向量垂直的向量。 意义同上。结果为矢量（新向量）。 观察到这个模长很像正弦定理中三角形面积公式 。事实上，这个结果代表两向量围成的平行四边形面积，因此 。那我们怎么去计算这个结果呢？有人会说：“那不是还要算 ，更麻烦了吗？” 联想到本节标题，其实二维向量叉乘是可以用 方阵的行列式来算的。把三角形的两边用向量表示出来组成一个方阵 ，于是 。 不到万不得已，考试时千万别用这一招，如果一定要用，请一定记住写出下面的证明过程才能保证不扣分或者扣分少一点。 证明： 从 的计算方法 开始，三角形中 （注意区间表示实数，不能写作 ），得出 。 那么： 此时将坐标 代入得： 得证。 做题时又会发现，围成三角形的是两个三维空间向量，难道要用 矩阵求行列式吗？ 答案是否定的，事实上我们可以想办法把它补充成一个完整的 方阵。具体来说就是在第一行加入这个三维空间的基底向量，然后稍作变化。例如求解 和 围成的三角形面积： 我们可以加入基底向量 ，或者一般地，，然后组合成矩阵： 展开得： 那是否意味着答案就是 呢？不是这样的，正确答案约为 ，是什么造成了结果偏差呢？ 首先方法本身是正确的，只是最后不能直接求和加绝对值！这也是把基底向量设为 的好处所在。实际上我们的展开式应该是这样子的： 相当于叉积的结果是一个新向量 ，求模长得 ，于是 ，答案正确。 二. 平行六面体体积 例题详见：《步步高一轮复习 83 练 2024 人教 A 版》 P355 T6 类比平行四边形，空间平行六面体也是可以用这个方法的。证明过于繁杂，不放了。事实上你可以用这个巧办法进行伪算，然后反解出一系列数值写到卷子上……对于由同样的三个三维向量围成的三棱锥，它的体积就应该是同向量构成的平行六面体的 。见下图： 三个等体积的三棱锥恰好填充了平行六面体的一半体积，即三棱锥体积是平行六面体的六分之一。手算时就可以用到先前介绍的代数余子式法选择零最多的行/列进行运算。 化学竞赛有时也会用行列式来求解平行六面体晶胞体积。事实上，任何由 个 维线性无关向量围成的几何体的体积都可以用行列式计算其体积。 例 3.6.1 Obsidian Opalstar 黑曜石奶奶 正如其他的占卜师那样，大名鼎鼎的「黑曜石奶奶」茜特菈莉在占卜前会也摆出各种各样的黑曜石晶体。然而她不同于普通占卜师的一点是——她的黑曜石可能来自于其他维度！其维度的高低、黑曜石在所处维度空间中的体积大小都取决于要占卜的事件。现在，你想让她帮你占卜一下“我什么时候能掌握线性代数”这一问题。茜特菈莉当然不会让你这么简单就得到她的回答，除非你能马上计算出她所用黑曜石的体积…… 已知茜特菈莉所用的黑曜石是一块由 个四维向量围成的几何体，这四个向量分别是 （单位：cm），你能从她嘴里得到问题的结果吗？ 问题分析：对于人工计算，可以选用代数余子式展开；对于计算机，可以使用高斯消元求解行列式。 解：问题即求解矩阵 的行列式的绝对值 。根据代数余子式展开得 ，则答案为 。 洛谷例题： P7112 [模板] 行列式求值 P4783 [模板] 矩阵求逆 第四章 向量空间 第一节 欧几里得向量空间 简称欧氏空间， 表示一个 维欧氏空间。我们在高中立体几何部分接触了向量在空间内的表示方法，一般来说它们都使用行向量 表示一个由原点指向 的向量。线性代数中为了区分，大多数时候使用列向量 来表示与上边相同的行向量。 如果仅把 描述成由原点指向 的有向线段，显然是不太合理的。根据向量知识，一段由 指向 的有向线段也可以用 来表示。因此对于一个列向量，它可以在对应维度空间内画出无数个起点和终点各不相同的向量图像来。如果根据这个原理，列向量表示法就失去了唯一性…… 事实不然，我们发现，无论这个向量的起点如何变化，它们的方向（辐角）、长度（模长）相同，它们可以经过平移变换成同一个向量。只要确定以上这两项的值，一个 维向量也就随之确定了。 （向量 可以通过平移变为向量 ，这两个向量是相等的，都可以用 表示） 根据勾股定理可以计算出向量的长度，这叫做向量的模长， 的模长一般写作 ，数值上等于 。若是 上的一个普通向量 ，就有 。这些是我们高中时期就学习过的内容。 高中数学教材在虚数那一章还有一个选学知识（2023 版）——辐角。尽管它标成“选学”，其实我们早在三角函数的几何表示里就接触过辐角了：一个起点是原点的向量可以看作是它从 轴正半轴逆时针旋转 得来的，这里的 就是向量的辐角。它很有用——是 中单位根操作的灵魂， 被广泛用于电子设备的自然信号处理，你桌面美化包里的频谱图的底层实现就是 算法。 向量的数乘运算：辐角不变，模长相乘。 图示： （） 向量的加法，参见高中物理合力与分力的知识。矢量（既有方向又有大小的量）的加法遵循平行四边形法则 图示： 即以要进行加法的两个共起点向量为平行四边形的相邻边，做出完整的平行四边形，它们的和向量的起点与前两个向量起点相同，终点是平行四边形的对角顶点。上图中 。 和平行四边形法则等价的还有三角形法则： 即将其中一个向量的起点平移到另一个向量的终点处，和向量的起点是后者的起点，终点是前者的终点。上图中 ，注意向量的字母表示有先后顺序，因此 不可颠倒变成 ，事实上 。 在向量表示中：。因此向量相加，坐标相加。 减法则是坐标相减，将减数向量做反向同模长的反向量再进行加法运算即可。 由于矩阵可以拆分成一个个列向量和行向量，而且矩阵的加法与数乘均与刚刚介绍的向量的加法与数乘规则相同。因此矩阵具备表示向量组的条件，称之为向量空间。向量空间中定义的加法和数乘需要满足如下几条（假设 为向量， 为标量 / 常数）： 好多啊 ccc，其实就是需要把“加法” 定义成正统的加法（满足交换律、结合律）；“数乘” 定义为正规的数乘（满足结合律、分配律，没有交换律）。可以发现矩阵的加法和数乘和它完美匹配！因此矩阵可以作为一个向量空间。 于是，向量空间 中的元素称作向量。因为这个空间需要包罗万象，就像宇宙空间要包含我们赖以生存的地球一样……它包括我们所需要的向量，因此向量运算最基本的两种——加法与数乘运算所导出的结果必须也在向量空间 内，这叫做向量空间内加法和数乘的封闭性，向量空间必定符合这个性质。如此一来，向量空间 就足以作为向量所生存的“宇宙空间” 了。 当然有时我们并不需要那么多空间，好比一个人住一个城市……先不提城市各项环节能否正常运作，如果只是用来溜达的，那也是太过巨大了，有些地方可能你一辈子也取不到，还不如开始就不要。向量空间其实也可以像这样压缩范围，并且压缩后的向量空间也必须是全集 的子集。根据向量空间的定义，该空间内的向量做任意加法和数乘运算得到的结果都得是空间内的向量。 若向量空间 的子集 满足加法和数乘运算的封闭性，那么 是 的一个子空间。特殊地， 与 都是 的子空间， 称作零子空间，其他非零且不等于 的子空间称作真子空间（类比集合的空集、子集和真子集概念）。 在矩阵中，也存在零空间。它表现为矩阵方程 在 上的解集 。我们首先验证数乘封闭性，；紧接着是加法封闭性：。封闭性得证，因此 是 的子空间。这种空间被称作矩阵的零空间，通常用 表示 的零空间。 例 4.1.1 Merusea Village Portal 海露村传送门 自从你来到枫丹，知晓了水仙十字结社的秘密之后，奇怪的事情开始在你身边上演…… 你在海露村遇见了抽象派美露莘大画师玛梅赫、以及一只发条机关狗西摩尔。很不巧，玛梅赫的作画颜料用完了，于是你们前去收集更加纯净的矿物颜料，期间玛梅赫邀请你们进入一个粉色的漩涡虫洞。或许是因为你前一天冒险到深夜，在这个温暖且舒适的环境下来了困意。一闭眼，再一睁眼，迎接你的不是如同往常一般的新地下区域 —— 而是一片温暖的、舒适的粉色幻境 —— 你被一个人丢在这个传送通道里了！ 为了不让派蒙着急，同时也为了你能尽快在下一次困意席卷前逃出这个空间，你需要确定这个传送门是否为“同维度空间卷曲型”—— 即传送过程中不发生维度的变化。你需要证明你身处的空间是一个三维空间的子空间，这样才能使用正确的方法逃出生天。你发现你的身高和体宽的比值是原来的一半、但是体宽不变。请证明你所在的空间是是三维空间的子空间。 问题分析：首先要根据已有的信息判断该向量空间是否为三维向量空间的子集，然后再验证加法与数乘的封闭性，只有当二者均成立时才能够证明该空间是三维空间的子空间。 算法设计：根据题干最后一句话，我们不妨将主人公设为三维坐标系原点，按照 三个坐标轴来建立变换关系。比如说“身高体宽比减半” 代表的是现在的 轴是 轴的一半，假设原身高在 轴上有 个单位，而现在只有两个单位，证明现在的 轴被拉伸了一倍。最后关于封闭性的证明，设出几个具有普遍性的向量证明即可。 解：根据变换关系，得到该向量空间的集合形式 。因此 为 的子集，令 ， 数乘：；令 ，，，封闭性得证。 因此，所在空间 是三维空间的一个子空间。 第二节 基底、张成与张集 假设 中有向量 ，那么 称作向量 的线性组合。向量 的所有线性组合构成的集合叫向量 的张成。 我们都知道， 个不共线向量唯一确定一个 维平面。假如有向量： 和 。它们的张成就是（注：最好是验证两个向量在三维空间里的张成，既直观还符合常规认知）它们围成的 维平面。方才的 和 的张成如下图： 如果 ，则称 张成 。用 表示。有以下两条性质： 若 ，则 为 的子空间 向量平面 中一组向量的张成是 中包含这组向量的最小子空间 对于第一条，因为你怎么拟合平面，都不可能让你的平面比整个空间的维度更高，而且无论以什么系数搭配向量，它们所得的新向量都在整体空间内，第一条就能很简明的证明了。第二条性质，首先空间内向量的张成必为整个空间的子空间，毕竟用的都是数乘和加法，用的向量也都在空间内，总不能算一下加法向量就跑到空间外边去了吧，此外，因为数乘和加法的封闭性，任何经过这两个向量的空间都包含其张成，因此它是最小的。 l和张成相对，如果 张成 ，则 是 的张集。 基底，大家在高中立体几何部分学过了。当时的定义是：平面内不共线的两个向量叫做这个平面的一组基底。然而这段话可以用线性代数的语言原原本本描述出来： 在 维向量空间 中有 个线性无关的向量 ，则称它们是向量空间的一组基。 线性无关的概念，之前已经简单讲过，总的来说就是向量不共线，即不存在标量 ，使得 ；线性相关则反之，指的是两个向量共线，即 成立。正如在高中课堂上学的一样，给出一个 维空间的一组基底，该空间上所有的向量都可以用这组基底唯一地表示出来。比如下边这个例子： 例 4.2.1 Al-Ahmar's Test 赤王的试炼 你和婕德一行人在圣显厅前击败了图谋不轨的镀金旅团，并在他们搭起的营帐里发现了一封密信。上面写着若想进入圣显厅，需先过三关试炼。为了能够一探黄金梦乡的秘密，你接下了完成三重试炼的任务，然而当你真正进入到第一重试炼时，却发现事情并没有这么简单…… 你进入了试炼场地，却发现整个世界天旋地转。最终安定下来，你发现赤王的神奇科技把你带入了一个 维空间内。这还没完，四周又有整齐排列的空气墙阻挡了你的通路。经过好一顿摸索，你终于发现这是一个 维空间，于是你开始建立空间坐标系，五个坐标轴分别是 ，假设你现在所在的地方是原点 ，通关点 。四周的空气墙限制了你仅能沿着与向量 平行的方向行动。请问如何安排前进方向使得你能够从起点 到达终点 ？ 问题分析：这个问题明显是让我们用 来表示出从起点（原点）到终点的一个向量，因为这五个向量不共线，可以作为五维向量空间的一组基底。又因为基底可以唯一地表示出平面上的所有向量，考虑列方程组求解每个基向量的系数关系。 解：明显地，题中五个向量互相线性无关，因此可以作为该平面的一组基。由于向量加法和数乘运算的封闭性，且路径向量 在该平面上，因此可以拆分成这些基向量的倍数和形式。 设 ，则有方程组 ，方程组的解： 因此，应在 方向上移动 ，在 方向上移动 ，在 的反方向上移动 ，在 方向上移动 ，在 的反方向上移动 就可以到达终点。 因此一旦选定了平面的基底，该平面上所有的向量都可以用这组基底唯一表示出来，具体操作是使待求向量 ，接着解方程求出系数 的值即可。在高中，我们称之为“待定系数法”。 基底可以表示平面内所有的向量，故 维平面 的基张成 。 第三节 线性变换在高中数学中的应用 本节是 2024 年 12 月 29 日新加入的内容。是适合高中生体质的快速解题技巧。 一、基底法 在开始之前，我认为有必要再为读者回顾一下高二上册空间向量的相关内容。 有时，我们拿到的题目里不存在很明显的直角关系。设想这么一个平行六面体——它的底面是一个夹角为 的菱形，侧棱与底面棱的夹角均为 。如下图： 上图中，，所有棱的长度均为 。题目可能让我们求出各种线段的长度，或者是某对异面直线的夹角（余弦值）。此时最常规的方法是基底向量法，即选择三个不共线的向量作为空间的基底，并将待求直线用这三个基底向量表示出来，接着利用角度关系即可求解。 一般来说将平行六面体的三条棱设置为基底会方便一些，因而空间中有基底向量 。例如我们现在要求解线段 的长度，先用所设基底表示它：。向量模长即为 。 又或者，我们想要求出异面直线 和 夹角的余弦值。根据公式可得 ，即两直线垂直。 像这样，根据角度关系巧妙设置基底、将一些向量用基底的线性组合表示，并进行计算的方法就叫做基底法。在存在特殊角度关系而难以建立空间直角坐标系的时候非常好用。 二、线性变换 我们先从平面直角坐标系入手，找到一般规律。假设我们有一组平面上的正交（垂直）单位基底 。并且有两个向量 ，可以很轻松地得知 。那么两个向量的数乘就是 。由于 ，那么结果就是 ，即坐标对位相乘。 事实上，对于 和 的夹角不为直角，而是特殊角的情况，根据上面的公式，我们可以得到平面斜角坐标系的数乘公式：。 第四节 线性基 本节主要是算法竞赛内容。 第二节里我们讲了向量空间的基底，基底其实还有一个名称叫线性基。平面中所有向量唯一对应一种基底的线性组合。在 OI 中常常被用于求第 大异或和的问题。为了和实数四则运算的线性基区分，这种线性基下称异或线性基。此节针对于 OI 算法，因此本节所述的“线性基”均默认为“异或线性基”。 一组值的异或和可以看做该空间内异或线性基的向量的异或组合，由于基底表示向量的唯一性：原集合中的数可以通过异或线性基里的基向量唯一确定。它有如下几个性质，事实上，它和普通平面内的实数线性基有相似之处： 原序列中任何元素都可以通过异或线性基内的元素异或得到 异或线性基不存在重复元素，且在保证性质一的前提下，它的元素最少 异或运算也有一个特殊性质，若 ，则 根据以上性质构造计算方法： 123456789101112void insert(ll x){ for (int i = 63; i &gt;= 0; i--) { if ((x &gt;&gt; i) &amp; 1) { // 要存放的数的当前位为1 if (!p[i]) { p[i] = x; // 异或线性基该位为0，二进制下该位置为1 break; // 已找到位置存放，退出循环 } x ^= p[i]; // 异或线性基该位为1，为化为下三角形矩阵形式方便计算置为0 } }} 由于一般题目中数据范围是 1e18，而转换为二进制位就有 位，因此数据类型最好选用无符号长长整型 unsigned long long，线性基 p 数组至少需要 60 位。 有时并不是所有的插入操作都会成功，因为要保证异或线性基里的向量互相线性无关。存储操作本质上是拆分二进制位，然后将它尽量表示为已有基向量的异或和，好像除去每个人身上的共同特征，只保留人的独特个性一般。如果拆到最后再也拆不了了，证明它是独特的，可以加入其中。反之，这个数就可以被其他数通过异或运算代替，没必要加它，返回插入失败。可以有下面的代码： 12345678910111213bool insert(ll x){ for (int i = 63; i &gt;= 0; i--) { if ((x &gt;&gt; i) &amp; 1) { if (!p[i]) { p[i] = x; // 异或线性基该位为0，二进制下该位置为1 break; // 已找到位置存放，退出循环 } x ^= p[i]; // 异或线性基该位为1，为化为下三角形矩阵形式方便计算置为0 } } return x; // 若被异或分解为0，则证明它可以被现有元素计算得到，为保证异或线性基元素互相线性无关，不予插入} 如果是求一个数能否被这个异或线性基表示出来，将最后一行改为 return !x; 即可（能表示即不可插入，不能表示即可以插入）。若某次插入失败，证明 可以被表示出来，在求最小值是要额外关注！我们在此维护一个布尔值 flag = false，在插入失败后设为 true 表示需要特判 。 线性基用于求解一组数的异或和最值问题，有下面求最值的三个例子。它们无一例外使用了贪心法： 一. 求最大值 12345678ll xorMax(){ ll ans = 0; for (int i = 63; i &gt;= 0; i--) { ans = max(ans, ans ^ p[i]); } return ans;} 为什么从高位开始遍历？我们都知道如果一个数字的某位数大于另一个数字相同位置的数（两数数量级相同，即十进制下位数相同），那么前者是大于后者的。根据异或的运算法则：“不同为 ，相同为 ”。如果 ans 的高位此时是 0，若进行异或运算的同位数字是 0，即二者相同，结果为 0，不会变得更小；反之若异或运算的对应二进制位为 1，当前位异或结果是 1，变大了，因此 ；如果 ans 高位为 1，运算数对应位为 0，结果为 1，不会变得更大；若运算数当前位是 1 异或结果为 0，变小了，所以 。 二. 求最小值 12345678910ll xorMin(){ ll ans = 0; if (flag) return 0; // 特判0 for (int i = 0; i &lt;= 63; i++) { if (p[i]) return p[i]; }} 我们知道，可以通过任意组合（异或运算）异或线性基中的元素来得出各种新的元素，若 无法被表示出来，我们找到异或线性基里最小的元素即可，因为异或线性基里的每个元素也是原序列中某些元素的异或和；反之返回 。 三. 求第 小值 这才是异或线性基的高级玩法 为了求第 小值，首先要对异或线性基进行一轮清扫。将它高斯消元化简为最简形式，称作重构 rebuild。 123456789void rebuild(){ for (int i = 63; i &gt;= 0; i--) { // 从高位开始按位扫 for (int j = i - 1; j &gt;= 0; j--) { // 遍历右移 if ((p[i] &gt;&gt; j) &amp; 1) p[i] ^= p[j]; // 保证p[i]是异或线性基里第i位最小的那个，通过不断异或可以变小 } }} 接着我们需要特判 ，如果每一次插入都可以成功进行，向量之间互相线性无关，也就无法表示 。在求 小值时，若 ，也就是说求最小值，明显应该返回 ，如果按照常规思路返回 就是错误的，因为这个做法的前提是 。所以如果先前的插入操作出现失败的情况，就要对 进行特判，原先的 实为 ： 123456789101112131415161718ll queryKMax(ll k){ if (k == 1 &amp;&amp; flag) return 0; // 特判 if (flag) k--; // 特判0，f(k)实为f(k-1) rebuild(); // 重构异或线性基 ll ans = 0; for (int i = 63; i &gt;= 0; i--) { if (p[i]) { // 对k进行二进制分解 if (k &amp; 1) ans ^= p[i]; // 位为1，异或 k &gt;&gt;= 1; } } return ans;} 除了求值，异或线性基还可以合并，甚至于求它和另一个异或线性基的交集与并集。所以异或线性基是一种数据结构。我把它封装在一个结构体 XorBase 里： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct XorBase { ll p[64]; bool flag; XorBase() { flag = false; memset(p, 0, sizeof p); } bool insert(ll n) { for (int i = 63; i &gt;= 0; i--) { if ((n &gt;&gt; i) &amp; 1) { if (!p[i]) { p[i] = n; break; } n ^= p[i]; } } if (!n) flag = true; return n; } void rebuild() { for (int i = 63; i &gt;= 0; i--) { for (int j = i - 1; j &gt;= 0; j--) { if ((p[i] &gt;&gt; j) &amp; 1) p[i] ^= p[j]; } } } ll getMin() { if (flag) return 0; for (int i = 63; i &gt;= 0; i--) { if (p[i]) return p[i]; } } ll getMax() { ll ans = 0; for (int i = 63; i &gt;= 0; i--) { ans = max(ans, ans ^ p[i]); } return ans; } ll MaxK(ll k) { if (k == 1 &amp;&amp; flag) return 0; if (flag) k--; rebuild(); ll ans = 0; for (int i = 63; i &gt;= 0; i--) { if (p[i]) { if (k &amp; 1) ans ^= p[i]; k &gt;&gt;= 1; } } return ans; }}; 四. 并集 思路就是枚举异或线性基 的内容，将其中元素全部加入到 中。 12345678910XorBase Union(XorBase A, XorBase B){ XorBase res = B; for (int i = 0; i &lt;= 63; i++) { if (A.p[i]) { res.insert(A.p[i]); } } return res;} 五. 交集 如果一个异或线性基里的元素插入到另一个异或线性基里会失败，则将它插入到交集异或线性基中。 123456789101112131415XorBase Intersect(XorBase A, XorBase B){ XorBase res; for (int i = 0; i &lt;= 63; i++) { if (A.p[i]) { if (!B.insert(A.p[i])) res.insert(A.p[i]); } if (B.p[i]) { if (!A.insert(B.p[i])) res.insert(B.p[i]); } } return res;} 例 4.3.1 DMG Bonus 打核爆 作为一名资深神原玩家，你希望能在新限定五星角色初进卡池时尽快拿下全网首个 999w 核爆记录，以此证明自己的实力。现在你已经在游戏里做好了很多伤害加成型的食物，准备在 boss 战时一展身手。战斗开始时，你首先给角色吃下了基础食物（每局开始前必吃的食物），它的效果是在 300 秒内单角色爆发伤害增加 ，但是同时它有一个副作用…… 基础食物生效期内，如果角色吃下其他伤害加成型的食物，总伤害加成的百分比数值将是各种食物的伤害百分比数值的异或之和，即 ， 表示 ， 为异或符号。各种食物的伤害加成在下边给出，如果不吃任何加成型食品（也不吃基础食品），爆发伤害期望值为 。吃完所有食物后，如果你用增伤角色施加了 的爆发增伤。请问你的最大爆发伤害能否达到 ，即 ？若不能，最高伤害是多少？（令每种食物只有一份，且食物效果均可叠加，结果四舍五入到万位） 编号 加成效果 1 270% 2 200% 3 280% 4 200% 5 180% 6 150% 7 75% 问题分析：题干信息已经很明显了，这是一道异或线性基的最大和问题。根据上文所述程序计算即可。 算法实现：这里使用的是结构体封装版本的异或线性基计算代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;struct XorBase { ll p[64]; bool flag; XorBase() { flag = false; memset(p, 0, sizeof p); } bool insert(ll n) { for (int i = 63; i &gt;= 0; i--) { if ((n &gt;&gt; i) &amp; 1) { if (!p[i]) { p[i] = n; break; } n ^= p[i]; } } if (!n) flag = true; return n; } void rebuild() { for (int i = 63; i &gt;= 0; i--) { for (int j = i - 1; j &gt;= 0; j--) { if ((p[i] &gt;&gt; j) &amp; 1) p[i] ^= p[j]; } } } ll getMin() { if (flag) return 0; for (int i = 63; i &gt;= 0; i--) { if (p[i]) return p[i]; } } ll getMax() { ll ans = 0; for (int i = 63; i &gt;= 0; i--) { ans = max(ans, ans ^ p[i]); } return ans; } ll MaxK(ll k) { if (k == 1 &amp;&amp; flag) return 0; if (flag) k--; rebuild(); ll ans = 0; for (int i = 63; i &gt;= 0; i--) { if (p[i]) { if (k &amp; 1) ans ^= p[i]; k &gt;&gt;= 1; } } return ans; }} A;int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; A.insert(x); } cout &lt;&lt; (1400000 * (A.getMax() + 60 + 70) / 100) &lt;&lt; endl; return 0;} 运行代码，在输入框输入： 12345678727020028020018015075 结果输出：8162000.000。小于所给的 。因而不能达到目标，最高伤害 816 万。 洛谷例题： P3812 [模板] 线性基 P4570 [BJWC2011] 元素 P4301 [CQOI2013] 新 Nim 游戏 后记 &amp; 鸣谢 本文的灵感来源正是例 1.4.1，感谢这样的高智商解谜让我沉迷于线性代数无法自拔。 本文的结构安排和部分证明过程均借鉴了 所著《线性代数》（原书第十版），并加以个人的理解和 OI 算法方面的拓展。如有偏颇之处烦请指出，不胜感激！ 感谢 @Brailliant11001 为本文例 2.2.1 进行答案检验；@HYLW 为本文 1.3 节消元步骤进行查验；向量空间部分图片取自知乎，其余图片资源引用时请注明出处；章节例题/代码均为原创，如有错漏之处可私信我指出。","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"CF 126D - Fibonacci Sums 题解","slug":"solution-cf126d-fibonacci-sums","date":"2024-10-31T04:56:37.544Z","updated":"2024-11-01T03:17:56.475Z","comments":true,"path":"articles/126/","link":"","permalink":"https://justpureh2o.cn/articles/126/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：CF 126D 题目难度：省选/NOI- 计算一个整数被分解成若干个各不相等的Fibonacci数列中的数的方案。 前置 齐肯多夫定理 齐肯多夫定理的内容是： 任何正整数都可以被表示成若干不连续的斐波那契数之和（ 除外） 而对于一个正整数，我们可以按照二进制分解的策略：先贪心地找到一个最大的 满足 ，然后用 减去 ，以此类推直到减为 。 斐波那契数列一般定义为：，这里我们做一个整体左移，本文所述的斐波那契数列应是数列 ，也就是 。 类比二进制，齐肯多夫分解是可以用一个 串表示出来的。例如：。因此它的齐肯多夫拆分就是：。 不难发现，按照贪心策略计算出的拆分是不会存在相邻的两个 的。因为一旦出现连续的 ，都可以遵循斐波那契数的定义把它变为一个更大的斐波那契数。 回归正题 假如我们现在已经得到了一个齐肯多夫拆分，如何计算题目要求的方案总数呢？ 可以利用“标准齐肯多夫拆分中不存在相邻 ”的结论。对于原串的一个模式串 *100*（星号代表任意 串），我们可以拆成 *011*。如果在末尾的 后还有更多的 ，那其实也是可以再次拆分的。 注意到要求方案数，考虑动态规划。我们用 表示拆分中第 个 的出现位置，并令状态转移方程为 ，表示选择是否删除 位后的总方案数。 接下来考虑当前状态从何而来。如果选择不删当前这一位，答案只能从前一位 那里贡献而来，也即 。 如果选择删除这一位，对于接下来的操作，我们仍然可以选择删除或不删除。发现删到最后整个字符串一定是像 101010101 这样交错排列的。于是可以得到： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt; #define N 90using namespace std; typedef long long ll; vector&lt;int&gt; pos;ll fib[N];ll dp[N][2]; void init() { fib[1] = fib[2] = 1; for (int i = 3; i &lt; N; i++) fib[i] = fib[i - 1] + fib[i - 2];} int solve(ll x) { pos.clear(); for (int i = N - 1; i &gt;= 1; i--) { if (!x) break; if (fib[i] &lt;= x) { x -= fib[i]; pos.push_back(i - 1); } } reverse(pos.begin(), pos.end()); return pos.size();} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t; cin &gt;&gt; t; init(); while (t--) { memset(dp, 0, sizeof dp); ll x; cin &gt;&gt; x; int len = solve(x); dp[0][0] = 1; dp[0][1] = (pos[0] - 1) / 2; for (int i = 1; i &lt; len; i++) { dp[i][0] = dp[i - 1][0] + dp[i - 1][1]; dp[i][1] = dp[i - 1][0] * ((pos[i] - pos[i - 1] - 1) / 2) + dp[i - 1][1] * ((pos[i] - pos[i - 1]) / 2); } cout &lt;&lt; dp[len - 1][1] + dp[len - 1][0] &lt;&lt; endl; } return 0;} CF 通过记录","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"动态规划","slug":"动态规划","permalink":"https://justpureh2o.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Bunny Jump——斐波那契数列","slug":"algorithm-fibonacci","date":"2024-10-30T04:44:01.996Z","updated":"2024-11-01T05:57:59.112Z","comments":true,"path":"articles/14162/","link":"","permalink":"https://justpureh2o.cn/articles/14162/","excerpt":"","text":"序 斐波那契数列是一个很有意思的东西，它的每一项都由前两项的和导出，即对于 ，有 。入门算法时，尤其是刚开始涉及递归函数时，你可能就已经写过求解斐波那契数列通项的函数了。基于递归的算法会将当前数分为两个较小的数，然后继续分解直到变为 。一般来说，这样的算法复杂度是 的，极其不友好。我们会选择从定义出发，也就是使用循环结构来递推。等到了提高组，你会发现这个算法也不是最优的，稍微了解线性代数（此处尤指矩阵乘法）后，你会发现斐波那契数列的通项可以由下面这个矩阵递推式给出： 如果你熟悉数学，尤其是对生成函数有一定了解，那么你一定知道下面这个关于斐波那契数列的生成函数： 生成函数作用可大，能够快速求出数列对应项的系数。经典的“换硬币问题”就可以使用生成函数快速求解。对生成函数进行一番操作后，你会得出它的通项公式： 在计算机中会涉及到精度问题，因此我们一般使用复杂度为 的矩阵快速幂做法。接下来我们将对斐波那契数列进行一个深入的信息学方面的探究。 齐肯多夫表示法 众所周知，二进制是一种计数系统，即用 0/1 表示所有的数。那么对于斐波那契数列里的数，是否也有这样的优美性质呢？答案是肯定的，齐肯多夫证明了所有的数都可以被分解成若干斐波那契数的和，例如 。拆分方法跟二进制分解相同，找到小于等于目标数的第一个斐波那契数，并减去，重复该过程直到被分解完毕。 与二进制一样，我们也用一个 01 串来表示分解的结果。第 位对应着分解出的和式中包含 项，因此上例可以表示成：。 CF 126D - Fibonacci Sums 题目地址：CF 126D 题目难度：省选/NOI- 计算一个整数被分解成若干个各不相等的Fibonacci数列中的数的方案。 根据齐肯多夫表示法的定义，解出的 01 串按理来说是不应该含有连续的 1 的，因为连续的 1 可以累加成下一个斐波那契数。既然题目都说了，那我们其实可以反过来利用这个结论。也就是求出标准齐肯多夫表示（不含连续的 1）后对每个 100* 模式串（1 后面至少跟两个 0）进行拆解变为 011*，如果后面还有零，例如 011000 可以继续拆成 010110，以此类推…… 因此设计状态转移方程为 ，表示是否拆分第 位的 1，并令 表示标准拆分的第 位有一个 1。 考虑答案从何而来。如果不拆当前位，那我们可以对它的子序列 进行拆分（或者同样不拆分子序列），答案就由子序列贡献得到，即 。 如果要拆分当前这一位，同样也和它的子序列有关。不过， 和 之间如果相隔大于等于两个 0，也就是 时，就可以进行拆分（即 100* 拆分为 011*）。拆分后如果剩余空位大于等于 那么就还可以继续拆分，但是此时只能对最末尾的 1 进行拆分了，因为经历若干轮拆分后的序列一定形如 10101010*。问题转化成最多能在空位里留下多少个互不相邻的 1（包括端点的 1），答案即为 。如果钦定了下一位也不拆分，那么答案就是 。综上所述： 需要注意的是，此时我们会将斐波那契数列整体左移一位变为 ，因此分解式中 1 位的位置也要顺带移动一位。 题解同步于本站","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://justpureh2o.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"博弈论","slug":"博弈论","permalink":"https://justpureh2o.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"记我在 CSP-S 2024 当志愿者的半天时光","slug":"journey-to-the-csps2024","date":"2024-10-30T03:44:51.115Z","updated":"2024-11-18T18:41:21.126Z","comments":true,"path":"articles/19034/","link":"","permalink":"https://justpureh2o.cn/articles/19034/","excerpt":"","text":"您已获得最佳的阅读体验！ 距离上次参加 CSP 已经过去了一年又五天，感觉一年以来自己收获了不少。 Day -1 和去年一样，我们不参加学校运动会，在机房里备考。上下午两场模拟赛——第一场 T1，第一眼，看到“序列”，好感度降低 50 点；第二眼，看到“最大子段和”，好感度再降 50 点，发现线段树做不了，果断下一道！T2 逆天的汉诺塔问题，苦了我一个多小时最后也只能全输出 1 骗 20pts。下午的波奇酱 T1 考模拟+逆元，因为太糖了居然没有写出来？？？凉仙贝 T4 一眼打表但是太懒了不想写，终了 50pts 写了个喜多郁代……然后想着切一道大模拟，把一年半前没切过的大模拟二十分钟切出来了，居然意外的顺利耶…… 听说运动会因为下了点细雨把闭幕式延后了，然后就逃了两节常规课…… Day 0 这里采用 1-index 所以 Day 0 应为考试前夕…… Brailliant11001 大佬早上给我讲了他那个「刺激的梦」，整个上午我没有什么印象，总之就是上了一上午常规课。下午最后一节课数学，只记得数学老师讲了很多阿基米德三角形的二级结论并让我们证明，临下课了才说有一道题用行列式做很简单，时间不够了只能周六再讲。纳尼？？复习了这么久的圆锥曲线，怎么到考前了才跟我说有我最擅长的线性代数？？？ 晚上想着第二天一大早就开考了，于是试着切一道大模拟找找码感，很可惜因为一些特判不足，最后还是失败了。 Day 1 上午一觉起来发现普及组都开考了，那没办法，只能准备下午的 S 组。上午写了会自己的 API，结果搞得下午开始偏头疼了……没办法吃了颗芬必得希望不会影响下午考试。 刚到就开始掉雨点，真的很郁闷欸……临进去前杨老师带我们拍了可能是退役前最后的一张大合照……进去考场惊奇的发现他们的系统是 Win11 欸（这都是什么奇妙的关注点）。我们机房只有 HYLW 坐在我对面，很不巧的是，我们考场居然有一个小糖人——开考前一直在大声喧哗，开考后也哔哔了好一阵子；监考老师提醒多次未果、已而再犯；接下来他做不出来题又开始搞东搞西，还惊动了监考老师，把监控调了出来，不知他这次会不会喜提三年大礼包。 T1 先想了个链式排序的情况，发现具有相同攻击力的卡牌之间无法消除，很浪费，于是转而把具有相同攻击值的卡牌在同一行排开，从下到上攻击力递增，就发现了答案其实就是众数（考后我还担心这么简单的结论会不会是错的）。10min 秒了，下一个！ T2 的第一问很简单，二分直接堆上去了。对于第二问当时确实没做过类似的贪心，开始还想用线段树，但是后面想到口胡出一个做法，就是维护每辆车被哪些监控拍到超速（到这里其实跟正解都还是一样的），组成一个 01 串，然后再找是否有 0/1 串是子集关系，若是则消去作为子集的那个串，最后统计，然后发现这种做法细节炒鸡多、而且包会爆时间的。于是就这么浑浑噩噩混没了几乎剩下的所有时间。 T3 看一眼知道是 DP，序列加分问题似乎可以用模拟退火骗分，但是没时间了就不想写了（反正估计只要有分就可以进 NOIp）；T4 看到就头疼啊这又长又臭的题面真的不是拿去作为 NOI 的试题吗？果断放弃。 晚上回去，又写了一会 API。 Day 2 周日正常来说上午十点就该返校的，但是我就是不想那么早回去（反正作业也写不完干脆不写）坐牢。于是找了个借口请假到下午两点再返校，期间把 API 完善到几乎完成了，现在可以正常运行绝大部分功能了。点此食用（上课慎入） 闲来无事翻了一下自测，才发现 T4 居然是黑题、T1 就是道橙题？？？今年第一届新 CSP 就给我憋这么大坨，简直抽象至极了。 鲜花 《竞赛辞》一首： 三载春秋入信竞，初时坚信可省一。 教练无心自无意，信竞一度成电竞。 常规文化还可以，自信入坑在高一。 二分搜索和 DP，欧拉回路线性基。 塔尖Tarjan强连 DCC双连通分量，组合数学 CRT中国剩余定理。 线段平衡 BST二叉搜索树，权值种类并查集。 北上广深BSGS 算法不容易，学会复数 FFT快速傅里叶变换。 倍增树上 LCA最近公共祖先，字符串有 KMP。 思维体操构造题，码量惊人大模拟。 考纲算法多繁杂，一时缭乱数不清。 但问算法哪家强？遗传退火包第一！ 停课申请真艰辛，高一拖到这学期。 外培十日天天测，清空错位失榜一。 我问苍天为何寄，未花笑我未努力。 初赛最大是收益，J 组满分拿百金！ S 组爆炸五十一，四川划线五十起。 复赛不知作何评，机房大佬二百一。 T2 半对半全寄，归来凭栏自叹息。 初中不识信竞好，高二方悔已晚矣。 望后宵小加把劲，莫学 GZ 只尽力。 百川障之东入海，狂澜既倒日已近。 设若此轮命不济，只能高考加把劲。 我自行叹坐复愁，苦诉人生亦有命。 天生我材若有用，哪得试验总失利？ 灯火阑珊庆功宴，白墙黑瓦无人气。 虽言无奖不竞技，有人欢笑有人泣。 试看孔明盛功名，三顾频烦天下计。 竞赛不成走强基？可惜学的是信息。 数竞数学争第一，物竞物理没问题。 化竞有机一眼秒，生竞生物有实力。 信竞显然是弟弟，高考增益等于零。 宋人鬻技有百金，唯我低价修机器。 且看赢家佳人侯，月桂树下一生情。 我自呼遍天下地，未月暗夜无人应。 洋洋洒洒千百篇，不敌一朝失落音。 最后留些篇幅纪念一下 2022 级的 OIer 们： 2023 信竞五人帮在此集结：","categories":[{"name":"鲜花","slug":"鲜花","permalink":"https://justpureh2o.cn/categories/%E9%B2%9C%E8%8A%B1/"}],"tags":[{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.cn/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"},{"name":"csp-s","slug":"csp-s","permalink":"https://justpureh2o.cn/tags/csp-s/"}]},{"title":"P2011 - 计算电压 题解","slug":"solution-p2011-voltage-calculator","date":"2024-10-09T04:27:23.489Z","updated":"2024-10-09T05:05:24.383Z","comments":true,"path":"articles/2011/","link":"","permalink":"https://justpureh2o.cn/articles/2011/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P2011 题目难度：省选/NOI- 现给定一个电阻网络，已知其中每条边上的电阻，和若干个点和负极之间的电压（电源电压不变） ，现在求任意两点之间的电压。 对于 的数据，，，，。 要解决这道题，我们首先要明白一个定理，即 电流定律（，或称 第一定律）。定理内容如下： 电路中任意一个节点上，在任何时刻，流入这个节点的电流之和等于流出这个节点的电流之和。 于是我们把每一个接线柱分开来看。假如当前在讨论接线柱 ，假设电流从若干接线柱流出并流入 ，那么记 为这些接线柱的集合；相应地，如果电流从 流出，并流入另一些接线柱，那么记这些接线柱的集合为 。此时根据欧姆定律有如下关系： 发现此时又要求每个电阻丝的电压，非常的麻烦。根据高中知识可得，导体两端的电压其实就等于它两端的电势之差，假如电阻丝 左右分别连接着接线柱 ，那么 。上式转化为： 发现最后的这个方程式可以使用高斯消元来解决，在系数矩阵中分别填入 ，作为系数。此时需要注意，第 项的系数应是 。对于题目中已经给定的值，即直接与正极相连的接线柱只需要列出形如 的方程即可。不难发现方程组有 条方程， 个未知数，是一定有解的。题目的询问就可以转化成求两接线柱之间的电势差了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;#define N 210using namespace std;typedef pair&lt;int, double&gt; PID;const double EPS = 1e-12;vector&lt;PID&gt; G[N];double matrix[N][N];double voltage[N];double start[N];int gauss(int n) { int rank = 0; for (int c = 0, r = 0; c &lt;= n; c++) { int t = r; for (int i = r; i &lt;= n; i++) { if (abs(matrix[i][c]) &gt; abs(matrix[t][c])) t = i; } if (abs(matrix[t][c]) &lt; EPS) continue; if (t ^ r) swap(matrix[t], matrix[r]); for (int i = n + 1; i &gt;= c; i--) matrix[r][i] /= matrix[r][c]; for (int i = 0; i &lt;= n; i++) { if (abs(matrix[i][c]) &gt; EPS &amp;&amp; i ^ r) { for (int j = n + 1; j &gt;= c; j--) { matrix[i][j] -= matrix[i][c] * matrix[r][j]; } } } r++; rank++; } for (int i = 0; i &lt;= n; i++) voltage[i] = matrix[i][n + 1]; return 2;}void out(int n) { cerr &lt;&lt; \"------------------\" &lt;&lt; endl; for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt;= n + 1; j++) { cerr &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; setw(10) &lt;&lt; matrix[i][j]; } cerr &lt;&lt; endl; } cerr &lt;&lt; \"------------------\" &lt;&lt; endl;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m, k, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q; while (k--) { int u; cin &gt;&gt; u &gt;&gt; start[u]; } while (m--) { int u, v; double w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].emplace_back(v, w); G[v].emplace_back(u, w); } matrix[0][0] = 1.0; for (int i = 1; i &lt;= n; i++) { double sum = 0.0; if (abs(start[i]) &gt; EPS) { matrix[i][i] = 1.0; matrix[i][n + 1] = start[i]; continue; } for (auto p: G[i]) { int u = p.first; matrix[i][u] += 1.0 / p.second; sum += 1.0 / p.second; } matrix[i][i] = -sum; } gauss(n); while (q--) { int u, v; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; voltage[u] - voltage[v] &lt;&lt; endl; } return 0;} 说句闲话：第一学月物理考试彻底炸了……诺贝尔物理学奖颁给了机器学习……我在这里写信息学物理题题解……","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"P3429 [POI2005] DWA - Two Parties 题解","slug":"solution-p3429-two-parties","date":"2024-10-06T17:37:24.903Z","updated":"2024-10-06T18:01:42.635Z","comments":true,"path":"articles/3429/","link":"","permalink":"https://justpureh2o.cn/articles/3429/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P3429 题目难度：省选/NOI- 题目来源：POI Poland 2005 拜占庭国王要举办两个大派对，并且希望邀请更多的居民。 国王从他的丰富经验里知道，如果一个居民在派对上能遇到偶数个的朋友，那他会非常高兴。因此，他要求你邀请国家的居民去两个派对，而使尽可能多的人在他们的聚会上有偶数个的朋友。认识是一种对称关系，如 认识 ，那么 也认识 。 输出第一行是一个整数 ，是前往第一个排队的人数。第二行 个整数，是去第一个派对的居民编号，其余的居民前往第二个派对。如果有多种答案，你只需要输出一个。 建方程组的思路和 P6126 始祖鸟 相同。分朋友数的奇偶性讨论，如果朋友数是偶数，那么只要 任意一处出现偶数个朋友，另一处就一定也会出现偶数个朋友，那么这个人去哪里都可以；如果朋友数是奇数，且在 地出现奇数个朋友，那么 地就一定会有偶数个朋友，他只能去 地，反之亦然。 如果第 个人去 地，那么令 ，否则令 。对于有偶数个朋友的人，只要他的朋友里存在偶数个 和偶数个 即可，不难发现，这些朋友的代表值异或起来是等于 的；相对地，对于有奇数个朋友的人，他只能去偶数的那一方，此时如果算上这个人，就会出现偶数个 和奇数个 ，全部异或的结果是 。然后就可以列方程组求解了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define N 210using namespace std;bitset&lt;N&gt; matrix[N];bitset&lt;N&gt; ans;int n;void out() { cerr &lt;&lt; \"-----------------\" &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) { cerr &lt;&lt; setw(5) &lt;&lt; matrix[i][j]; } cerr &lt;&lt; endl; } cerr &lt;&lt; \"-----------------\" &lt;&lt; endl;}int gauss() { int rank = 0; for (int c = 1, r = 1; c &lt;= n; c++) { int t = r; for (int i = r; i &lt;= n; i++) { if (matrix[i].test(c)) { t = i; break; } } if (!matrix[t].test(c)) continue; if (t ^ r) swap(matrix[r], matrix[t]); for (int i = 1; i &lt;= n; i++) { if (matrix[i].test(c) &amp;&amp; i ^ r) { matrix[i] ^= matrix[r]; } } r++; rank++; } if (rank &lt; n) { for (int i = rank + 1; i &lt;= n; i++) { if (matrix[i].test(n + 1)) return 0; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) { if (matrix[i].test(j)) { ans[j] = matrix[i][n + 1]; break; } } } return 1; } for (int i = 1; i &lt;= n; i++) ans[i] = matrix[i][n + 1]; return 2;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { int k; cin &gt;&gt; k; if (k &amp; 1) matrix[i].flip(i); matrix[i][n + 1] = k &amp; 1; while (k--) { int x; cin &gt;&gt; x; matrix[i].flip(x); } } int res = gauss(); if (res) { cout &lt;&lt; ans.count() &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { if (ans.test(i)) cout &lt;&lt; i &lt;&lt; ' '; } } else cout &lt;&lt; \"Impossible\" &lt;&lt; endl; return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"P6126 [JSOI2012] - 始祖鸟 题解","slug":"solution-p6126-archaeopteryx","date":"2024-10-06T17:22:18.735Z","updated":"2024-10-06T17:39:34.425Z","comments":true,"path":"articles/6126/","link":"","permalink":"https://justpureh2o.cn/articles/6126/","excerpt":"","text":"您已获得最佳的阅读体验 题目地址：P6126 题目难度：省选/NOI- 题目来源：江苏 2012 各省省选 有 只始祖鸟，我们从 开始编号。对于第 只始祖鸟，有 个认识的朋友，它们的编号分别是 。朋友的认识关系是单向的，也就是说如果第只始祖鸟认识第 只始祖鸟，那么第 只始祖鸟不一定认识第 只始祖鸟。 聚会的地点分为两处，一处在上游，一处在下游。对于每一处聚会场所，都必须满足对于在这个聚会场所中的始祖鸟，有恰好有偶数个自己认识的朋友与之在同一个聚会场所中。当然，每一只始祖鸟都必须在两处聚会场所之一。 现在需要你给出一种安排方式。你只需要给出在上游的始祖鸟编号，如果有多组解，请输出任何一组解。如果无法满足要求，只输出一行 Impossible。 对于 的数据，。 为所有始祖鸟按朋友数的奇偶性分类。对于朋友数是偶数的始祖鸟，只要在上游/下游出现偶数个朋友，那么另一方也肯定存在偶数个朋友，此时当前的始祖鸟就可以在上下游中任意选择去向；如果这只始祖鸟有奇数个朋友，那么上游/下游一定是一边奇数一边偶数，此时这只鸟只能去偶数那侧。 若当前始祖鸟在上游，我们令 ，否则 。对于朋友数是偶数的始祖鸟，把它的所有朋友代表的数异或起来，那就相当于偶数个 与偶数个 异或，结果为 ；对于朋友数是奇数的始祖鸟，把自己和它的朋友代表的数异或起来，相当于偶数个 和奇数个 异或，结果一定是 。因此对于某只有 个朋友的始祖鸟 ，一定有如下关系： 然后对每只始祖鸟建立关系，再使用异或高斯消元即可。这里介绍一种能方便解决“无数组解特解求解”问题的消元法。 一般的高斯消元会把矩阵消元成一个上/下三角矩阵，矩阵的同一列可能存在多个非零的系数，也就代表着方程之间的未知数还存在相互依赖关系，求解时只能老老实实向上回代，遇到存在自由元的情况时会较难处理。 我们认为这样的矩阵是“未完全化简的”，事实上，如果在减法/异或消元时让每一行都重新消元一次，而不是只对 行消元，那么最终你会得到一个同一列只存在一个非零系数的增广矩阵。特别地，对于存在唯一解的情况，它是一个对角矩阵，此时每个未知数的解就是对应常数项的值；如果是存在无数组解的情况，找到主元也非常简单：只需找到每一行的第一个非零系数，然后直接将它赋值为常数项。对于主元右侧的所有非零系数，一律当自由元赋值为 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define N 2010using namespace std;bitset&lt;N&gt; matrix[N];bitset&lt;N&gt; ans;int n;void out() { cerr &lt;&lt; \"-----------------\" &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) { cerr &lt;&lt; setw(5) &lt;&lt; matrix[i][j]; } cerr &lt;&lt; endl; } cerr &lt;&lt; \"-----------------\" &lt;&lt; endl;}int gauss() { int rank = 0; // 矩阵的秩 for (int c = 1, r = 1; c &lt;= n; c++) { int t = r; for (int i = r; i &lt;= n; i++) { if (matrix[i].test(c)) { // 找到绝对值最大的行（只要第一个系数是 1 即可） t = i; break; } } if (!matrix[t].test(c)) continue; // 跳过零行 if (t ^ r) swap(matrix[r], matrix[t]); // 交换到第一行 for (int i = 1; i &lt;= n; i++) { // 与普通高斯消元的不同之处，对 1~n 行全部消元 if (matrix[i].test(c) &amp;&amp; i ^ r) { // 当前行不消，零行不消 matrix[i] ^= matrix[r]; // 异或代替减法进行消元 } } r++; rank++; } if (rank &lt; n) { // 秩小于 n，可能是无数组解、有可能无解 for (int i = rank + 1; i &lt;= n; i++) { if (matrix[i].test(n + 1)) return 0; // 存在类似于 0=k 的矛盾情况，无解 } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) { if (matrix[i].test(j)) { // 无数组解，找到主元并赋值 ans[j] = matrix[i][n + 1]; break; } } } return 1; } for (int i = 1; i &lt;= n; i++) ans[i] = matrix[i][n + 1]; // 有唯一解，对角矩阵每个未知数的解就是常数项的值 return 2;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { int k; cin &gt;&gt; k; if (k &amp; 1) matrix[i].flip(i); // 奇数个朋友建立方程组时要算上自己 matrix[i][n + 1] = k &amp; 1; while (k--) { int x; cin &gt;&gt; x; matrix[i].flip(x); } } int res = gauss(); if (res) { cout &lt;&lt; ans.count() &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { if (ans.test(i)) cout &lt;&lt; i &lt;&lt; ' '; } } else cout &lt;&lt; \"Impossible\" &lt;&lt; endl; return 0;} Hack 数据也过了，这是记录。你可以调用函数 out() 来输出矩阵的项。","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"线性代数 高斯消元","slug":"algorithm-gauss-elimination","date":"2024-10-06T05:59:39.512Z","updated":"2024-10-11T04:58:46.283Z","comments":true,"path":"articles/41750/","link":"","permalink":"https://justpureh2o.cn/articles/41750/","excerpt":"","text":"Gauss-Jordan 消元法 也叫高斯-若尔当消元法，简称高斯消元法或高斯消元。它可以在 的时间复杂度内求出矩阵方程组的解、以及给定矩阵的逆矩阵、行列式等。 基础知识 初等行变换：指的是对一个矩阵中的某些行进行的基本变换，具体如下： 交换某两行。相当于把方程组的顺序调换一下，本质上不影响该矩阵。 将某一行乘以一个非零数。相当于给某个方程做等比放缩，可以通过除以该倍数还原，且不影响最终解。 将某一行乘以一个非零倍数后对位相加到另一行。相当于把前两个操作综合起来，这是高斯消元中核心的步骤。 增广矩阵：有时我们会拿到形如这样的方程组： 那么把它写成矩阵形式就应该是： 发现这个矩阵只对应了原方程组中的未知数系数，而并没有它的常数项，这种矩阵叫做系数矩阵。而增广矩阵就是将它的系数囊括进来，系数和常数之间用竖线分割。如下： 行阶梯型：定义形如： 的矩阵为行阶梯型矩阵。不难发现，这个矩阵中所有的非零系数组成一个类似于三角形的结构，且它们都聚集在右上角，这就叫做上三角型矩阵；若这些系数聚集在左下角，则称作下三角型矩阵。 主元/自由元：在求解矩阵方程时，偶尔会碰见某些未知数存在无数组解的情况，它们就叫做自由元。那些已经唯一确定的变量就叫做主元。在高斯消元过程中，某一行的第一个非零系数就对应一个主元。 以上就是所有的前置知识，更多内容见 线性代数 简明教程。 算法流程 首先我们需要把矩阵化简成为行阶梯型，化简有这几个步骤（假设有 个方程组）： 枚举每一列 ，找出第 行中第 列系数绝对值最大的那一行，并交换到第 行。 对这一行整体除以这个系数，让该行第 列变为 。 对于该行下边的所有行，正常状况下它们的前 列系数都应已经化为 ，假如它们的第 列元素分别是 。那么分别让每一行对位减去该行的 倍，让第 列系数化为 。 重复操作直到第 行第 列系数化为 。 此时如果从矩阵方程组的角度审视这个矩阵，你会发现最后一行就已经可以变为 的已经解出的形式。此时向上回代，第 行应为 ，此时只需计算 就可得出 的结果，以此类推……直到所有未知数均已敲定为止。 当然，我们还可以更进一步。让当前行的上面所有行再减去当前行的某个倍数。那么当存在唯一解时，我们可以把原矩阵消元成只有对角线的矩阵，这样更加简单，每个未知数的值就是右侧的系数，甚至无需回代；存在无数组解时，矩阵同一列上不会出现两个及以上的非零项，意味着当前行未知数的状态只与当前行有关，而不会存在一般高斯消元中的行与行间的相互依赖，在处理无数组解时非常好用。后文均会用这种消元方法。 细心的你一定发现了：无解情况该怎么判断呢？ 联系一元二次方程的求解。若只关心实根，我们可以使用 判别法，。我们都知道对负数开根号是不会得到实数的（详见“复数”），观察到前面的正负号，只有在 时才有两个相同的实根，当 时是会得到两个不同结果的。因此： 方程无实数解方程有两个相同的实数解方程有两个不相同的实数解 在矩阵中也有类似的判断方法，秩就是其中之一（行列式等其他判别法此处不给出），用 表示 矩阵的秩。矩阵的秩定义为线性无关的横行/纵行的极大数目。简单来说就是化为行阶梯型后非零行的个数。一般情况下（方程个数等于未知数个数）系数矩阵和增广矩阵的秩都是 。那如果存在无数组解，此时系数矩阵和增广矩阵都存在零行，即 。如果无解，也就是出现诸如 的情况，即系数矩阵的秩严格小于增广矩阵的情况。若 为系数矩阵、 为增广矩阵，那么： 方程组有唯一解方程组有无数组解方程组无解 有唯一解和无解都好解决，主要是这个无数组解的情况，普通的回代似乎不起作用，因为有些未知数我们并不知道具体值，因此无法代入。此时就需要分离主元和自由元了。 如果使用上面说的，最终将矩阵消元成对角线矩阵的消元法，此时就非常简单。主元对应着某一行的第一个非零项，其值就是该行的常数项；若该行存在不止一个非零项，我们就自动把后面的非零项看作自由元，赋值任意。 12345678910111213141516171819202122232425262728293031323334353637383940int gauss() { int rank = 0; // 秩 for (int c = 1, r = 1; c &lt;= n; c++) { int t = r; for (int i = r; i &lt;= n; i++) { if (abs(matrix[i][c]) &gt; abs(matrix[t][c])) t = i; // 找出主元绝对值最大的那一行 } if (abs(matrix[t][c]) &lt; EPS) continue; // 非零才能消成1 if (t != r) swap(matrix[t], matrix[r]); // 交换 for (int i = n + 1; i &gt;= c; i--) matrix[r][i] /= matrix[r][c]; // 主元消成1 for (int i = 1; i &lt;= n; i++) { // 反复消元，成为对角线矩阵 if (abs(matrix[i][c]) &gt; EPS &amp;&amp; i ^ r) { // 当前行不消，若当前位已经是零了也不消 for (int j = n + 1; j &gt;= c; j--) { matrix[i][j] -= matrix[i][c] * matrix[r][j]; // 消成零 } } } r++; rank++; } if (rank &lt; n) { // 无解or无数组解 for (int i = rank + 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) { if (abs(matrix[i][j]) &gt; EPS) return 0; // 无解 } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (abs(matrix[i][j]) &gt; EPS) { ans[j] = matrix[i][n + 1]; // 无数组解，找到主元并直接赋值，剩余的自由元自动赋值为0 break; } } } return 1; } for (int i = 1; i &lt;= n; i++) ans[i] = matrix[i][n + 1]; // 有解，此时常数项即为答案 return 2;} 高斯消元例题 洛谷 P2455 [SDOI2006] 线性方程组 题目地址：P2455 题目难度：提高+/省选- 题目来源：山东 2006 各省省选 已知 元线性一次方程组。 请根据输入的数据，编程输出方程组的解的情况。如果有唯一解，则输出解。你的结果被认为正确，当且仅当对于每一个 而言结果值与标准答案值的绝对误差或者相对误差不超过 。如果方程组无解输出 ；如果有无穷多实数解，输出 ； 对于 的数据，。对于 ，有 ，。 这道题就是模板题，用方才给出的对角线版消元代码就可以轻松过掉这个题。需要注意的是，对于浮点数消元，由于精度问题，需要设置最低精度，一般当 时就可认为这个浮点数为零。 洛谷 P4035 [JSOI2008] 球形空间产生器 题目地址：P4035 题目难度：提高+/省选- 题目来源：江苏 2008 各省省选 给定一个 维球体和球面上 个点的坐标，请确定这个 维球体的球心坐标，保留 位小数。球面上的所有点距离球心均相同，坐标的每一个实数精确到小数点后 位，且其绝对值都不超过 。 保证 根据球心定义，可以列出方程组： 解出方程， 就是球心坐标。考虑等号两端同时平方，并移项消去平方项，最终可以得到一个 元线性方程组，高斯消元解出即可。 洛谷 P10315 [SHUPC 2024] 原神，启动！ 题目地址：P10315 题目难度：提高+/省选- 题目来源：SHUPC 2024 雷元素方碑具有如下性质： 具有 种状态， 中的一种； 方碑受到一次攻击会进入下一个状态（ 的下一个状态是）； 某个方碑受到一次攻击时会带动其它一些方碑一起进入下一个状态。 现在有 个雷元素方碑，每个雷元素方碑有 种状态。对于每个方碑 ，当它受到攻击时，都有 个其它方碑和它一起进入下一个状态。给定 个雷元素方碑的初始状态 和终止状态 ，请你计算需要分别攻击每个方碑多少下，才能将雷元素方碑从状态 变换到 。如果无解请输出niuza，如果存在无数组解则任意输出一组。 ，保证 为质数。 本题数据过水，求无数组解特解的样例放在了后面。 本题其实是在让我们求如下方程组的特解： 思路和普通高斯消元是一样的，只是和实数高斯消元不同，带模数的式子中不能直接出现除法。那我们直接把除法改换成逆元就好了。注意负数的处理，最终答案要规约到 内。 接下来是 Hack 数据（有两种可行解）： 12345678910In:3 32 2 32 1 31 10 0 02 1 2Out:0 1 1 or 1 0 1 题解同步于本站 洛谷 P6126 [JSOI2012] 始祖鸟 题目地址：P6126 题目难度：省选/NOI- 题目来源：江苏 2012 各省省选 现在有 只始祖鸟，我们从 开始编号。对于第 只始祖鸟，有 个认识的朋友，它们的编号分别是 ，，，。朋友的认识关系是单向的，也就是说如果第只始祖鸟认识第 只始祖鸟，那么第 只始祖鸟不一定认识第 只始祖鸟。 聚会的地点分为两处，一处在上游，一处在下游。对于每一处聚会场所，都必须满足对于在这个聚会场所中的始祖鸟，有恰好有偶数个自己认识的朋友与之在同一个聚会场所中。当然，每一只始祖鸟都必须在两处聚会场所之一。 现在需要你给出一种安排方式。你只需要给出在上游的始祖鸟编号，如果有多组解，请输出任何一组解。如果无法满足要求，只输出一行 Impossible。 对于的数据，。 把所有始祖鸟按朋友个数的奇偶性分类，这只鸟如果有偶数个朋友，只要上游和下游其中一方存在偶数个朋友，那么另一端也会有偶数个朋友，这只鸟哪里都可以去；如果它有奇数个朋友，这奇数个朋友必定是“奇数+偶数”分布的，那么只需让这只鸟到有偶数个朋友的一段即可。 令在上游为 ，在下游为 。若存在偶数个朋友在其中一方，即（此时只算朋友的情况）偶数个 和 全部异或，结果为 ；若存在奇数个朋友，如果有偶数个朋友在上游，这只鸟必定到上游，（此时算上当前这只鸟和它的所有朋友）也就是奇数个 和奇数个 异或，结果是 ；反过来，如果有偶数个朋友在下游，那么就是奇数个 和奇数个 异或，结果为 。那么对于一只有 个朋友的鸟 ，能够得到这样的关系： 分别对应朋友数为偶数和奇数的情况。紧接下来使用 bitset 优化异或高斯消元： 与一般的高斯消元接近，异或高斯消元使用异或来代替消元时的减法操作，而且因为方程组的系数只会出现 ，因而不需要将当前的首个元素通过除法化为 。其余步骤，包括找出绝对值最大的行，和普通高斯消元是一致的。 双倍经验：P3429 [POI2005] DWA-Two Parties 题解同步于本站 P2973 [USACO10HOL] Driving Out the Piggies G 题目地址：P2973 题目难度：省选/NOI- 题目来源：USACO 2010 一个 个点、 条边的无向图，节点1有一个炸弹，在每个单位时间内，有 的概率在这个节点炸掉，有 的概率随机选择一条出去的路到其他的节点上。问最终炸弹在每个节点上爆炸的概率。 对于当前点，它可能由与它相连的点转移过来。假如与当前点相连的所有点的爆炸概率分别设成未知数，那么在这个点爆炸的概率就应该是在相连点不爆炸的情况下再移动到当前点上的概率，即： 其中 为 点的度数。我们发现有一个特殊点是 号点，要么在这个点爆炸，要么转移到相连的点，即： 然后直接套高斯消元模板即可。","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"P9220 [TAOI-1] - 椎名真昼 题解","slug":"solution-p9220-shiina-mahiru","date":"2024-10-05T05:22:55.891Z","updated":"2024-10-09T05:02:49.743Z","comments":true,"path":"articles/9220/","link":"","permalink":"https://justpureh2o.cn/articles/9220/","excerpt":"","text":"您已获得最佳的阅读体验 题目地址：P9220 题目难度：提高+/省选- Alice 和 Bob 正在玩一款游戏，给定一个有向图，每个点初始有一个颜色（黑或白）。 双方轮流进行操作，Alice 先手，每次操作选定一个节点，将所有从该点开始，能到达的点（包括自身）颜色翻转。如果某次操作后所有节点都变为白色，则进行该次操作的人胜利。 假如双方都采用最优策略使得自己胜利，或者如果自己无法胜利，使得对方无法胜利。 给你节点的初始状态，请你求出最终的胜者，亦或者，没有胜者。 定义点 能到达点 ，当且仅当存在数列 ，其中 ，使得 ，存在有向边 ，且 ，。 对于所有测试数据，，，。 首先，如果这个游戏无法在两步及以内结束的话，就可以直接算平局了。因为若是超过两步，认为自己会输的那一方将会想尽办法不让你赢，具体表现就是重复另一方先前的操作，让图变为另一方操作前的状态，最终陷入死循环。因此我们只需关注一步定胜负和两步定胜负的情况。 根据题目中对两点能互相到达的定义，我们很容易知道——若对某个 中的点进行一次操作，那么同处于这个 的其他点的颜色也都会翻转（但不止这些点的颜色被翻转）。这启发我们处理出原图中的所有强连通分量。此时不难发现，如果某个 中存在异色点，那么无论怎么翻转，它们都不会变为统一颜色，于是这种情况可以直接判成平局；否则我们就把这个强连通分量染成内部点的颜色。 处理出所有的强连通分量后，我们再把一个强连通分量整体看作一个新点，建在新图上（即缩点），此时新图必定是一个有向无环图 。那么如果在某个强连通分量中的某个点上进行操作，新图中该强连通分量的子节点一定也会受到影响从而变化颜色。至此我们便理清了操作与颜色翻转之间的规律。 现在来讨论必胜局面。因为游戏不会超过两轮，所以如果先手的 想要获胜，她就必须在第一轮胜利，否则要么 胜、要么平局。也因此，在新建的有向无环图上，有且仅能存在一个节点，使得它的子树包含新图中所有的黑色 ，且不包含任何白色 。这样一来先手 才能一次把这些黑色点转化成白色从而获胜。如果这个子树不完全是黑色 ，或者是存在多个节点满足要求，都不能保证 获胜（但也不代表必输，因为还存在平局）。 再来看 这边，他如果想要获胜，就只能抓住第二轮这唯一的机会。有三种可能性： 全图均为白色节点。这样 只能选择白色节点染黑，此时 只需重复她的操作即可恢复全图到全白的状态。 仅有两个孤立的黑色 。此时 选择其一染白， 仅需染白另一个即可。 一个白色 和一个黑色 ，并且仅有一条有向边从黑点指向白点。此时无论 开局选择染哪个点， 总能在第二轮把全图染成白色而获胜。 其他情况即为二人平局。注意多测清空！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;bits/stdc++.h&gt;#define N 100010#define M 200010using namespace std;struct Edge { int to, ne;} edges[M], dag[M];int h[N], hs[N], idx = 0, idx1 = 0;int scc_cnt = 0, dfs_cnt = 0;int dfn[N], low[N];int scc_id[N];vector&lt;int&gt; scc[N];stack&lt;int&gt; stk;bool st[N];bool in_stk[N];bool color[N], scc_color[N];int deg[N];void add(int u, int v) { // 建原图 idx++; edges[idx].to = v; edges[idx].ne = h[u]; h[u] = idx;}void shrink(int u, int v) { // 建缩点后的图 idx1++; dag[idx1].to = v; dag[idx1].ne = hs[u]; hs[u] = idx1;}bool tarjan(int u) { stk.push(u); in_stk[u] = true; dfn[u] = low[u] = ++dfs_cnt; for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; if (!dfn[j]) { tarjan(j); low[u] = min(low[u], low[j]); } else if (in_stk[j]) { low[u] = min(low[u], dfn[j]); } } if (dfn[u] == low[u]) { scc_cnt++; int t; do { t = stk.top(); stk.pop(); in_stk[t] = false; scc_id[t] = scc_cnt; // 每个点对应的 SCC 编号 scc[scc_cnt].push_back(t); // 维护 SCC 内的节点 } while (t != u); // 如果同一个 SCC 内存在异色节点，即为无解（平局） for (int i = 1; i &lt; scc[scc_cnt].size(); i++) { if (color[scc[scc_cnt][i]] ^ color[scc[scc_cnt][i - 1]]) return false; } scc_color[scc_cnt] = color[scc[scc_cnt][0]]; // 同色，给 SCC 染色 } return true;}void init() { idx = 0; idx1 = 0; while (!stk.empty()) stk.pop(); for (int i = 1; i &lt;= scc_cnt; i++) scc[i].clear(); scc_cnt = dfs_cnt = 0; memset(st, false, sizeof st); memset(scc_id, 0, sizeof scc_id); memset(dfn, 0, sizeof dfn); memset(low, 0, sizeof low); memset(in_stk, false, sizeof in_stk); memset(deg, 0, sizeof deg); memset(h, -1, sizeof h); memset(hs, -1, sizeof hs);}int getFirstBlack() { // 拓扑排序找出第一个黑色 SCC queue&lt;int&gt; topo; for (int i = 1; i &lt;= scc_cnt; i++) { if (!deg[i]) topo.push(i); } while (!topo.empty()) { int t = topo.front(); topo.pop(); if (scc_color[t]) return t; for (int i = hs[t]; ~i; i = dag[i].ne) { int j = dag[i].to; if (--deg[j] == 0) topo.push(j); } } return 0;}bool dfs(int u) { // 检查黑色子树中是否混有白色 SCC bool ret = scc_color[u]; st[u] = true; for (int i = hs[u]; ~i; i = dag[i].ne) { int j = dag[i].to; if (st[j]) continue; ret &amp;= dfs(j); } return ret;}bool check() { for (int i = 1; i &lt;= scc_cnt; i++) { if (scc_color[i] &amp;&amp; !st[i]) return false; // 子树必须包含新图中所有的黑色 SCC } return true;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t, m, n; cin &gt;&gt; t; while (t--) { init(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; color[i]; int u, v; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; u &gt;&gt; v; add(u, v); } bool tmp = true; for (int i = 1; i &lt;= n; i++) { if (!dfn[i]) { if (!tarjan(i)) { tmp = false; cout &lt;&lt; 'N'; break; } } } if (!tmp) continue; // 同 SCC 存在异色节点，直接判无解（平局） bool b2w = true; for (int i = 1; i &lt;= scc_cnt; i++) { for (int a: scc[i]) { for (int j = h[a]; ~j; j = edges[j].ne) { int k = edges[j].to; if (scc_id[a] != scc_id[k]) { // 缩点建图 shrink(scc_id[a], scc_id[k]); b2w &amp;= !scc_color[scc_id[k]] &amp;&amp; scc_color[scc_id[a]]; // 存在一黑一白，检查是否是黑点指向白点 deg[scc_id[k]]++; // 维护入度 } } } } int start = getFirstBlack(); if (dfs(start) &amp;&amp; check()) cout &lt;&lt; 'A'; // Alice else if (!start &amp;&amp; !color[1]) cout &lt;&lt; 'B'; // Bob 情况1 else if (scc_cnt == 2 &amp;&amp; scc_color[1] &amp; scc_color[2]) cout &lt;&lt; 'B'; // Bob 情况2 else if (scc_cnt == 2 &amp;&amp; b2w) cout &lt;&lt; 'B'; // Bob 情况3 else cout &lt;&lt; 'N'; } return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"博弈论","slug":"博弈论","permalink":"https://justpureh2o.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"P9850 [ICPC2021 Nanjing R] - Ancient Magic Circle in Teyvat 题解","slug":"solution-p9850-ancient-magic-circle-in-teyvat","date":"2024-10-04T05:56:24.940Z","updated":"2024-10-04T06:00:04.952Z","comments":true,"path":"articles/9850/","link":"","permalink":"https://justpureh2o.cn/articles/9850/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P9850 题目难度：NOI/NOI+/CTSC 题目来源：ICPC 南京 2021 给定一个 个点的完全图，有 条边是红色的，其余边是蓝色的，求出边均为蓝色的大小为 的完全子图个数与边均为红色的大小为 的完全子图个数的差。 对所有数据满足，， 的量级是 的，因此不能直接建完全图，考虑把蓝色图用红色图表示出来。假设存在 个有 条边的红色子图，那么对于一张存在 条红色边的图，就能有 种选择方法；此时再令 表示大小为 且存在 条红色边的完全子图个数，因此有下式： 对上面的式子使用二项式反演得： 那么求蓝色完全子图和红色完全子图的差就可以用 得到，接下来对每个 进行分类讨论： 时，即没有选定的红色边。此时随便选择四个点组成图，即 。 时，需选定一条红色边。选边方案数是 ，此时确定下两个端点，那么在剩下的 个点里选择两个点，即 。 时，分两类考虑： 两条线有公共端点：首先枚举这个公共点，再枚举两条以该点为端点的线段，最后选剩下的那个点。此时方案数为 ，其中 为原无向图中点 的度数。 两条线无公共端点：正难则反，将原图中任意选两条边的方案数减去两条线有公共端点的方案数即得两条线无公共端点的方案数。也就是 。 两情况求和得：。 时，继续分类讨论： 三条边组成一个三元环，再枚举剩下的一个点，结果为 。 三条边共用一个顶点，枚举这个顶点，选择直连边中的三条即可涵盖四个点，即 。 三条边形成链状结构。选择一条边，该边的两个端点分别支出去一条边，刚好覆盖满四个点。注意把成环情况舍去，同一个三元环会算三次，最终需减去 。结果为：。 综上，。 时，分两类讨论： 四条边组成一个四元环，四个点恰好均被覆盖，无需多余枚举，结果为 。 三元环的某个顶点支出去一条边，枚举这个端点。结果为 ，其中 为经过点 的不同三元环个数。 综上，。 时，只有一种情况，那就是两个三元环共用一条边。此时只需枚举这个公共边即可，即 ，其中 表示求解三元环时完成定向的边集， 表示覆盖到边 的不同三元环个数。 最后套公式计算即可，注意加上绝对值，建图用前向星会超时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;#define N 100010#define M 200010using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; PII;vector&lt;PII&gt; E[N];vector&lt;int&gt; G[N];int u[N &lt;&lt; 1], v[N &lt;&lt; 1];ll deg[N &lt;&lt; 1];ll cnt[N &lt;&lt; 1];ll containerP[N], containerE[M];int tmp[N], id[N];ll n, m;ll countTripling() { ll ret = 0; for (int i = 1; i &lt;= n; i++) { for (auto j: E[i]) id[j.first] = j.second; for (auto j: E[i]) { int k = j.first; for (auto l: E[k]) { int w = l.first; if (id[w]) { containerP[i]++; containerP[k]++; containerP[w]++; containerE[j.second]++; containerE[l.second]++; containerE[id[w]]++; ret++; } } } for (auto j: E[i]) id[j.first] = 0; } return ret;}ll countQuadrant() { for (int i = 1; i &lt;= m; i++) { if ((deg[u[i]] == deg[v[i]] &amp;&amp; u[i] &gt; v[i]) || deg[u[i]] &gt; deg[v[i]]) swap(u[i], v[i]); E[u[i]].emplace_back(v[i], i); } ll ret = 0; int hh = 0; for (int i = 1; i &lt;= n; i++) { for (int j: G[i]) { for (auto k: E[j]) { int w = k.first; if (deg[i] &lt; deg[w] || (deg[i] == deg[w] &amp;&amp; i &lt; w)) { ret += cnt[w]; if (!cnt[w]) tmp[hh++] = w; cnt[w]++; } } } for (int j = 0; j &lt; hh; j++) cnt[tmp[j]] = 0; hh = 0; } return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; u[i] &gt;&gt; v[i]; deg[u[i]]++; deg[v[i]]++; G[u[i]].push_back(v[i]); G[v[i]].push_back(u[i]); } ll quad = countQuadrant(); ll trip = countTripling(); ll f0, f1, f2 = 0, f3 = 0, f4 = 0, f5 = 0; for (int i = 1; i &lt;= n; i++) { f2 += deg[i] * (deg[i] - 1) / 2 * (n - 4); f3 += deg[i] * (deg[i] - 1) * (deg[i] - 2) / 6; f4 += containerP[i] * (deg[i] - 2); for (auto j: E[i]) { int k = j.first; f3 += (deg[i] - 1) * (deg[k] - 1); } } for (int i = 1; i &lt;= m; i++) { f5 += containerE[i] * (containerE[i] - 1) / 2; } f0 = (__int128) n * (n - 1) * (n - 2) * (n - 3) / 24; f1 = m * (n - 2) * (n - 3) / 2; f2 += m * (m - 1) / 2; f3 += trip * (n - 6); f4 += quad; cout &lt;&lt; abs(f0 - f1 + f2 - f3 + f4 - f5); return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"BA Memory API 已开放","slug":"api-ba-memory","date":"2024-10-03T05:24:58.140Z","updated":"2024-10-03T05:25:00.896Z","comments":true,"path":"articles/3787/","link":"","permalink":"https://justpureh2o.cn/articles/3787/","excerpt":"","text":"访问 API 文档 以了解更多。","categories":[{"name":"API","slug":"API","permalink":"https://justpureh2o.cn/categories/API/"}],"tags":[{"name":"API","slug":"API","permalink":"https://justpureh2o.cn/tags/API/"}]},{"title":"图论 环计数问题","slug":"algorithm-ring-count","date":"2024-09-28T04:48:57.270Z","updated":"2024-10-04T04:53:55.467Z","comments":true,"path":"articles/21999/","link":"","permalink":"https://justpureh2o.cn/articles/21999/","excerpt":"","text":"环 顾名思义，环就是环 一般研究较多的是三元环和四元环计数。题目给定一张无向图，让你直接或间接地求图中有多少个不同的三元/四元环。形式化的，给定一张无向图，统计出满足要求的无序对 或 的个数，无序对需满足图中存在仅由点 或 组成的环。而且它还喜欢和容斥一起考（属实是出生到家了）。 三元环计数 对于三元环计数，我们有很好的算法可以解决，还能够顺带给出三元环的组成点分别是哪些。基本思路如下： 将所有边定向：统计每个点的度数，并让度数小的点指向度数大的点（原边基础上定向，不创建新边），若度数相同则编号小的点指向编号大的点。此时可以得到一张有向无环图 。 枚举每个点 的所有出点 ，并将 标记，再对 枚举其出点 ，检查 是否已被标记过，最终把 所有出点的标记清空。 其实听起来很暴力（尤其是第二步），但是它却能做到 的复杂度。太强辣 代码来自于：P1989 无向图三元环计数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;struct Edge { int to, ne;} edges[N &lt;&lt; 1];int h[N], idx = 0;int deg[N &lt;&lt; 1];bool st[N &lt;&lt; 1];int u[N &lt;&lt; 1], v[N &lt;&lt; 1];void add(int a, int b) { idx++; edges[idx].to = b; edges[idx].ne = h[a]; h[a] = idx;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; u[i] &gt;&gt; v[i]; deg[u[i]]++; deg[v[i]]++; } for (int i = 1; i &lt;= m; i++) { if ((deg[u[i]] == deg[v[i]] &amp;&amp; u[i] &gt; v[i]) || deg[u[i]] &gt; deg[v[i]]) swap(u[i], v[i]); add(u[i], v[i]); } int cnt = 0; for (int u = 1; u &lt;= n; u++) { for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; st[j] = true; } for (int i = h[u]; ~i; i = edges[i].ne) { int v = edges[i].to; for (int j = h[v]; ~j; j = edges[j].ne) { int w = edges[j].to; if (st[w]) cnt++; } } for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; st[j] = false; } } cout &lt;&lt; cnt &lt;&lt; endl; return 0;} 如果使用上面这种方法，千万不要忘记数组开二倍。 四元环计数 基本步骤如下： 为无向边定向，思路同三元环计数。 设定一个辅助计数数组 cnt，在有向图上枚举点 的出点 ，再在原本的无向图上枚举 的出点 ，当 的度数严格大于 的度数时，答案累加 cnt[w]，并把 cnt[w] 自增一，当前 枚举结束时把 cnt 清零。 例题 P9850 [ICPC2021 Nanjing R] Ancient Magic Circle in Teyvat 题目地址：P9850 题目难度：NOI/NOI+/CTSC 题目来源：ICPC 南京 2021 给定一个 个点的完全图，有 条边是红色的，其余边是蓝色的，求出边均为蓝色的大小为 的完全子图个数与边均为红色的大小为 的完全子图个数的差。 对所有数据满足，， 将蓝色子图容斥掉，接着分类讨论选择的边数即可。 题解同步于本站","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"P6669 - [清华集训2016] 组合数问题 题解","slug":"solution-p6669-combination-problem","date":"2024-09-28T04:29:22.486Z","updated":"2024-09-28T04:29:36.436Z","comments":true,"path":"articles/6669/","link":"","permalink":"https://justpureh2o.cn/articles/6669/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P6669 看到超大组合数对质数取模首先考虑朴素 定理，定理内容如下： 其中第一项可以继续递归。但是这里要涉及到 定理的另外一个意义——发现这个公式实质上是在对 进行 进制分解。整个组合数可以看作是将 转换为 进制后对位求组合数然后累乘得到的，即： 其中 为 在 进制下位数的最大值，若位数不够则将该位看作 。 如果一个数要是 的倍数，那么这个数模 的结果一定是 。根据 定理，在连乘过程中，必须至少出现一个零项，最终结果才会是 。根据组合数 在 时结果为 的性质，可知我们需要统计 进制下有多少 有至少一个位严格大于 ，此时同时对 数位 DP 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define N 62#define MOD 1000000007using namespace std;typedef long long ll;int numN[N], numM[N];ll f[N][2][2][2][2];int k;ll dfs(int pos, bool valid, bool limitN, bool limitM, bool limitI) {// 当前位 是否已合法 i顶到上界n j顶到上界m j顶到上界i if (pos &lt; 0) return valid; if (f[pos][valid][limitN][limitM][limitI] &gt;= 0) return f[pos][valid][limitN][limitM][limitI]; // 记忆化搜索 ll sum = 0; for (int i = 0; i &lt;= (limitN ? numN[pos] : k - 1); i++) { // 枚举 i 在这一位上填的数字 for (int j = 0; j &lt;= min((limitM ? numM[pos] : k - 1), (limitI ? i : k - 1)); j++) { // 枚举 j 在这一位上填的数字，注意需要满足 j 不超过 i 和 m 的最小值 sum = (sum + dfs(pos - 1, valid | (j &gt; i), limitN &amp; (i == numN[pos]), limitM &amp; (j == numM[pos]),limitI &amp; (i == j))) % MOD; } } f[pos][valid][limitN][limitM][limitI] = sum; return sum;}ll calc(ll n, ll m) { memset(numN, 0, sizeof numN); memset(numM, 0, sizeof numM); memset(f, -1, sizeof f); // 进制分解 int size1 = 0, size2 = 0; ll tmp1 = n, tmp2 = m; while (tmp1) { numN[size1++] = tmp1 % k; tmp1 /= k; } while (tmp2) { numM[size2++] = tmp2 % k; tmp2 /= k; } return dfs(max(size1, size2) - 1, false, true, true, true);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(f, -1, sizeof f); int t; cin &gt;&gt; t &gt;&gt; k; while (t--) { ll n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; calc(n, m) &lt;&lt; endl; } return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"数论补完计划 Part5 组合计数","slug":"algorithm-number-theory-part-v","date":"2024-09-25T00:06:19.146Z","updated":"2024-09-28T00:29:00.402Z","comments":true,"path":"articles/16521/","link":"","permalink":"https://justpureh2o.cn/articles/16521/","excerpt":"","text":"排列数与组合数 排列组合基础 对于一个正整数 ，它的阶乘等于 ，记作 。特殊地，。 小学时我们就知道，用 三个数字最多能表示出 个互不相同的三位数字；若改为 组成四位数，那么答案就该是 种。这其实就是排列数的一个经典应用。探究这个答案是怎么得到的——对于第一个位置，可以有 种填数方法；对于第二个位置，因为先前已经用掉一个数了，此时可选的数就只剩 个，根据分步乘法原理，就应该乘上 ，以此类推……我们会惊奇地发现答案其实就是 ，或者可以表示成 。 排列数 是指从 个物体中选出 个并进行排列的总方案数。公式为 。排列所隐含的意思是，选中的 个物品之间是存在顺序差别的。例如上例选数字， 和 显然是不相同的两个数字，因此需要用到排列数。这也是它和组合数最大的差别。 上了高中，我们又知道，从 个人中选出 个人组队，总共能有 种组队方案。答案是 吗？鉴于 一队和 一对是等价的，那么其实队内的排序是不必要的，考虑到两个人能变出 种排序，意味着同一个方案会出现两次，答案其实是 。 组合数 （或者用二项式表示法表示为 ）是指从 个物体里选出 个并进行组合的总方案数。公式为 。它和排列数一样，只要 均为正整数，那么结果也都是整数。特殊地，。组合蕴含的意思是，不考虑选中元素之间的顺序关系，正如选择 组成一组和选择 成一组是完全等价的。 记不住组合数公式的看这张图： 还有特殊情况，例如 ，当 且 时，我们规定计算结果是 。 一个重要的恒等式是：。可以套公式验证。 排列组合扩展 比如说二项式定理，这个非常的好用，尤其是当你需要计算 的时候。二项式定理说道，对于 的展开形式，我们可以通过公式： 来快捷得到。注意 从 开始。 时我们很熟悉，完全平方展开，系数分别是 ； 还好，系数为 ； 时就是 。很容易发现这个系数似乎关于中间那一项左右对称，这一点可以用恒等式 完美解释。 跟二项式定理密切联系的还有一个杨辉三角，它长这个样子： 发现所有的二项式系数都可以在对应行找到。因此可以说，杨辉三角第 行的第 个数其实就对应组合数 。再次仔细观察，可以发现当前的数字可以由它肩上的两个数字相加得到，例如 ，于是所有的组合数都可以由这个递推式得到：。 杨辉三角还有许多有趣的性质，例如将第 行的所有二项式系数加起来能得到 ，要证明也很简单，利用二项式定理代入特值 ，这样就会得到 。还有，你还可以从第 行开始，将杨辉三角中的数按特定规则相加，就可以得到斐波那契数列的项，见下图： 即 。可以在了解组合数递推公式的基础上理解这个规律。 Lucas 定理 用于组合数取模问题，公式其实很简洁： 其中 为质数（暗示扩展），除法为整除。而当 时，第一项可以通过递归这个公式得到。 如果考虑递归，我们其实发现它和 进制分解蛮像。事实上， 定理就可以看作是 在 进制下进行对位求组合数的结果之积。也就是说，假如 的 进制表示分别为 和 （不存在对应为则为 ），那么 。证明略（不会）。它经常和数位DP放在一起考。 虽然它简化了计算，但是它本质上还是需要计算组合数的值。因此需要维护模意义下的阶乘和阶乘的逆元，或者你还可以暴力求解，适用于模数易变的情况。 1234567891011121314// 暴力求解组合数int C(int n, int m, int p) { int res = 1; for (int i = 1, j = n; i &lt;= m; i++, j--) { res = ((ll) res % p * j % p * inv(i, p) % p) % p; } return res;}int lucas(int n, int m, int p) { if (m &gt; n) return 0; // 必须特判，否则 RE+WA if (n &lt; p &amp;&amp; m &lt; p) return C(n, m, p) % p; return (lucas(n / p, m / p, p) % p * lucas(n % p, m % p, p) % p) % p;} 1234567891011121314// 预处理int lucas(int n, int m, int p) { if (n &lt; m) return 0; // 必须特判 if (n &lt; p &amp;&amp; m &lt; p) return (fac[n] % p * infac[m] % p * infac[n - m] % p) % p; return (lucas(n / p, m / p, p) % p * lucas(n % p, m % p, p) % p) % p;}void init(int lim) { fac[0] = infac[0] = 1; for (int i = 1; i &lt;= lim; i++) { fac[i] = (fac[i - 1] * i % p) % p; infac[i] = (infac[i - 1] * inv(i, p) % p) % p; }} 无论你选用哪一种，都不要忘了对特殊情况的特判，例如 的答案应为 。 扩展 Lucas 定理 回收伏笔 既然 定理只适用于 为质数，何不把模数 拆成质数呢？根据算术基本定理，这是可以做到的，假设最终分解为 。我们把代求的组合数当作一个未知数 ，联立可以得到方程组： 发现可以使用朴素的中国剩余定理合并（不同质数之间显然互质），前提是我们得知道 的值。 根据组合数的阶乘定义式得到：。但是还不能直接算，万一逆元不存在（ 或 ）怎么办？既然导致无解的原因是出现了 的倍数，那么我们就把 因子拆除了！设 分别为 中 因子的个数，那么原问题可以变为求解： 此时因为除去了因子 ，逆元就可以放心求解了。此时还面临一个问题，即形如 的算式的快速求解。分母可以用逆元求，其实时间复杂度瓶颈还是在阶乘取模上，因此只需要解决 即可。我们从一个实例来感受如何求解： 例 3.1 求解 的值 即 。我们先写阶乘，再把 的倍数提出来： 发现原式分为三个部分： 的 次幂、 的阶乘和与 互质的数的乘积。对于第二部分，由于可能仍然存在 的倍数，故递归求解；对于第三部分，有一个很好的性质——把互质的数按 个一组分下去（余下的另算），发现每个完整组的乘积模 的值是相同的，故快速幂解决，最后暴力乘上剩下的即可。 假设每一个完整组的乘积模 的值均为 ，剩余组模出来的值为 ，那么可以得到： 递归的下一层就是求解 的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; Equation;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y) { if (!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d;}ll inv(ll a, ll p) { ll ans, tmp; exgcd(a, p, ans, tmp); return (ans % p + p) % p;}ll qmul(ll a, ll b, ll p) { ll res = 0; while (b) { if (b &amp; 1) res = (res + a) % p; a = (a + a) % p; b &gt;&gt;= 1; } return res % p;}ll qpow(ll a, ll b, ll p) { ll res = 1; while (b) { if (b &amp; 1) res = (res % p * a % p) % p; a = (a * a) % p; b &gt;&gt;= 1; } return res % p;}ll mul(initializer_list&lt;ll&gt; args, ll p) { // 很方便的变长参数列表求连乘，int128 防止爆范围 __int128 res = 1; for (ll i: args) { res = (res % p * i % p) % p; } return (ll) (res % p);}ll CRT(vector&lt;Equation&gt; &amp;v) { // 中国剩余定理部分 ll M = 1; ll res = 0; for (Equation eq: v) M *= eq.second; for (Equation i: v) { ll Mi = M / i.second; res = (res + qmul(qmul(i.first, Mi, M), inv(Mi, i.second), M)) % M; } return res % M;}ll resolve(ll a, ll p, ll ppow) { // 递归过程求解，即实现例3.1 if (!a) return 1; // 1的阶乘模质数当然无论如何都是1 ll s = 1; for (ll i = 1; i &lt;= ppow; i++) { if (i % p) s = mul({s, i}, ppow); // 完整组循环节连乘 } s = qpow(s, a / ppow, ppow); // 对完整组的积求幂 for (ll i = a / ppow * ppow + 1; i &lt;= a; i++) { if (i % p) s = mul({s, i}, ppow); // 对不完整组求积 } return mul({s, resolve(a / p, p, ppow)}, ppow); // 递归过程}ll getA(ll n, ll m, ll p, ll ppow) { // 获取 CRT 方程组中的 a ll x = 0, y = 0, z = 0; // 统计 n, m, n - m 分别是 p 的多少次幂 for (ll i = n; i; i /= p) x += i / p; for (ll i = m; i; i /= p) y += i / p; for (ll i = n - m; i; i /= p) z += i / p; // 套公式 return mul({ qpow(p, x - y - z, ppow), resolve(n, p, ppow), inv(resolve(m, p, ppow), ppow), inv(resolve(n - m, p, ppow), ppow) }, ppow);}ll exLucas(ll n, ll m, ll p) { // 分解质因数 vector&lt;Equation&gt; E; for (ll i = 2; i * i &lt;= p; i++) { if (p % i == 0) { // 统计对应质数以及它的幂 ll c = 1; while (p % i == 0) { c *= i; p /= i; } E.emplace_back(getA(n, m, i, c), c); } } if (p &gt; 1) E.emplace_back(getA(n, m, p, p), p); // 最后一个质数 return CRT(E);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); ll n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; exLucas(n, m, p) &lt;&lt; endl; return 0;} 其中 getA(n, m, p, ppow) 用来求解 ，即中国剩余定理中的 ； resolve(a, p, ppow) 实现求解 。 Lucas 定理的实际应用 鉴于 定理在进制分解上的性质，它其实可以跟一些涉及到进制的算法放在一起考。例如数位DP，数位DP相关内容请见：记忆化搜索 数位DP。 洛谷 P7976 [Stoi2033] 园游会 题目地址：P7976 题目难度：提高+/省选- 设 ，给定 ，求： 对 取模。 对于 的数据，。 根据 定理，我们知道 。那怎么把这个用到函数 上呢？我们可以发现， 满足 ，即积性函数。 我们把 转为三进制，那么此时求 就可以通过按位算组合数并连乘得到。固定一个 ，此时对于 的每一位，有几种可能： ，保证 的情况下，，此时贡献为 ， 只能枚举 ，贡献为 ，此时 ，贡献为 因此，真正能对答案产生实质性贡献的就是 的情况。换句话说，当 在 内枚举时，我们只需要统计 取不同值时（三进制下） 位的个数即可，也就是标准的数位DP求解 内数在三进制下总共有多少个 。记结果为 ，那么答案就是 。 洛谷 P6669/BZOJ 4737 [清华集训2016] 组合数问题 题目地址：P6669 题目难度：省选/NOI- 题目来源：清华集训 2016 给定 和 ，对于所有的 有多少对 满足 是 的倍数。答案对 取模。 对于 的测试点， ，，且 是一个质数。 读题，倍数必定满足关系 。根据 定理的基数对位组合求积意义，我们可以把 都转成 进制，并且，只要在连乘式中出现任意一个及以上的 项，整个结果就是 ，也即 的倍数。根据组合数的计算公式，发现只要 满足 ，那么结果就是 。 布尔型维护当前是否已经存在 项。此时考虑同时填两个不同数的相同位置，也就是一次性填 两个数，自然需要用到双层循环。鉴于题目要求 ，我们不仅需要维护 是否顶到上界 ，还要额外维护 是否顶到上界 和上界 。总的状态数是 ，转移是双层循环的 ，时间复杂度约为 ，完全足够。 题解同步于本站","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"数论补完计划 Part4 中国剩余定理","slug":"algorithm-number-theory-iv","date":"2024-09-18T05:04:03.506Z","updated":"2024-09-24T23:00:34.509Z","comments":true,"path":"articles/29256/","link":"","permalink":"https://justpureh2o.cn/articles/29256/","excerpt":"","text":"中国剩余定理 《孙子算经》有云： 今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？ 大意为：有 个物品，满足如下线性同余方程组： 刚入坑编程的估计在“循环结构”那一章里就写过求解这个方程的枚举代码了。这种方式不好的一点就是码量随方程数的增多而膨胀（但是你可以写一个生成计算代码的程序，然后运行编译后的程序）。我们急需一种通解，在码量不增的情况下实现对这个方程组的求解。 我们考虑拆开这个方程组，分别令 满足： 两个方程组的写法其实是等价的，只是把同余转化为了带余除法罢了。我们惊奇地发现，如果再加上几个约束条件，原方程组的解 就可以经过 表示出来： 此时 ，因为 ，其他同理。 而我们的中国剩余定理断言道，对于模数均互质的 元线性同余方程组： 它的解 ，其中 。因此只需要计算同余号右侧的部分即可，由于方程组模数互质并不等于每个方程的模数是质数，因此需要用到扩展欧几里得算法来求解逆元。 1234567891011121314151617181920212223242526272829int n;ll m[N], a[N];ll M = 1;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y) { if (!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d;}ll inv(ll x, ll p) { ll ans, tmp; exgcd(x, p, ans, tmp); return (ans % p + p) % p;}ll CRT() { ll res = 0; for (int i = 1; i &lt;= n; i++) M *= m[i]; for (int i = 1; i &lt;= n; i++) { ll Mi = M / m[i]; res += a[i] * Mi * inv(Mi, m[i]); } return res % M;} 扩展中国剩余定理 经历过数论大风大浪的应该都知道，马上要开始推导模数不全互质的情况了。 还是那个方程组： 此时不保证 两两互质，求出方程的最小正整数解。此时因为失去了互质，构造通解的方式已经不能用了。因此我们转而寻找另外的方法来简化这个方程组。 对大量事实的观测表明，两个线性同余方程在合并后遵循如下性质： 模数变为原两个方程模数的最小公倍数 合并得到的方程与原方程同型 合并得到的方程不一定有解 也即： 事实上，假设我们有方程 和 。那么转化成带余方程之后就有： 观察到这是二元一次不定方程 的形式，根据贝祖定理，有解的充要条件是 ，因此无解情况就可以筛去了。 约去最大公倍数得：。用扩展欧几里得解出方程 的特解 ，那么 可以用如下关系得到： 于是 。用 去代结果是一样的。 那么对于方程 仅当 时有整数解 。那么方程的通解可以表示成 的形式，这样就能解释合并后方程的模数为什么为最小公倍数了。 我们假设 ，并假设存在关系： 做差可得： 得到关系 。注意到两个数的最小公倍数一定满足 。但是对于非负整数 来说， 是一定成立的，且在 时取得等号，那么当且仅当在 时才存在最小公倍数的整除关系。因此导出式是一定正确的。 总结一下，对于方程组： 有解的充要条件是 。若已知有解，假设二元一次不定方程 的特解是 ，并记 ，那么原方程等价于： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;typedef long long ll;struct Equation { ll a, m;};ll a[N], b[N];stack &lt;Equation&gt; stk;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y) { // 扩展欧几里得过程，求解特解 t1 和 t2 if (!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d;}ll mul(ll a, ll b, ll p) { // 著名的龟速乘，就是把快速幂中的乘号改成加号，用来在不爆范围的情况下计算乘积取模的结果 ll res = 0; bool flag = (b &lt; 0) ^ (a &lt; 0); // 处理负数情况，同号相乘为正，异号为负 a = abs(a) % p; b = abs(b) % p; // 注意到：a * (-b) = -(a * b)，数字按绝对值相乘，负号最后处理 while (b) { if (b &amp; 1) res = (res + a) % p; a = (a + a) % p; b &gt;&gt;= 1; } return res * (flag ? -1 : 1) % p; // 处理负号}ll exCRT() { while (stk.size() &gt; 1) { // 不断合并方程直至剩下最后一个 Equation cur = stk.top(); stk.pop(); Equation nxt = stk.top(); stk.pop(); ll t1, t2; ll D = gcd(cur.m, nxt.m); ll S = lcm(cur.m, nxt.m); if ((nxt.a - cur.a) % D != 0) return -1; // 无解判断 exgcd(cur.m, nxt.m, t1, t2); // 求解特解 ll X = ((mul(mul(cur.m, t1, S), (nxt.a - cur.a) / D, S)) + cur.a) % S; stk.push((Equation) {X, S}); } Equation res = stk.top(); return (res.a % res.m + res.m) % res.m; // 转为正整数}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i]; for (int i = 1; i &lt;= n; i++) stk.push((Equation) {b[i], a[i]}); cout &lt;&lt; exCRT() &lt;&lt; endl; return 0;}","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"数论补完计划 Part3 欧拉函数","slug":"algorithm-number-theory-iii","date":"2024-09-17T22:47:08.015Z","updated":"2024-09-18T04:57:52.107Z","comments":true,"path":"articles/37074/","link":"","permalink":"https://justpureh2o.cn/articles/37074/","excerpt":"","text":"欧拉函数 欧拉函数 ，表示 内与 互质的数的个数。对于质数 显然有 。特殊地，。欧拉函数是一个积性函数，对任意互质的数 ，都有 。不互质时，如果 为奇数，那么有 。 如果 可以用算术基本定理分解成 的形式，那么 。注意，若 可以被同一个质数反复除尽，即存在一个 和 使得 ，计算时同样只对这个质数计算一次贡献。 证明： 正难则反，考虑用 内的所有数的个数减去不互质的数的个数。 因为每个大于 的自然数都可以分解为若干质数之积，因此我们只需要考虑小于等于 的所有质因子，这一步类似于埃氏筛的想法。那么能被 整除的数就有 个，进而，得到第一个式子： 但是有一个小问题——如果 或诸如此类的数，那么在计算贡献时会被 和 同时计入，显然结果小于正确答案。此时我们就需要引入“容斥原理”来帮我们解决这个问题了。来看一个例子（小学奥数题）： 假设被 整除的数分别构成三个集合 ，那么我们在用 计算结果时（ 记号表示集合元素个数），两个集合间的交集部分总共会被计入两次，最中间三个集合的交集总共会被计入三次，而我们希望的是每个部分只计一次。此时可以用上边算出的和减去两两集合之间的交集，那么最中间又会被减去三次，因而最终再加上一次中间部分，就得到了正确答案。也就是说本例的结果为： 特别的，形如上例问题的结果可以用以下公式算出： 因此我们在欧拉函数的计算中，也可以引入容斥原理。我们需要加上能被任意两个不同质数之积整除的数的个数，再减去能同时被三个不同质数之积整除的，以此类推。最终经过一些奇妙的化简（或者根本就是猜了一个结果然后拆括号检验的，正难则反懂不懂），得到如下计算公式： 代码实现时，通常把 等价变形为 ，然后先除后乘，以保证整除。 1234567891011int eular(int x) { int res = x; for (int i = 2; i * i &lt;= x; i++) { if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) x /= i; } } if (x &gt; 1) res = res / x * (x - 1); return res;} 欧拉函数的递推 本质是在筛质数的过程中顺便维护一定区间内的数的欧拉函数值，这就需要用到欧拉函数作为积性函数的性质了。 线性筛/埃氏筛在筛质数的过程中，有一步是标记掉质数的所有倍数，根据算术基本定理，所有合数都可以被如此标记掉。假如当前在筛 ，大部分情况下 是可以保证的，此时 。在这两种质数筛中，有一个特殊情况是 ，此时 。总的时间复杂度是线性的。 12345678910111213141516171819202122int phi[N], primes[N];bool st[N];int idx = 0;void sieve(int lim) { phi[1] = 1; for (int i = 2; i &lt;= lim; i++) { if (!st[i]) { primes[++idx] = i; phi[i] = i - 1; } st[i] = true; for (int j = 1; i * primes[j] &lt;= lim; j++) { phi[i * primes[j]] = phi[i] * (primes[j] - 1); st[i * primes[j]] = true; if (i % primes[j] == 0) { phi[i * primes[j]] = phi[i] * primes[j]; break; } } }} 欧拉函数的实例 一个排列整齐的点阵，请问从某个角看去，视野内总共有多少个点？（不包括自己） 观察可得，图是有对称性的。那么沿对角线划分成上下两个对称的部分，对于两个点 和 ，显然当 互质且 互质时才能为答案贡献 。因此只需求互质对的数目即可，答案就是 。","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"P10315 [SHUPC 2024] - 原神，启动！ 题解","slug":"solution-p10315-genshin-startup","date":"2024-09-17T22:38:27.468Z","updated":"2024-09-17T22:38:29.022Z","comments":true,"path":"articles/10315/","link":"","permalink":"https://justpureh2o.cn/articles/10315/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目原型谜题解法浅究（ 的情况） 题目地址 本题考察模意义下的高斯消元。 基本思路是，让 号方块分别击打 次，使得最终每个方块都朝向位置 。 欲解决此题，首先需要为每个位置编号。定义 为“击打 方块后， 均会旋转一次”。那么样例输入 #1 如下图（编号方式不唯一），红线为目标方向、初始时均在 朝向： 假设三个方块需要击打 次，那么可以列出以下方程组： 但是不够严谨，因为我们没考虑“转过头”这种情况。即朝向为 的方块旋转后会变为朝向 。因此可以发现朝向存在模 意义的同余关系。 上例方程组解得： 出现了负数，怎么处理？ 根据解的意义考虑，这相当于 往回转一次，根据同余关系可以得到，往回转 次就相当于向前转 次。因此对于负数，采取 (x % m + m) % m 的方式即可转化为非负数。 于是题目就很明了了，让我们求出如下 元一次同余方程组的解： 因而可以用高斯消元求解。那么如何处理无数组解的情况呢？ 高斯消元时我们会跳过一些零行。此时零行对应的变量就是一个自由元，可以任意赋值。 因此使用一个 ans 数组来存储答案，如果出现无数组解的情况，那么不管它，ans 数组也会自动赋值它为 。 模意义下的除法显然需要用逆元解决，考虑到 为质数，因此使用费马小定理计算。注意处处取模，答案不要忘了转化为 内的数，还要开 long long。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;#define N 110#define SOLVE_OK 200#define SOLVE_NO 404#define LUXURIOUS_CHEST 0;#define F returnusing namespace std;typedef long long ll;int n, m;ll matrix[N][N];ll ans[N];ll qpow(ll a, ll b, int p) { ll res = 1; while (b) { if (b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res % p;}ll inv(ll x, int p) { return qpow(x, p - 2, p);}int gauss() { // 1-index 高斯消元 int rank = 0; for (int c = 1, r = 1; c &lt;= n; c++) { int max_row = r; for (int i = r; i &lt;= n; i++) { if (abs(matrix[i][c]) &gt; abs(matrix[max_row][c])) { max_row = i; } } if (!matrix[max_row][c]) continue; if (max_row != r) swap(matrix[max_row], matrix[r]); for (int i = n + 1; i &gt;= c; i--) { matrix[r][i] *= inv(matrix[r][c], m); matrix[r][i] = (matrix[r][i] % m + m) % m; } for (int i = r + 1; i &lt;= n; i++) { if (abs(matrix[i][c])) { for (int j = n + 1; j &gt;= c; j--) { matrix[i][j] -= (matrix[r][j] * matrix[i][c]); matrix[i][j] = (matrix[i][j] % m + m) % m; } } } r++; rank++; } if (rank &lt; n) { // 无解判断 for (int i = rank + 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) { if (abs(matrix[i][j])) return SOLVE_NO; } } // 无穷解处理，无穷解算作有解 for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (abs(matrix[i][j])) { ans[j] = matrix[i][n + 1]; break; } } } return SOLVE_OK; } // 有唯一解，回代 for (int i = n; i &gt;= 1; i--) { for (int j = i + 1; j &lt;= n; j++) { matrix[i][n + 1] -= (matrix[i][j] * matrix[j][n + 1]); matrix[i][n + 1] = (matrix[i][n + 1] % m + m) % m; } } for (int i = 1; i &lt;= n; i++) ans[i] = matrix[i][n + 1]; return SOLVE_OK;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) matrix[i][i] = 1; // 每个方块被击打后自己也会转一下，因此主对角线全为 1 for (int i = 1; i &lt;= n; i++) { int k; cin &gt;&gt; k; for (int j = 1; j &lt;= k; j++) { int x; cin &gt;&gt; x; matrix[x][i] = 1; } } for (int i = 1; i &lt;= n; i++) { ll s; cin &gt;&gt; s; matrix[i][n + 1] -= s; } for (int i = 1; i &lt;= n; i++) { ll t; cin &gt;&gt; t; matrix[i][n + 1] += t; } int res = gauss(); if (res == SOLVE_OK) { for (int i = 1; i &lt;= n; i++) cout &lt;&lt; (ans[i] % m + m) % m &lt;&lt; ' '; } else cout &lt;&lt; \"niuza\" &lt;&lt; endl; F LUXURIOUS_CHEST}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"数论补完计划 Part2 欧几里得算法","slug":"algorithm-number-theory-ii","date":"2024-09-15T05:48:13.086Z","updated":"2024-09-15T05:48:13.205Z","comments":true,"path":"articles/47621/","link":"","permalink":"https://justpureh2o.cn/articles/47621/","excerpt":"","text":"欧几里得算法 众所周知的是，欧几里得算法可以用来求解最大公约数。它的核心是一个恒等式 ，并且在 时函数值是 。C++14 标准提供一个函数 __gcd() 来求解最大公约数，而在 C++17 以后，我们可以使用 gcd() 和 lcm() 函数来求解两个数的最大公约数和最小公倍数。 通常我们采用递归版本： 123int gcd(int a, int b) { return b ? gcd(b, a % b) : a;} 当然，C++ 标准使用的是循环版本： 12345678int gcd(int a, int b) { while (b) { int t = a % b; a = b; b = t; } return a;} 扩展欧几里得算法 今天的重头戏是我们的扩展欧几里得算法（简称“扩欧”）。它和一般的朴素-扩展定理不太一样，按照常理，应该是一个针对互质（朴素）、一个针对不互质（扩展）。但是欧几里得算法并不存在互质和不互质的差别，因而也就没有这样的区分。扩展欧几里得算法能够在求解最大公约数的基础上连带求出不定方程 的特解，也算是在功能方面上的一种“扩展”吧。 贝祖定理 也就是 定理，它表述为： 对于任意不全为零的整数 ，总存在整数 ，使得 成立 我们可以利用这个定理来判断不定方程解的情况。 证明： 当 其一为 时，显然成立。 当 均不为 时，有一个结论是 。那么问题可以收缩到只考虑 同为正数时的情况了。接下来我们借用欧几里得算法的思路，即执行 直到 。假设初始参数为 ，并把欧几里得算法变为带余数的除法： 退出时 ，则 ，继续向上回代，最终得到 。两边同乘 得到原式。 因此在方程 中，如果 ，那么是铁定无解的。 扩展欧几里得 假如我们拿到一个方程 ，并且已知它是有解的。我们一定可以把它化简成 的形式。根据欧几里得证明的最大公约数的等价变换，可以得到： 把取模换成带余除法， 就等价于 ，那么原式变为： 即， 发现这个式子和最开始的那个是同型的。也就是说我们每次递归的时候都需要把 减去 然后代入计算。递归终点和朴素欧几里得算法相同，在 时，原式为 ，可以返回特解 。注意传参时需要将 反着传入。 借助 C++ 的引用特性，可以在每次递归时计算。 123456789int exgcd(int a, int b, int &amp;x, int &amp;y) { if (!b) { y = 0, x = 1; return a; } int d = exgcd(b, a % b, y, x); y -= (a / b) * x; return d;} 不定方程的通解 我们都知道，通过扩展欧几里得算法求出的 是一组特解，而不定方程是可能存在无数组解的。我们需要找到这些解之间的规律，从而更加方便快捷地导出具有某些特殊性质的解来。 对于一个二元一次不定方程的基本式 ，显然有解。对于一般情况 ，满足 时才有解。一般式其实可以由基本式推导而来：。 一组特解为 ，根据上边的推导式，可以得到： 也因此， 是成立的。假设有一个有理数 ，显然下面的式子是成立的（拆开括号后会消去）： 我们一般只考虑整数解，所以需要保证 。显然当 时是可行的，方程的整数通解就可以通过如下形式导出： 题目中还会给你一些限制条件，例如 的最大/小正整数解分别是多少。此时需要进一步推导。 假如限制条件是， 均为正整数。那么有如下不等式组： 解得： 因为 为整数，放缩得： 当右边严格小于左边时，无解，即没有 同为正整数的解。否则，注意到 与 成正关系， 与 成负关系。 的最大可能整数值就由 的上界代入得出， 的最大可能整数值是 的下界对应的值，反之亦然。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y) { if (!b) { x = 1, y = 0; return a; } ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { ll a, b, c, x, y; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (c % gcd(a, b) == 0) { ll gcd = exgcd(a, b, x, y); x *= c / gcd, y *= c / gcd; // 转化为推导式 ll low = ceil((1.0 - x) * gcd / b); // 算下界，浮点数1.0是必须的 ll up = floor((y - 1.0) * gcd / a); // 上界 if (up &lt; low) { cout &lt;&lt; (x + low * b / gcd) &lt;&lt; ' ' &lt;&lt; (y - up * a / gcd) &lt;&lt; endl; // x,y 最小值 } else { cout &lt;&lt; up - low + 1 &lt;&lt; ' '; // 区间大小 cout &lt;&lt; (x + low * b / gcd) &lt;&lt; ' ' &lt;&lt; (y - up * a / gcd) &lt;&lt; ' '; // x,y 最小值 cout &lt;&lt; (x + up * b / gcd) &lt;&lt; ' ' &lt;&lt; (y - low * a / gcd) &lt;&lt; endl;// x,y 最大值 } } else cout &lt;&lt; -1 &lt;&lt; endl; } return 0;} 乘法逆元 乘法逆元其实就是模意义下的倒数，因为取模是针对整数而言的，而实数域的倒数可能不是一个整数，所以引入一个乘法逆元的概念。定义线性同余方程 的解 为 在模 意义下的乘法逆元，记作 。 根据定义，我们其实就可以直接开始用扩展欧几里得计算了。特殊情况下，当 为质数时，由费马小定理得到 ，进而得 ，因此当 为质数时，逆元就是 的值，可以用快速幂解决（如果 特别大可以考虑十进制快速幂）。 根据带余除法，我们把同余方程变成这样：。有解的条件就是 ，只要 是 的倍数（包括 ），那么就不存在逆元。所以我们直接把 和 代入即可计算出逆元的值。注意解出的 可能为负数，那么就需要用 (x % MOD + MOD) % MOD 来将它转化为非负数。 调用 exgcd(a, p, x, y) 所得 即为逆元的值。","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"数论补完计划 Part1 基本定理、质数与约数","slug":"algorithm-number-theory-i","date":"2024-09-13T22:47:25.492Z","updated":"2024-09-13T22:47:27.613Z","comments":true,"path":"articles/39984/","link":"","permalink":"https://justpureh2o.cn/articles/39984/","excerpt":"","text":"基本定理 算术基本定理 任何一个合数均可被唯一分解成若干质数的乘积。 也就是说任何合数都可以唯一地表示成 的形式，这条定理在之后的质数筛中有大用。 素数定理 中的质数个数约等于 可以用来粗略估计在当前数据范围下质数的个数，以便更具有针对性的选用质数筛法。据说这个定理有一个非常初等的证明，仅涉及到极限、自然对数函数和指数函数的一些简单性质（子供向），非常适合初中生茶余饭后作为谈资。 费马小定理 对于一个质数 ，以及一个正整数 。如果 不是 的倍数，那么 它是质数模数逆元求解的理论基础，在大部分情况下，它还可以拿来检验一个数是否是质数（有特例，例如 ）。 欧拉定理 若 ，那么 其中 为欧拉函数，代表 内与 互质的数的个数。当 为质数时满足 ，不难发现费马小定理是欧拉定理在 为质数时的特殊情况。 威尔逊定理 对于任意质数 ，满足 上式还等价于 。可以用作质数检验，但是要算阶乘，开销方面还不如试除法。 质数 我们定义，如果一个大于一的自然数 不包含 和 外的其他约数，那么 是一个质数，反之即为合数。特别地， 既不是质数，也不是合数。 在保证正确的情况下，最快的质数判断法是 的试除法。如果我想要一次性找出 内的所有质数该怎么办呢？此时就需要质数筛了。 埃氏筛 由古希腊数学家埃拉托斯特尼发明的质数筛法。它首先找到一个质数 ，然后在 内枚举它的倍数并标记为合数，然后循环往复得到所有范围内的质数。 这个算法的核心就是算术基本定理，任何质数都可以被分解为若干质数的乘积，因此只要对质数的倍数进行筛选，就一定能保证正确性。 线性筛 它断言每个合数只会被它最小的质因子筛掉，因此我们只需要筛去以当前质数为最小质因子的合数即可。 123456789void get(int n) { for (int i = 2; i &lt;= n; i++) { if (!vis[i]) prime[cnt++] = j; for (int j = 1; prime[j] &lt;= n / i; j++) { vis[prime[j] * i] = true; if (i % prime[j] == 0) break; // 不再是最小质因子了，跳出 } }} 常数筛/直取筛 顾名思义，就是 的打表。虽然这听起来非常的荒谬，但是有些时候还是可以用上的。它结合了上述的任何一种筛法，以及一个字符串格式化输出系统。代码实现很基础，不放了😎。 约数 也叫因数，当 能被 整除时，即 时，就称 是 的一个因数。 求约数仍然是试除法，需要注意的是当前数是否是一个完全平方数，以防止重复记录约数 。 最大公约数 欧几里得算法/辗转相除法用来求解两个数的最大公约数。它的核心是 的递归式，终点是 ，此时 为所求。C++ 内置的 __gcd() 函数可以做到这一点（两个下划线）。 最小公倍数 小学时讲过这样一个性质，最大公约数和最小公倍数的乘积等于两数之积。因此直接根据公式导出即可。","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"记忆化搜索 数位DP","slug":"algorithm-digital-dp","date":"2024-09-04T04:16:09.758Z","updated":"2024-09-13T03:58:59.397Z","comments":true,"path":"articles/3140/","link":"","permalink":"https://justpureh2o.cn/articles/3140/","excerpt":"","text":"数位DP 简介 数位DP是一种基于按位枚举的计数类DP。一般来说，当题目要求对所有符合特殊性质的数字计数（且这些性质可以转化到数位上讨论）、对给定区间内的合法数做统计、数据范围中出现了超大的上界时，就可以考虑使用数位DP来进行求解。 数位DP的时间复杂度基本上是 级别的，其中 为状态数，可以看作是记忆化搜索数组每一维上界的总乘积。因此在大多数情况下它能做得很好。 数位DP 基本实现 数位DP运用了前缀和的思想，假设代求区间为 ，它的基本思路是求出 内的方案数，再求出 内的方案数，答案就是后者减去前者。 其次，数位DP还支持搜索记忆化。具体来说就是把搜索时的传参记录下来，方便后期调用。由于不同数的上界（或枚举到的前导零）状态不甚相同，故当前数较为特殊时（顶上界/存在前导零）不进行记忆化。 基本模板如下（代码来自 P2657 windy 数）： 12345678910111213int dfs(int pos, int pre, bool limit, bool zero) { // 当前位置 上一个数 是否顶上界 是否有前导零 int sum = 0; if (pos &lt; 0) return 1; // 当前符合要求，是一种合法解 if (!limit &amp;&amp; pre &gt;= 0 &amp;&amp; f[pos][pre] != -1) return f[pos][pre]; // 记忆化剪枝 for (int i = 0; i &lt;= (limit ? num[pos] : 9); i++) { // 顶上界就只能最大枚举到上界当前位的数 if (abs(i - pre) &lt; 2) continue; // 判断合法性 if (!i &amp;&amp; zero) sum += dfs(pos - 1, -2, limit &amp;&amp; i == num[pos], true); // 当前是前导零 else sum += dfs(pos - 1, i, limit &amp;&amp; i == num[pos], false); // 不为前导零 } if (!limit &amp;&amp; !zero) f[pos][pre] = sum; // 加入记忆化 return sum;} 注意到程序的整体复杂度与记忆化数组的维度有关，因此把无用的参数尽可能省去会提高运行效率（因题而异，但基本上都是省去判断前导零和前一个数的状态） 数位DP 经典例题 例题按照难度升序排序。 受限于篇幅，仅在第一题给出完整代码，其余题目只会给出部分核心代码 洛谷 P1708 [入门赛 #21] 星云 hard ver. 题目地址：P1708 题目难度：普及/提高- 定义星云数为位数不大于 且各数位之和不超过 的正整数，给定 ，求星云数的个数。 共 组测试数据 对于 的数据，，，。 当时比赛时没想出来该怎么搞，下来发现原来正解是打表吗？？？不，肯定不是，这道题就是数位DP！建议升绿。 考虑到 都很小，打表确实可行。但是既然这道题给你说的都这么明显了，那咱们就用数位DP来做。 题目转化成，求 内符合要求的数的数量。因此记忆化搜索维护一个当前的数位和，在搜索终点时判断是否小于等于 ，或者途中判断，都是可行的。注意到数的前导零不会产生影响、也无需记录上一步选择的数字，我们可以把记忆化压缩至三维的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define N 10#define K 110using namespace std;typedef long long ll;int f[N][K];vector&lt;int&gt; num;int k;int power10[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000};int dfs(int pos, bool limit, int tot) { if (pos &lt; 0) return tot &gt; 0 &amp;&amp; tot &lt;= k; if (tot &gt; k) return 0; if (!limit &amp;&amp; f[pos][tot] &gt;= 0) return f[pos][tot]; int sum = 0; for (int i = 0; i &lt;= (limit ? num[pos] : 9); i++) { sum += dfs(pos - 1, limit &amp; (i == num[pos]), tot + i); } if (!limit) f[pos][tot] = sum; return sum;}int calc(int x) { num.clear(); int tmp = x; while (tmp) { num.push_back(tmp % 10); tmp /= 10; } memset(f, -1, sizeof f); return dfs(num.size() - 1, true, 0);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n &gt;&gt; k; cout &lt;&lt; calc(power10[n] - 1) &lt;&lt; endl; } return 0;} 洛谷 P2602 [ZJOI2010] 数字计数 题目地址：P2657 题目难度：普及+/提高 给定两个正整数 和 ，求在 中的所有整数中，每个数码(digit)各出现了多少次。 对于 的数据，保证 。 考虑对于每一次记忆化搜索，只搜索 内其中某个数的出现次数。因此在整个范围内搜索 次并分别输出答案即可。由于前导零不能算作 的出现次数，因此需要加入前导零的判断。 123456789101112ll dfs(int pos, int pre, bool limit, bool zero, int cnt, int target) { // 位置 上一个数 顶上界 前导零 出现次数 搜索目标 if (pos &lt; 0) return cnt; if (!limit &amp;&amp; !zero &amp;&amp; f[pos][pre][cnt][target] &gt;= 0) return f[pos][pre][cnt][target]; ll sum = 0; for (int i = 0; i &lt;= (limit ? num[pos] : 9); i++) { if (!i &amp;&amp; zero) sum += dfs(pos - 1, i, limit &amp; (i == num[pos]), true, 0, target); else sum += dfs(pos - 1, i, limit &amp; (i == num[pos]), false, cnt + (i == target), target); } if (!limit &amp;&amp; !zero) f[pos][pre][cnt][target] = sum; return sum;} 其实不用记录上一个数也是没问题的，因为历史遗留问题没删罢了。 洛谷 P2657 [SCOI2009] windy 数 题目地址：P2657 题目难度：提高+/省选- 题目来源：四川 2009 各省省选 不含前导零且相邻两个数字之差至少为 的正整数被称为 windy 数。windy 想知道，在 和 之间，包括 和 ，总共有多少个 windy 数？ 对于全部的测试点，保证 。 对于当前所填的数位，能进入下层循环的充要条件是它和前一个填入的数的绝对值大于等于 。只需要在枚举当前为所填数字时加入判断即可，这也预示着我们的状态中就需要额外添加一维用来记录前一个填入的数。 特殊地，如果当前是前导零，那么下一个填入的非零数将作为数字的开头，应该是不受绝对值限制的。 12345678910111213int dfs(int pos, int pre, bool limit, bool zero) { // 当前位置 上一个数 顶上界 前导零 int sum = 0; if (pos &lt; 0) return 1; if (!limit &amp;&amp; pre &gt;= 0 &amp;&amp; f[pos][pre] != -1) return f[pos][pre]; for (int i = 0; i &lt;= (limit ? num[pos] : 9); i++) { if (abs(i - pre) &lt; 2) continue; // 绝对值之差必须大于等于2 if (!i &amp;&amp; zero) sum += dfs(pos - 1, -2, limit &amp;&amp; i == num[pos], true); // 当前为前导零，下一位不受限制，填入小于等于-2或大于等于12的数均可 else sum += dfs(pos - 1, i, limit &amp;&amp; i == num[pos], false); } if (!limit &amp;&amp; !zero) f[pos][pre] = sum; return sum;} 洛谷 P4124 [CQOI2016] 手机号码 题目地址：P4124 题目难度：提高+/省选- 题目来源：重庆 2016 各省省选 一个符合要求的电话号码必须同时包含以下两个条件：号码中要出现至少 个相邻的相同数字；号码中不能同时出现 和 。 手机号码一定是 位数，且不含前导的 。请你统计出 区间内所有满足条件的号码数量。 和 也是 位的手机号码。 数据范围：。 考虑加入维度，一个用来判定电话号码中是否出现 、一个判断 的存在，此时再来维护“三个相邻的相同数字”这一条件，用一个布尔值来判断是否已经有三个及以上的相邻数字，此时再加一个最长连续长度，每次判断是否大于等于 即可。 由于计算时涉及到前缀和相减，当下界卡在 上时可能就错了。最好的方法是先用代码求解一遍取值为 时的结果，特判并减去这个特殊值即可。 12345678910111213141516171819202122232425ll dfs(int pos, int pre, bool limit, bool zero, bool _4, bool _8, bool cont, int last) { // 位置 前一个数 顶上界 前导零 出现4 出现8 是否三数连续 当前连续数 if (_4 &amp; _8) return 0; if (pos &lt; 0) return cont; if (!limit &amp;&amp; pre &gt;= 0 &amp;&amp; f[pos][pre][last][_4][_8][cont] &gt;= 0) return f[pos][pre][last][_4][_8][cont]; ll sum = 0; for (int i = 0; i &lt;= (limit ? num[pos] : 9); i++) { if (!i &amp;&amp; zero) sum += dfs(pos - 1, -1, limit &amp; i == num[pos], true, _4, _8, false, 0); else sum += dfs(pos - 1, i, limit &amp; i == num[pos], false, _4 | i == 4, _8 | i == 8, cont | (i == pre ? last + 1 &gt;= 3 : false), i == pre ? last + 1 : 1); } if (!limit &amp;&amp; !zero) f[pos][pre][last][_4][_8][cont] = sum; return sum;}ll calc(ll x) { num.clear(); ll tmp = x; while (tmp) { num.push_back(tmp % 10); tmp /= 10; } if (num.size() &lt; 11) return 485218848ll; // 特判 memset(f, -1, sizeof f); return dfs(num.size() - 1, -2, true, true, false, false, false, 0);} 洛谷 P4317 花神的数论题 题目地址：P4317 题目难度：提高+/省选- 设 表示 的二进制表示中 的个数。给出一个正整数 ，花神要问你 ，也就是 的乘积。结果对 取模。 对于 的数据，。 乍看还不太好想，但是当我们把数字变为二进制表示后，最多也只有 位。一般地，对于任意 ，我们求出二进制表示下恰好包含 个 的数的总数，假设结果记作 ，那么最终答案就会是 ，此时使用快速幂维护即可。 1234567891011ll dfs(int pos, bool pre, bool limit, int cnt, int target) { // 位置 前一个数 顶上界 填入1的个数 要求的1的个数 if (pos &lt; 0) return cnt == target; if (!limit &amp;&amp; f[pos][cnt][pre] &gt;= 0) return f[pos][cnt][pre]; ll sum = 0; for (int i = 0; i &lt;= (limit ? num[pos] : 1); i++) { sum += dfs(pos - 1, i, limit &amp; i == num[pos], cnt + i, target); } if (!limit) f[pos][cnt][pre] = sum; return sum;} 洛谷 P4127 [AHOI2009] 同类分布 题目地址：P4127 题目难度：提高+/省选- 题目来源：安徽 2009 各省省选 给出两个数，求出中各位数字之和能整除原数的数的个数。 对于所有的数据， 根据题目所给的数据范围，最大可能的数位和仅为 。于是考虑枚举这个数位和，同时维护一个当前数模这个数位和的余数，一个数符合要求当且仅当填完所有数之后余数为 。末尾填数的过程可以看作把原数乘 再加上当前的数，余数也可以通过乘十加上当前数再取模得到。 1234567891011ll dfs(int pos, int cur, ll now, bool limit, int m) { // 位置 当前数位和 当前余数 顶上界 枚举的数位和 if (pos &lt; 0) return cur == m &amp;&amp; now == 0; if (!limit &amp;&amp; f[pos][now][cur] &gt;= 0) return f[pos][now][cur]; ll sum = 0; for (int i = 0; i &lt;= (limit ? num[pos] : 9); i++) { sum += dfs(pos - 1, cur + i, (now * 10 + i) % m, limit &amp; i == num[pos], m); } if (!limit) f[pos][now][cur] = sum; return sum;} 洛谷 P6218 [USACO06NOV] Round Numbers S 题目地址：P6218 题目难度：提高+/省选- 题目来源：USACO 2006 如果一个正整数的二进制表示中， 的数目不小于 的数目，那么它就被称为「圆数」。请你计算，区间 中有多少个「圆数」。 对于 的数据，。 （二进制下）维护当前填了多少个 和多少个 ，同时注意前导零对数位统计上的影响即可。一个数合法当且仅当 的个数大于等于 的个数。 1234567891011int dfs(int pos, bool pre, int _0, int _1, bool limit, bool zero) { // 位置 上一个数 0的个数 1的个数 顶上界 前导零 if (pos &lt; 0) return _0 &gt;= _1 &amp;&amp; _0; // 必须填过0，以防前导零带来错误 if (!limit &amp;&amp; !zero &amp;&amp; f[pos][_0][_1][pre] &gt;= 0) return f[pos][_0][_1][pre]; int sum = 0; for (int i = 0; i &lt;= (limit ? num[pos] : 1); i++) { sum += dfs(pos - 1, i, !i &amp; zero ? 0 : _0 + !i, !i &amp; zero ? 0 : _1 + i, limit &amp; i == num[pos], zero &amp; !i); } if (!limit &amp;&amp; !zero) f[pos][_0][_1][pre] = sum; return sum;} CF 55D Beautiful Numbers 题目地址：CF 55D 题目难度：省选/NOI- Volodya 认为一个数字 是美丽的，当且仅当 并且对于 的每一个非零位上的数 ，都有 。你需要帮助他算出在区间 中有多少个数是美丽的。 组数据。。保证 都是整数，且 的十进制表示小于等于 位。 感觉跟刚刚切掉的“同类分布”这道题很像，但是这道题要求每一位上的数都整除原数。我们引入一个很有趣的数学常识。 某个数若能被若干个数整除，那么这个数也一定能被它们的最小公倍数整除。 因为它们的最小公倍数的因子一定能够完全包含这些数，因此结论显然是成立的。那么我们可以维护一个已填入的所有非零数的最小公倍数，解合法当且仅当最终的数字能被这个最小公倍数整除。但是这样就还得维护当前拼出的数，这显然不现实（），转而寻找替代方案。 注意到填入的数字最多把 都选一遍（ 不计入最小公倍数）。无论如何，每个数位都只能是一个区间内的数字。最坏情况下把 都选进数中，此时所有数位的最小公倍数就是 。也就是说，只要我们拼出来的数能够被 整除，那么无论每一位上是多少，它都是合法的。于是可以效仿“同类分布”这道题，采用记录余数的方法来判别。此时记忆化维度仍然过高，又注意到 的因数仅有 个，于是将每个因数离散化存在一个数组中，不难发现，维护的最小公倍数永远都是 的某个因子。至此，我们就做完了这道题。 12345678910111213141516171819202122ll dfs(int pos, bool limit, int m, int lcm) { // 位置 顶上界 余数 最小公倍数 if (pos &lt; 0) return m % lcm == 0; if (!limit &amp;&amp; f[pos][m][fac[lcm]] &gt;= 0) return f[pos][m][fac[lcm]]; ll sum = 0; for (int i = 0; i &lt;= (limit ? num[pos] : 9); i++) { // 若该位非零，则更新最小公倍数；反之不更新 sum += dfs(pos - 1, limit &amp; (i == num[pos]), (m * 10 + i) % 2520, i ? std::lcm(i, lcm) : lcm); } if (!limit) f[pos][m][fac[lcm]] = sum; return sum;}void init() { // 离散化因子 int idx = 0; for (int i = 1; i &lt;= 2520; i++) { if (2520 % i == 0) { fac[i] = ++idx; } }} 洛谷 P3413 SAC#1 萌数 题目地址：P3413 题目难度：省选/NOI- 定义萌数为满足“存在长度至少为 的回文子串”的数。请求出 到 内有多少个萌数。答案对 （）取模。 对于全部的数据，，。 这道题如果遍历整个数去判断是否存在回文会非常难办，因此想个办法来简化这一过程。注意到我们其实只关注数字中是否出现符合要求的回文串，而不关心这个回文串有多少。当一个串是回文串时，两个端点同时向内收缩一个字符得到的子串也同样是一个回文串。因此其实只用分两种最简情况讨论即可，因为其他情况都可以被转化为这两种情况。 第一种是长度恰好为 的回文串，也就是前后两个数相同。此时只需要维护前一个数的情况就好；第二种是长度为 的回文串，显然首尾需相同，中间任意填。此时就需要额外维护前第二个数的情况。 注意由于答案输出需要取模，而数位DP又涉及到减法，为了避免负数取模出错，故在差后加上一个模数再整体取模。并且注意到读入数据特大，因此写一个高精度减一的函数来预处理 。 1234567891011121314151617181920212223ll dfs(int pos, int pre, int pre2, bool limit, bool zero, bool ok) { // 位置 前一个数 再前一个 顶上界 前导零 是否是萌数 if (pos &lt; 0) return ok; if (!limit &amp;&amp; !zero &amp;&amp; f[pos][pre][pre2][ok] &gt;= 0) return f[pos][pre][pre2][ok]; ll sum = 0; for (int i = 0; i &lt;= (limit ? num[pos] : 9); i++) { if (!i &amp;&amp; zero) sum = (sum + dfs(pos - 1, 10, 10, limit &amp; (i == num[pos]), true, false)) % MOD; else sum = (sum + dfs(pos - 1, i, pre, limit &amp; (i == num[pos]), false, ok | (i == pre | i == pre2))) % MOD; // 要么是长度为2，要么长度为3 } if (!limit &amp;&amp; !zero) f[pos][pre][pre2][ok] = sum; return sum;}void init(string &amp;s) { // 高精度 for (size_t i = s.length() - 1; ~i; i--) { if (s[i] &gt; '0') { s[i]--; break; } s[i] = '9'; }} 洛谷 P6371 [COCI2006-2007 #6] V 题目地址：P6371 题目难度：省选/NOI- 题目来源：COCI Croatian 2007 使用给定的数字，组成一些在 之间的数使得这些数每个都能被 整除。 对于 的数据，保证 ，。 我们已经解决了很多关于整除的数位DP了，状态设计感觉还挺简单，预处理能填的数字，然后从备选能填的数字中选数来填，维护模数即可。由于状态普通数组存不下（万一模数会很大），考虑使用 STL 来处理这个点。填数时有一个细节是，如果备选数字中没有给 ，但是我们仍然可以用 来当前导零占位，如果不判会 WA 一个点。 然后我们成功 MLE/TLE 了，这是因为我们记录了太多无用且为 的状态。也就是说我们需要找到一个方法来加速无解情况的判断，无解其实就是最终的模数不为 。如果不是全 ，那么要让模数为 ，只有在当前的数大于等于给定模数时才能做到。 假设当前位置为 ，当前的模数为 ，要求被 整除。我们大胆假设一个特殊情况——后面的 位全填 。那么当全填上 后，模数就应该是 。要想最终模数为 ，那么至少就应该让模数增加 ，那么当剩下的位全填 都还小于这个标准时，那么铁定无解，判断即可。 1234567891011121314151617181920212223ll dfs(int pos, bool limit, bool zero, ll m, ll x) { // 位置 顶上界 前导零 模数 题目中的X if (pos &lt; 0) return !zero &amp;&amp; m == 0; if (!limit &amp;&amp; !zero &amp;&amp; f.count((PILL) {pos, m})) return f[(PILL) {pos, m}]; ll sum = 0; // 无解特判部分 ll check = m, tmp = 0; for (int i = 1; i &lt;= pos + 1; i++) check = check * 10ll % x; check = (x - check + x) % x; for (int i = 1; i &lt;= pos + 1; i++) { tmp = tmp * 10 + candidates.back(); if (tmp &gt; check) break; } if (tmp &lt; check) return 0; for (int i: candidates) { if (limit &amp;&amp; i &gt; num[pos]) break; if (!i &amp;&amp; zero) sum += dfs(pos - 1, limit &amp; (i == num[pos]), true, 0, x); else if (!allowZero &amp;&amp; !i) continue; // 不为前导零，但是不允许填零 else sum += dfs(pos - 1, limit &amp; (i == num[pos]), false, (m * 10 % x + i) % x, x); } if (!limit &amp;&amp; !zero) f[(PILL) {pos, m}] = sum; return sum;}","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"搜索算法","slug":"搜索算法","permalink":"https://justpureh2o.cn/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://justpureh2o.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"P10503 - 233 Matrix 题解","slug":"solution-p10503-233-matrix","date":"2024-09-01T03:36:37.000Z","updated":"2024-09-04T04:13:57.871Z","comments":true,"path":"articles/23333/","link":"","permalink":"https://justpureh2o.cn/articles/23333/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P10503 假设我们有一个称为 233 矩阵。在第一行，它可能是 233、2333、23333...（表示 ，，...）。此外，在 233 矩阵中，我们有 。现在已知 ，你能告诉我 233 矩阵中的 吗？ 发现 很小、 很大，于是选择使用 的矩阵快速幂做法。 假设矩阵一开始存储 列的信息，它看起来是这样的： 由于涉及到 的计算，我们需要同时递推 相关项，显然有 ，出现了常数，连同 一起，初始矩阵就应该是如下的样子： 然后可以发现： 得出 的转移矩阵： 然后让初始矩阵乘以转移矩阵的 次幂即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define N 15#define MOD 10000007using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; PII;int n, m;struct Matrix { ll mat[N][N]{}; Matrix() { memset(mat, 0, sizeof mat); } void I() { for (int i = 1; i &lt;= n + 2; i++) mat[i][i] = 1; }};Matrix operator*(const Matrix &amp;l, const Matrix &amp;r) { Matrix res; for (int i = 1; i &lt;= n + 2; i++) { for (int j = 1; j &lt;= n + 2; j++) { for (int k = 1; k &lt;= n + 2; k++) { res.mat[i][j] = (res.mat[i][j] + l.mat[i][k] % MOD * r.mat[k][j] % MOD) % MOD; } } } return res;}Matrix qpow(Matrix a, ll b) { Matrix res; res.I(); while (b) { if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; } return res;}void print(Matrix m) { for (int i = 1; i &lt;= n + 2; i++) { for (int j = 1; j &lt;= n + 2; j++) { cout &lt;&lt; setw(5) &lt;&lt; m.mat[i][j] &lt;&lt; ' '; } cout &lt;&lt; endl; }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); while (cin &gt;&gt; n &gt;&gt; m) { Matrix A, M; A.mat[1][1] = 1, A.mat[1][2] = 23; for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; A.mat[1][i + 2] = x; } for (int i = 1; i &lt;= n + 2; i++) { for (int j = i; j &lt;= n + 2; j++) { M.mat[i][j] = 1; } } for (int i = 2; i &lt;= n + 2; i++) M.mat[1][i] = 3, M.mat[2][i] = 10; A = A * qpow(M, m); cout &lt;&lt; A.mat[1][n + 2] % MOD &lt;&lt; endl; } return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"P10938 - Vani 和 Cl2 捉迷藏","slug":"solution-p10938-hide-and-seek-between-vani-and-cl2","date":"2024-08-31T17:37:03.940Z","updated":"2024-08-31T19:27:47.245Z","comments":true,"path":"articles/1126/","link":"","permalink":"https://justpureh2o.cn/articles/1126/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P10938 题目难度：省选/NOI- Vani 和 cl2 在一片树林里捉迷藏。 这片树林里有 座房子， 条有向道路，组成了一张有向无环图。 树林里的树非常茂密，足以遮挡视线，但是沿着道路望去，却是视野开阔。 如果从房子 沿着路走下去能够到达 ，那么在 和 里的人是能够相互望见的。 现在 cl2 要在这 座房子里选择 座作为藏身点，同时 Vani 也专挑 cl2 作为藏身点的房子进去寻找，为了避免被 Vani 看见，cl2 要求这 个藏身点的任意两个之间都没有路径相连。 为了让 Vani 更难找到自己，cl2 想知道最多能选出多少个藏身点。 对于 的数据，，，。 乍一看好像求最大点独立集的问题，但是它只存在于无向图中，题目所给是有向图。这道题的答案是该图的最小重复路径点覆盖的路径条数。那么什么是路径点覆盖呢？ 在图上选取若干条互不相交的路径，并让这些路径不重不漏覆盖到每一个点。符合上述要求且总数最小的方案就叫做原图的最小路径点覆盖，图中每个节点均只被覆盖一次。而最小重复路径点覆盖则是允许选取的路径相交，即某个点至少被覆盖一次。 在二分图中，最小路径点覆盖的路径条数等于总点数减去最大匹配数；最小路径重复点覆盖的数量则需要先求传递闭包，再计算最小路径点覆盖得出。 这启发我们可以把图转化为二分图来做，具体流程如下： 原图中的点 ，在二分图中变为 和 对于原图所有形如 的边，在二分图上连 ；对于所有形如 的边，在二分图上连边 就可以把原图当二分图求解了。 接下来证明为什么答案就是原图的最小重复路径点覆盖。设答案为 、原图最小重复路径点覆盖数为 ，即证明 ： 证明 ，考虑最小路径点覆盖的定义：因为 条路径已经把所有点覆盖了，选点只能选其中某条路径的某个端点，已知有道路相连的房屋是可以互相看到的，所以不可能同时选某条路径的两个端点（最多选一个）。因此选出的 是一定小于等于 的。 证明 ，考虑构造：将所有路径的终点 放入一个集合 中， 为“从 出发能够到达的所有点的集合”。如果 ，均有 ，意味着 内任意两点不互通，此时 为一组合法方案，大小为 ；反之，让当前的 沿有向边反着走直到满足上面的情况。若当前点已经退回到它的起点，都还不满足上述情况，意味着这个起点与 中的所有点都互通，我们完全可以让 作为起点，所有点也都能被覆盖到，此时的最小路径点覆盖数为 ，与原图最小路径点覆盖数为 矛盾。故一定存在 。 综上， 必定成立。证毕。 此时使用匈牙利算法跑二分图最大匹配，然后就可以得出答案了。时间复杂度 ，实际上会远小于此。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define N 210#define M 30010using namespace std;bool g[N][N];int match[N];bool st[N];int n, m;bool hungary(int u) { for (int i = 1; i &lt;= n; i++) { if (g[u][i] &amp;&amp; !st[i]) { st[i] = true; if (!match[i] || hungary(match[i])) { match[i] = u; return true; } } } return false;}void floyd() { // Floyd 传递闭包 for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { g[i][j] |= g[i][k] &amp; g[k][j]; } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; while (m--) { int a, b; cin &gt;&gt; a &gt;&gt; b; g[a][b] = 1; } floyd(); int res = 0; for (int i = 1; i &lt;= n; i++) { memset(st, false, sizeof st); if (hungary(i)) res++; } cout &lt;&lt; (n - res) &lt;&lt; endl; return 0;} 瓦尼瓦尼和氯气？","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"P10939 - 骑士放置 题解","slug":"solution-p10939-knight-placement","date":"2024-08-31T17:13:04.595Z","updated":"2024-08-31T17:40:10.073Z","comments":true,"path":"articles/12834/","link":"","permalink":"https://justpureh2o.cn/articles/12834/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P10939 题目难度：提高+/省选- 给定一个 的棋盘，有一些格子禁止放棋子。 问棋盘上最多能放多少个不能互相攻击的骑士（国际象棋的“骑士”，类似于中国象棋的“马”，按照“日”字攻击，但没有中国象棋“别马腿”的规则）。 看到数据范围，，状压 DP 肯定是没戏的。转而寻找其他能够解决棋盘问题的算法。 棋盘是这样的（从隔壁 P3355 借的图）： 骑士放在 处，可以攻击到叉号的位置。 此时发现一个规律：骑士能攻击到的方格的颜色与当前被放置方格的颜色是相反的。如果我们让所有某色方格向能到达的异色方格连边，那么两个骑士能互相攻击到就意味着这两个骑士通过若干条边相连。 此时两种颜色的方格恰好组成一张二分图的左右部点；题目要求我们选择尽量多的点，使得选出的点任意两点不互通，我们就可以求这个二分图上的最大点独立集的大小来得到答案。 最大点独立集的大小可以用总点数减去最大匹配得到。由于本题设置了不可到达点，计算时同样也要减去、且进行匈牙利算法时需要排除它们。总的时间复杂度是 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define N 210using namespace std;typedef pair&lt;int, int&gt; PII;bool g[N][N];PII match[N][N];bool st[N][N];int dx[8] = {-2, -1, 1, 2, -2, 1, -1, 2};int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};int n, m, k;bool hungary(PII t) { for (int i = 0; i &lt; 8; i++) { int nx = t.first + dx[i]; int ny = t.second + dy[i]; if (nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; m) continue; if (st[nx][ny] || g[nx][ny]) continue; st[nx][ny] = true; if (!match[nx][ny].first || hungary(match[nx][ny])) { match[nx][ny] = t; return true; } } return false;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= k; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; g[a][b] = true; } int res = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if ((i + j) % 2 || g[i][j]) continue; memset(st, false, sizeof st); if (hungary((PII) {i, j})) res++; } } cout &lt;&lt; n * m - res - k &lt;&lt; endl; return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"P10935 - 银河 题解","slug":"solution-p10935-the-galaxy","date":"2024-08-31T16:06:35.168Z","updated":"2024-08-31T17:10:32.398Z","comments":true,"path":"articles/7830/","link":"","permalink":"https://justpureh2o.cn/articles/7830/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P10935 题目难度：提高+/省选- 银河中的恒星浩如烟海，但是我们只关注那些最亮的恒星。 我们用一个正整数来表示恒星的亮度，数值越大则恒星就越亮，恒星的亮度最暗是 。 现在对于 颗我们关注的恒星，有 对亮度之间的相对关系已经判明。 你的任务就是求出这 颗恒星的亮度值总和至少有多大。 输入格式： 第一行给出两个整数 和 。 之后 行，每行三个整数 ，表示一对恒星 之间的亮度关系。恒星的编号从 开始。 如果 ，说明 和 亮度相等。 如果 ，说明 的亮度小于 的亮度。 如果 ，说明 的亮度不小于 的亮度。 如果 ，说明 的亮度大于 的亮度。 如果 ，说明 的亮度不大于 的亮度。 输出格式： 输出一个整数表示结果。 若无解，则输出 。 数据范围： 数据保证，，。 题目给出的大小关系可以转化为如下不等式组： 且需要满足亮度均大于等于 ，那么这道题有两种做法： 差分约束 差分约束可以通过把若干形如 的不等式组转化为图论问题来求得不等式组的特解。做法是把大的那部分向小的部分连一条长为 的有向边，本例中就是有向边 。题目要求亮度至少为 ，让一个虚拟源点向所有点连一条权值为 的有向边即可。 然后注意到有一个结论，要求出未知量的最小值，就需要在新图上做最长路，反之做最短路，这两种情况无解当且仅当图中存在正环/负环。 因而可以使用 的 来求解，但是数据范围都是 级别的，这条路不可取。于是我们转而寻找更优的策略解答。 强连通分量 强连通分量是指图中的极大强连通子图，而有向图强连通当且仅当图中任意两个点连通。 根据这个定义，有向图的强连通分量中必定会存在至少一个环（单点构成的强连通分量除外），考虑到建出的图中边权只会是 ，因此整张图存在正环当且仅当某个强连通分量中出现了长度为正数的边。 同样需要虚拟源点，使用 算法能够在 复杂度内解决。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;#define N 100010#define M 300010using namespace std;typedef long long ll;struct Edge { int to, ne, w;} edges[M &lt;&lt; 1];int h[N], hs[N], idx = 0;int scc_cnt = 0, dfs_cnt = 0;int scc_id[N], scc_size[N];int dfn[N], low[N];int dist[N];stack&lt;int&gt; stk;bool in_stk[N];void add(int head[], int a, int b, int w) { idx++; edges[idx].to = b; edges[idx].ne = head[a]; edges[idx].w = w; head[a] = idx;}void tarjan(int u) { dfn[u] = low[u] = ++dfs_cnt; stk.push(u); in_stk[u] = true; for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; if (!dfn[j]) { tarjan(j); low[u] = min(low[u], low[j]); } else if (in_stk[j]) { low[u] = min(low[u], dfn[j]); } } if (dfn[u] == low[u]) { scc_cnt++; int t; do { t = stk.top(); stk.pop(); in_stk[t] = false; scc_id[t] = scc_cnt; scc_size[scc_cnt]++; } while (t != u); }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); memset(hs, -1, sizeof hs); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) add(h, 0, i, 1); while (m--) { int t, a, b; cin &gt;&gt; t &gt;&gt; a &gt;&gt; b; if (t == 1) { add(h, a, b, 0); add(h, b, a, 0); } else if (t == 2) add(h, a, b, 1); else if (t == 3) add(h, b, a, 0); else if (t == 4) add(h, b, a, 1); else add(h, a, b, 0); } tarjan(0); for (int i = 0; i &lt;= n; i++) { for (int j = h[i]; ~j; j = edges[j].ne) { int k = edges[j].to; int a = scc_id[i], b = scc_id[k]; if (a == b) { if (edges[j].w &gt; 0) { cout &lt;&lt; -1 &lt;&lt; endl; return 0; } } else add(hs, a, b, edges[j].w); } } for (int i = scc_cnt; i &gt;= 1; i--) { for (int j = hs[i]; ~j; j = edges[j].ne) { int k = edges[j].to; dist[k] = max(dist[k], dist[i] + edges[j].w); } } ll res = 0; for (int i = 1; i &lt;= scc_cnt; i++) res += dist[i] * scc_size[i]; cout &lt;&lt; res &lt;&lt; endl; return 0;} 后记 这道题启示我们，某些差分约束的题目可以使用强连通分量加速求解。 我发现这道题和 P3275 [SCOI2011] 糖果 很像，没错，这是双倍经验！","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"P7812 [JRKSJ R2] - Dark Forest 题解","slug":"solution-p7812-dark-forest","date":"2024-08-31T00:43:10.356Z","updated":"2024-08-31T17:11:04.933Z","comments":true,"path":"articles/27039/","link":"","permalink":"https://justpureh2o.cn/articles/27039/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：P7812 题目难度：省选/NOI- 题目类型：提交答案 Special Judge 本题为提交答案题。 给你一个长为 的序列 ，定义 的排列 的权值为 你可以理解为这个排列是一个环，即 。 请构造一个权值尽量大的 的排列。 输入格式： 第一行一个整数 。 第二行 个整数表示序列 。 输出格式： 一行 个整数表示排列。 数据范围： 对于 的数据，。 评分方式： 本题使用 Special Judge，每个测试点都有 个参数 。如果你的输出的权值 ，则该测试点您至少会获得 分。 特别的，如果您的输出不是一个 的排列，您会在该测试点获得 分。 评分参数已经放至附件。 附件下载： 评分参数 输入数据 什么？提交答案题？直接打表！ 首先我们需要明确如何才能构造出一个符合题意的排列，暴力枚举的复杂度是 的，显然是不可取的做法。因此我们考虑随机化做法。 测试点 1-2 提到随机化，我们有模拟退火。先随机一个 的排列，再任意交换若干元素并与先前的序列权值进行比较，若更优则直接采纳，否则就依据 准则概率接受，其余情况则恢复原状。 在本地跑没有时限，可以把参数调精一点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define N 1010#define PRINT_TABLEusing namespace std;typedef long long ll;int n;ll a[N], p[N], q[N];random_device rd;ll ans = 0;double rand(double l, double r) { return (double) rd() / random_device::max() * (r - l) + l;}int rand(int l, int r) { return (int) (rd() % (r - l + 1)) + l;}ll calc() { // 计算权值 ll sum = p[1] * a[p[n]] * a[p[1]] * a[p[2]]; for (int i = 2; i &lt; n; i++) sum += p[i] * a[p[i - 1]] * a[p[i]] * a[p[i + 1]]; sum += p[n] * a[p[n - 1]] * a[p[n]] * a[p[1]]; return sum;}void SA() { double T = 1e10; ans = max(ans, calc()); while (T &gt; 1e-17) { int a = rand(1, n), b = rand(1, n); swap(p[a], p[b]); ll now = calc(); long double delta = now - ans; if (delta &gt; 0) { memcpy(q, p, sizeof p); ans = now; } else if (exp(delta / T) &lt;= (double) rd() / random_device::max()) swap(p[a], p[b]); T *= 0.99996; }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); // Test Point #1 #2 cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) p[i] = i; shuffle(p + 1, p + 1 + n, mt19937(rd())); SA(); clog &lt;&lt; ans &lt;&lt; endl;// 打表格式化#ifdef PRINT_TABLE cout &lt;&lt; '{'; for (int i = 1; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; \", \"; cout &lt;&lt; q[n] &lt;&lt; \"},\\n\";#else for (int i = 1; i &lt;= n; i++) cout &lt;&lt; q[i] &lt;&lt; ' ';#endif return 0;} 一般来说一秒之内可以出答案。 测试点 3 测试点 3 的数据很有意思，它是一个单调递增的排列。模拟退火跑了很久，得出的排列有两头大、中间小的特征。于是大胆构造一个特解——从左至右奇数递减、从右至左偶数递减。 测试点 4-10 模拟退火调了半天参数就是过不去……同机房的大佬好像用加强版的模拟退火跑了几天才跑过？这里推荐一个叫“遗传算法”的解决方案。 遗传算法能通过模拟生物繁衍、自然选择等自然现象来实现求解全局最优解的功能。具体是让当前的优解进行变换，期望能得到一个更优的解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define N 1010#define PRINT_TABLE#define LIMIT 141473199965824ll // 每个测试点的最大值#pragma optimize(3)using namespace std;typedef long long ll;int n;ll ans = 0, submax = 0;random_device rd;ll a[N], p[N], q[N], id[N];ll calc(const ll arr[] = p) { ll sum = arr[1] * a[arr[n]] * a[arr[1]] * a[arr[2]]; for (int i = 2; i &lt; n; i++) sum += arr[i] * a[arr[i - 1]] * a[arr[i]] * a[arr[i + 1]]; sum += arr[n] * a[arr[n - 1]] * a[arr[n]] * a[arr[1]]; return sum;}ll d(int pos1, int pos2) { // 处理交换前后的变化量 ll sum = 0; sum -= p[pos1] * a[p[pos1 - 1]] * a[p[pos1]] * a[p[pos1 + 1]] + p[pos1 + 1] * a[p[pos1]] * a[p[pos1 + 1]] * a[p[pos1 + 2]] + p[pos1 - 1] * a[p[pos1 - 2]] * a[p[pos1 - 1]] * a[p[pos1]]; sum -= p[pos2] * a[p[pos2 - 1]] * a[p[pos2]] * a[p[pos2 + 1]] + p[pos2 + 1] * a[p[pos2]] * a[p[pos2 + 1]] * a[p[pos2 + 2]] + p[pos2 - 1] * a[p[pos2 - 2]] * a[p[pos2 - 1]] * a[p[pos2]]; swap(p[pos1], p[pos2]); sum += p[pos1] * a[p[pos1 - 1]] * a[p[pos1]] * a[p[pos1 + 1]] + p[pos1 + 1] * a[p[pos1]] * a[p[pos1 + 1]] * a[p[pos1 + 2]] + p[pos1 - 1] * a[p[pos1 - 2]] * a[p[pos1 - 1]] * a[p[pos1]]; sum += p[pos2] * a[p[pos2 - 1]] * a[p[pos2]] * a[p[pos2 + 1]] + p[pos2 + 1] * a[p[pos2]] * a[p[pos2 + 1]] * a[p[pos2 + 2]] + p[pos2 - 1] * a[p[pos2 - 2]] * a[p[pos2 - 1]] * a[p[pos2]]; return sum;}int rand(int l, int r) { return (int) (rd() % (r - l + 1)) + l;}void GA() { while (ans &lt; LIMIT) { for (int i = 1; i &lt;= 20; i++) { int a = rand(1, n), b = rand(1, n); swap(p[a], p[b]); } submax = calc(); // 当前值 shuffle(id + 1, id + 1 + n, mt19937(rd())); // 每次打乱枚举顺序 bool flag; do { // 还能变得更优就继续下去 flag = false; #pragma unroll 20 for (int i = 1; i &lt; n; i++) { for (int j = i + 1; j &lt;= n; j++) { ll cur; int pos1 = id[i], pos2 = id[j]; if (abs(pos2 - pos1) &lt;= 5 || abs(pos2 - pos1) &gt;= n - 5) { swap(p[pos1], p[pos2]); cur = calc(); } else { cur = submax + d(pos1, pos2); } if (cur &gt; ans) { ans = submax = cur; memcpy(q, p, sizeof p); if (ans &gt; (ll) (LIMIT * 0.999)) cerr &lt;&lt; ans &lt;&lt; endl; flag = true; if (ans &gt;= LIMIT) return; } else if (cur &gt; submax) { submax = cur; flag = true; } else swap(p[pos1], p[pos2]); } } } while (flag); }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); // Test Point #4 #5 #6 #7 #8 #9 freopen(\"9.in\", \"r\", stdin); freopen(\"9.out\", \"w\", stdout); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) p[i] = i, id[i] = i; GA(); clog &lt;&lt; \"Final Answer: \" &lt;&lt; calc(q) &lt;&lt; \" Overloaded: \" &lt;&lt; calc(q) - LIMIT &lt;&lt; endl;#ifdef PRINT_TABLE cout &lt;&lt; '{'; for (int i = 1; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; \", \"; cout &lt;&lt; q[n] &lt;&lt; \"}\\n\";#else for (int i = 1; i &lt;= n; i++) cout &lt;&lt; q[i] &lt;&lt; ' ';#endif return 0;} 跑得稍久一些，但是还是比较快的。","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"随机化","slug":"随机化","permalink":"https://justpureh2o.cn/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"物竞天择 遗传算法","slug":"algorithm-genetic","date":"2024-08-28T01:08:57.416Z","updated":"2024-08-31T18:21:43.626Z","comments":true,"path":"articles/34336/","link":"","permalink":"https://justpureh2o.cn/articles/34336/","excerpt":"","text":"前言 遗传算法Genetic Algorithm，简称 GA。是一种基于随机化的最优解搜索算法，它和模拟退火Simulate Anneling都基于随机化，遗传算法通过模拟自然界生物的遗传和变异、自然选择和淘汰的过程来找到最优种群（最优解）；后者则是通过设定一个初始温度以及降温率、将当前最优解进行随机扰动以寻得更优的解来找到最优解。 （纯属虚构）遗传算法就好比生活在中原地区的 OIer 们，竞赛主办方希望筛选出“随机化算法调参能力最强的一批选手”。于是官方从今年起，将复试的四道试题全部换成了需要模拟退火才能解决的问题，并且严格卡精度和时限。这样一来，调参能力弱的选手大多在复试中遗憾落榜，剩下的大部分都是调参能力强的选手……如此几年之后，官方会惊奇地发现全国选手的调参能力都有了大幅提升，最佳选手同样可以通过逐渐严格的要求来筛选出来。 相比之下，遗传算法适合解决复杂的离散与组合优化问题，在问题规模较大、搜索空间复杂时表现良好。 生物术语 学遗传算法首先就需要搞清楚它背后的基本生物学概念（都是高一内容，请放心食用）： 个体和种群：生命系统的其中两级结构层次，前者是指单一的生物体；后者则是指同一时间在一定区域内生活的同种生物的全部个体（同一时间、一定区域、同种生物、全部个体） 染色体：由组蛋白和缠绕的 DNA 双链构成，是遗传信息的载体 基因型：某个体全部基因组合的总称，可以理解为个体的基因组成 互换（基因重组）、基因突变：前者发生在减数分裂的前期，指在一对联会的同源染色体（四分体）间发生染色体相应片段的交换；后者是指基因发生的部分碱基对的改变 自然选择：来自达尔文进化论。他主张种群间存在生存斗争，有利突变积累得更多的个体有更大的几率在斗争中存活下来并将这些有利突变遗传给后代。即“物竞天择，适者生存” 以下几张图可以帮助你更轻松的理解这些概念： 互换： 互换 基因突变： 基因突变 算法基本流程 适应性描述 我们引入一个适应性函数 表示当前种群在当前环境下的生存表现，分数越高的种群就越有可能在此轮将当前代的优良基因遗传下去，即参与下一轮迭代。而随着迭代次数的增加，每一代的平均表现值会增加，当找到我们想要的优良后代时，停止这个算法，并宣布我们已经找到了一个令人满意的解。 的计算因题而异。在费马点的求解中，它可以是当前点到其他点的欧几里得距离之和；在最优化排列问题中，它可以是当前排列的总贡献、也可以是当前排列与标准排列之间的元素差距……总之，这个函数需要能定量地描述当前解与标准解之间的差距。 基因的突变和重组 遗传算法的一大乐趣就是模拟“遗传”和“变异”的过程。我们考虑把整个染色体编码成一个 0/1 串（实数串也是可行的），每一位代表一个基因，整个个体就可以看作是一个染色体集合（二进制串集合）。遗传时按照均等概率从父方和母方继承基因、变异过程也能通过随机取反某一位实现。 双亲杂交的代码实现如下（C++17 标准）： 1234567891011121314151617181920// 整数版本 - LENGTH 宏记录整数的二进制最高包含多少位[[nodiscard]] Individual hybrid(Individual p) const { int child = 0; for (int i = 0; i &lt;= LENGTH; i++) { if (rand(1, 100) &lt;= 50) child |= (gene &gt;&gt; i); else child |= (p.gene &gt;&gt; i); } return Individual(child);}// 字符串版本[[nodiscard]] Individual hybrid(Individual p) const { string child; size_t len = gene.length(); for (int i = 0; i &lt; len; i++) { if (rand(1, 100) &lt;= 50) child[i] = gene[i]; else child[i] = p.gene[i]; } return Individual(child);} 个体突变的代码实现如下（C++17 标准）： 1234567891011121314151617// 整数版本 - LENGTH 宏记录整数的二进制最高包含多少位void mutate() { int times = rand(1, 3); // 突变 1~3 个基因，可调 for (int i = 1; i &lt;= times; i++) { int pos = rand(0, LENGTH); gene ^= (1 &lt;&lt; pos); }}// 字符串版本void mutate() { int times = rand(1, 3); for (int i = 1; i &lt;= times; i++) { int pos = rand(0, gene.length() - 1); gene[pos] = (gene[pos] == '0' ? '1' : '0'); }} 优解的筛选与继承 算法开始时，我们会创建一个虚拟种群，种群大小是一个参数，一般在 内。对于每一代，我们都在种群中随机选择个体杂交得到子一代。 和模拟退火一样，我们计算一下子代的适应参数，如果与亲代相比有了进步，那我们就毫不犹豫地让它生存下去；反之，这个子代是有一定几率能生存下去的，我们让这个概率遵循 准则，即 ，取 是比较明智的。 那如何最大化解的最优性呢？可以使用不同的随机算子，常用的几种随机算子如下： 最佳保留选择 这是为了最小化不定向变异和随机遗传带来的优良性状丢失所设计的选择算子。 首先把父代集合按照适应性进行降序排列，选取最靠前的若干个体，并让它们直接拿到进入下一代的入场券。然后再从排名相对靠前的亲代个体中选择个体杂交，并继承到子代。 因为代码实现简单、排序的时间复杂度相对较低、保证继承优良性状、有效减少随机性损失、维持了最基本的基因多样性，因此这是最常用的选择算子之一。 轮盘赌选择 类似于分层抽样调查的原理。首先计算出种群内所有个体的适应度之和，接下来对于每个个体 ，被选中的概率可以通过如下公式导出： 此后再进行随机，按照计算出的概率分配名额即可。实现难度较最佳保留选择较大，而且这种选择算子造成的选择误差也会更大一些。 随机竞争选择 每次用轮盘赌选择选出两个个体，并让二者进行竞争，适应度大的保留，选入下一代，直到满额为止。这种方法的时间复杂度较高，但是能比较有效的保留亲代优良性状。 因为最佳保留选择算子的实现简单、效果较好，因此下面给出最佳保留选择的实现代码： 123456789101112131415161718// MAX_POPULATION 是种群的最大个体数；MAX_ADAPTION 作用是让父代表现优异的保送进下一代；MAX_ACCEPTANCE 用来设置父代生存能力排名的上限vector&lt;Individual&gt; initP; // 初始种群for (int i = 1; i &lt;= MAX_POPULATION; i++) initP.emplace_back(rand(0, 1000000), rand(0, 1000000));for (int T = 10; T; T--) { // 繁衍 10 代，可调 vector&lt;Individual&gt; curP; // 子代 sort(initP.begin(), initP.end()); // 排序 for (int i = 0; i &lt;= MAX_ADAPTION; i++) curP.push_back(initP[i]); // 保送 while (curP.size() &lt; MAX_POPULATION) { Individual p = initP[rand(0, MAX_ACCEPTANCE)]; // 选出父代 Individual child = p.hybrid(initP[rand(0, MAX_ACCEPTANCE)]); // 杂交得到子代 if (rand(0.0, 1.0) &lt;= 0.02) child.mutate(); // 2% 的几率突变个别基因，几率可调 double x = child.fit, y = p.fit; double delta = x - y; if (delta &lt; 0 || exp(-delta / T) / 2.0 &gt; rand(0.0, 1.0)) curP.push_back(child); // 优胜劣汰 } initP = curP; // 更新种群} 典型例题 UVA 10228 / POJ 2420 - A Star not a Tree? / AcWing 3167 星星还是树 题目地址：UVA 10228/POJ 2420/AcWing 3167 题目难度：普及+/提高 题面来源于 AcWing 在二维平面上有 个点，第 个点的坐标为 。 请你找出一个点，使得该点到这 个点的距离之和最小。 该点可以选择在平面中的任意位置，甚至与这 个点的位置重合。 输入格式： 第一行包含一个整数 。 接下来 行，每行包含两个整数 ，表示其中一个点的位置坐标。 输出格式： 输出最小距离和，答案四舍五入取整。 数据范围： 请注意，UVA 题目的输出有细微不同！ 这道题是一道求解平面费马点的模板问题。我们把当前点的坐标设计成基因，由于题目要求保留整数，为了精度，坐标需要保留到两位小数，考虑到 ，我们可以把这个数设置成 以内的整数，在计算 时除以 即可；在设计适应性函数时，我们就选用当前点到其他点的距离之和；稍微调整一下参数，我们就可以过掉这个题。为了方便，这里转而使用父代自交的方法产生子代。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;#define N 110#define MAX_POPULATION 500#define MAX_ADAPTION 30#define MAX_ACCEPTANCE 50using namespace std;typedef pair&lt;double, double&gt; PDD;PDD a[N];int n;random_device rd;double ans = 1e9;double rand(double l, double r);double dis(PDD i, PDD j);int rand(int l, int r);struct Individual { int x, y; double fit; Individual(int x, int y) : x(x), y(y) { fit = fitness(); } [[nodiscard]] double fitness() const { double sum = 0; for (int i = 1; i &lt;= n; i++) { sum += dis((PDD) {(double) x / 100, (double) y / 100}, a[i]); } return sum; } [[nodiscard]] Individual hybrid() const { int x1 = x, y1 = y; int t = rand(0, 3); for (int i = 1; i &lt;= t; i++) { int pos = rand(0, 20); x1 ^= (1 &lt;&lt; pos); } t = rand(0, 3); for (int i = 1; i &lt;= t; i++) { int pos = rand(0, 20); y1 ^= (1 &lt;&lt; pos); } return {x1, y1}; } void mutate() { for (int i = 1; i &lt;= 3; i++) x ^= (1 &lt;&lt; rand(0, 20)); for (int i = 1; i &lt;= 3; i++) y ^= (1 &lt;&lt; rand(0, 20)); } bool operator&lt;(const Individual &amp;p) const { return fit &lt; p.fit; }};double dis(PDD i, PDD j) { return sqrt((i.first - j.first) * (i.first - j.first) + (i.second - j.second) * (i.second - j.second));}double rand(double l, double r) { if (r &lt; l) return 0; return (double) rd() / random_device::max() * (r - l) + l;}int rand(int l, int r) { if (r &lt; l) return 0; return (int) (rd() % (r - l + 1)) + l;}void GA() { vector&lt;Individual&gt; initP; for (int i = 1; i &lt;= MAX_POPULATION; i++) initP.emplace_back(rand(0, 1000000), rand(0, 1000000)); for (int T = 10; T; T--) { vector&lt;Individual&gt; curP; sort(initP.begin(), initP.end()); for (int i = 0; i &lt;= MAX_ADAPTION; i++) curP.push_back(initP[i]); while (curP.size() &lt; MAX_POPULATION) { Individual p = initP[rand(0, MAX_ACCEPTANCE)]; Individual child = p.hybrid(); if (rand(0.0, 1.0) &lt;= 0.02) child.mutate(); double x = child.fit, y = p.fit; double delta = x - y; if (delta &lt; 0 || exp(-delta / T) / 2.0 &gt; rand(0.0, 1.0)) curP.push_back(child); } initP = curP; } ans = initP[0].fitness();}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t; cin &gt;&gt; t; for (int i = 1; i &lt;= t; i++) { ans = 1e9; cin &gt;&gt; n; for (int j = 1; j &lt;= n; j++) cin &gt;&gt; a[j].first &gt;&gt; a[j].second; GA(); cout &lt;&lt; (int) round(ans) &lt;&lt; endl; if (i ^ t) cout &lt;&lt; endl; } return 0;} P7812 [JRKSJ R2] - Dark Forest 题解同步 题目地址：P7812 题目难度：省选/NOI- 题目类型：提交答案 本题为提交答案题。 给你一个长为 的序列 ，定义 的排列 的权值为 你可以理解为这个排列是一个环，即 。 请构造一个权值尽量大的 的排列。 输入格式： 第一行一个整数 。 第二行 个整数表示序列 。 输出格式： 一行 个整数表示排列。 数据范围： 对于 的数据，。 注意事项： 本题使用 Special Judge，每个测试点都有 个参数 。如果你的输出的权值 ，则该测试点您至少会获得 分。 特别的，如果您的输出不是一个 的排列，您会在该测试点获得 分。 附件下载： 评分参数 输入数据 因为我选择本地测评再提交打表程序（太菜了不知道怎么提交答案），所以本地我会开 O3 优化、以及循环展开之类的编译预处理指令。 数据点 还是好做的，直接模拟退火能过，没有时限的话把参数卡死一点是没问题的。 数据点 很有意思，输入是一个单增排列，我们优先让大数乘大数，构造一个两边大中间小的特殊构造即可。 数据点 就开始上强度了，模拟退火怎么卡精度都过不去，同机房的退火大佬好像跑了几天？总之对于这种毒瘤测试点，我们上遗传算法。 实现整个种群太过麻烦，因此就只选择一个个体来进行自我繁衍。过程中需要记录全局最优、当前最优，然后随机一个排列，交换部分元素并更新答案即可。有人会说我还是过不了，跑得太慢了。那是因为做了很多无用的交换，我们枚举交换的位置，然后依次检查对答案的贡献是否为正。只要当前序列还能继续创造更优解，那么让它进行下去，否则对序列进行一次大清洗，从头来过。 这里只放遗传算法的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define N 1010#define PRINT_TABLE#define LIMIT 141473199965824ll // 每个测试点的最大值#pragma optimize(3)using namespace std;typedef long long ll;int n;ll ans = 0, submax = 0;random_device rd;ll a[N], p[N], q[N], id[N];ll calc(const ll arr[] = p) { ll sum = arr[1] * a[arr[n]] * a[arr[1]] * a[arr[2]]; for (int i = 2; i &lt; n; i++) sum += arr[i] * a[arr[i - 1]] * a[arr[i]] * a[arr[i + 1]]; sum += arr[n] * a[arr[n - 1]] * a[arr[n]] * a[arr[1]]; return sum;}ll d(int pos1, int pos2) { ll sum = 0; sum -= p[pos1] * a[p[pos1 - 1]] * a[p[pos1]] * a[p[pos1 + 1]] + p[pos1 + 1] * a[p[pos1]] * a[p[pos1 + 1]] * a[p[pos1 + 2]] + p[pos1 - 1] * a[p[pos1 - 2]] * a[p[pos1 - 1]] * a[p[pos1]]; sum -= p[pos2] * a[p[pos2 - 1]] * a[p[pos2]] * a[p[pos2 + 1]] + p[pos2 + 1] * a[p[pos2]] * a[p[pos2 + 1]] * a[p[pos2 + 2]] + p[pos2 - 1] * a[p[pos2 - 2]] * a[p[pos2 - 1]] * a[p[pos2]]; swap(p[pos1], p[pos2]); sum += p[pos1] * a[p[pos1 - 1]] * a[p[pos1]] * a[p[pos1 + 1]] + p[pos1 + 1] * a[p[pos1]] * a[p[pos1 + 1]] * a[p[pos1 + 2]] + p[pos1 - 1] * a[p[pos1 - 2]] * a[p[pos1 - 1]] * a[p[pos1]]; sum += p[pos2] * a[p[pos2 - 1]] * a[p[pos2]] * a[p[pos2 + 1]] + p[pos2 + 1] * a[p[pos2]] * a[p[pos2 + 1]] * a[p[pos2 + 2]] + p[pos2 - 1] * a[p[pos2 - 2]] * a[p[pos2 - 1]] * a[p[pos2]]; return sum;}int rand(int l, int r) { return (int) (rd() % (r - l + 1)) + l;}void GA() { while (ans &lt; LIMIT) { for (int i = 1; i &lt;= 20; i++) { int a = rand(1, n), b = rand(1, n); swap(p[a], p[b]); } submax = calc(); // 当前值 shuffle(id + 1, id + 1 + n, mt19937(rd())); // 每次打乱枚举顺序 clog &lt;&lt; \"Reset...\" &lt;&lt; endl; bool flag; do { // 还能变得更优就继续下去 flag = false; for (int i = 1; i &lt; n; i++) { for (int j = i + 1; j &lt;= n; j++) { ll cur; int pos1 = id[i], pos2 = id[j]; if (abs(pos2 - pos1) &lt;= 5 || abs(pos2 - pos1) &gt;= n - 5) { swap(p[pos1], p[pos2]); cur = calc(); } else { cur = submax + d(pos1, pos2); } if (cur &gt; ans) { ans = submax = cur; memcpy(q, p, sizeof p); if (ans &gt; (ll) (LIMIT * 0.999)) cerr &lt;&lt; ans &lt;&lt; endl; flag = true; if (ans &gt;= LIMIT) return; } else if (cur &gt; submax) { submax = cur; flag = true; } else swap(p[pos1], p[pos2]); } } } while (flag); }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); // Test Point #4 #5 #6 #7 #8 #9 freopen(\"9.in\", \"r\", stdin); freopen(\"9.out\", \"w\", stdout); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) p[i] = i, id[i] = i; GA(); clog &lt;&lt; \"Final Answer: \" &lt;&lt; calc(q) &lt;&lt; \" Overloaded: \" &lt;&lt; calc(q) - LIMIT &lt;&lt; endl;#ifdef PRINT_TABLE cout &lt;&lt; '{'; for (int i = 1; i &lt; n; i++) cout &lt;&lt; q[i] &lt;&lt; \", \"; cout &lt;&lt; q[n] &lt;&lt; \"}\\n\";#else for (int i = 1; i &lt;= n; i++) cout &lt;&lt; q[i] &lt;&lt; ' ';#endif return 0;}","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"随机化","slug":"随机化","permalink":"https://justpureh2o.cn/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"}]},{"title":"随机化高能骗分 模拟退火","slug":"algorithm-simulate-anneal","date":"2024-08-25T17:14:53.368Z","updated":"2024-08-27T03:11:34.923Z","comments":true,"path":"articles/54974/","link":"","permalink":"https://justpureh2o.cn/articles/54974/","excerpt":"","text":"退火与模拟退火 退火，是一种物理过程。指通过将固体加热到一定温度，并让温度缓慢降低，从而让高能的粒子能够在每个温度均达到平衡态，最终让整个固体变为内能最小的状态的过程。通常用这个方法来使固体硬度变得更高。 而模拟退火则是使用计算机语言模拟物理学中退火的过程，达到求多峰函数最优解近似值的功能。它通过设定一个模拟初始温度、以及一个终止温度（可以理解为精度）和一个衰减率，每次随机选取一个函数值，并随机邻域上的某个值，比较两值并优化答案，最终实现求近似解的功能。 一般来说，温度的衰减需要符合 准则，即当前温度为 ，粒子内能的变化量为 时，该粒子趋于平衡的概率为 ，其中 为常数。也就是说我们先机选一个值，再随机出另外的值，比较差异，更优则直接进入第二个值；否则我们有概率选择这个更劣的解，概率是 ，同时再迭代下一个温度。 世界上有很多无法在多项式时间内解决的问题（ 问题），例如求解费马点的坐标、旅行商问题等；有些问题的复杂度是指数级别的，求解精确值的时间极长；又或者你在训练一个 模型……此时人们希望找到一种方法，使得能够在较短的时间内解出答案的近似值。然后，模拟退火、爬山算法、遗传算法等就进入了人们的视野。 下图展示了模拟退火找到全局最优解的过程： Simulate Anneal 模拟退火核心函数如下： 12345678void SA() { double T = 1e4; // 初始温度 while (T &gt; 1e-4) { double d = calc(now) - calc(cur); // 计算差距 if (exp(-d / T) &gt; rand(0, 1)) cur = now; // Metropolis 准则 T *= 0.99; // 按既定比率降温 }} 更好的随机化选择 在平衡树的“如何生成更好的随机数”一节中，我们介绍了常用的三种随机数生成器 rand、random_device 和 mt_19937。接下来介绍一种听起来就非常牛逼的随机分布生成器 uniform_real_distribution。 整/实数均匀分布类 整数和浮点数版本分别对应 std::uniform_int_distribution 和 std::uniform_real_distribution。定义和普通的 STL 容器类似，需要指定存储类型，支持上下界约束。它在生成随机数时需要一个随机数生成引擎 std::default_random_engine 作为参数传入，理解为设置种子即可。 123456789default_random_engine random(time(nullptr));uniform_int_distribution&lt;int&gt; dis1(0, 100);uniform_real_distribution&lt;double&gt; dis2(0.0, 1.0);for(int i = 0; i &lt; 10; ++i) cout &lt;&lt; dis1(random) &lt;&lt; ' ';cout &lt;&lt; endl;for(int i = 0; i &lt; 10; ++i) cout &lt;&lt; dis2(random) &lt;&lt; ' ';cout &lt;&lt; endl; 输出： 1270 5 91 57 87 15 52 72 62 960.806944 0.389546 0.951 475 0.530597 0.125625 0.622024 0.109438 0.735015 0.717254 0.954637 生成带上下界的随机数 一般来说，对于 范围内的随机数生成，我们只需要把结果对 取模即可，但是这样并不明智且泛用性低，如果带上下界，那么这个方法将不再适用。 如果要生成 内的任意实数，一个现成的公式是： 首先我们的 将答案约束到了 内，然后乘区间大小，得到一个 间的实数，最后加上下界，结果就位于 内了。 常见随机数生成模板 123456789101112131415161718// 一般的随机数srand(time(nullptr));int x1 = rand();// random devicerandom_device rd;unsigned x2 = rd();// mt19937mt19937 mt(time(nullptr));unsigned x3 = mt();// 均匀分布default_random_engine seed(time(nullptr));uniform_real_distribution&lt;double&gt; urd(L, R);uniform_int_distribution&lt;int&gt; uid(L, R);double x4 = urd(seed);int x5 = uid(seed); 典例解析 POJ 3420/AcWing 3167/UVA 星星还是树 题目地址：AcWing 3167 题目难度：中等 在二维平面上有 个点，第 个点的坐标为 。 请你找出一个点，使得该点到这 个点的距离之和最小。 该点可以选择在平面中的任意位置，甚至与这 个点的位置重合。 输入格式： 第一行包含一个整数 。 接下来 行，每行包含两个整数 ，表示其中一个点的位置坐标。 输出格式： 输出最小距离和，答案四舍五入取整。 数据范围： 这是一道求解二维平面费马点的问题，可以使用模拟退火求解。首先拟定一个平面上的随机点，然后在它的周围区域随机一个新点，若更优则直接跳转到新点，否则则有一定几率跳到新点，整个过程遵循 准则。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define N 200using namespace std;typedef pair&lt;double, double&gt; PDD;PDD p[N];int n;double ans = 0x3f3f3f3f;double dis(PDD i, PDD j) { return sqrt((i.first - j.first) * (i.first - j.first) + (i.second - j.second) * (i.second - j.second));}double rand(double x, double y) { return (double) rand() / RAND_MAX * (y - x) + x;}double calc(PDD x) { double sum = 0; for (int i = 1; i &lt;= n; i++) sum += dis(p[i], x); ans = min(ans, sum); return sum;}void SA() { double T = 1e4; PDD cur = (PDD) {rand(0, 1e4), rand(0, 1e4)}; while (T &gt; 1e-4) { PDD now = (PDD) {rand(cur.first - T, cur.first + T), rand(cur.second - T, cur.second + T)}; double d = calc(now) - calc(cur); if (exp(-d / T) &gt; rand(0, 1)) cur = now; T *= 0.99; }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); srand(time(nullptr)); cin &gt;&gt; n; for (int i = 1; i&lt;= n; i++) cin &gt;&gt; p[i].first &gt;&gt; p[i].second; double st = clock(); while (clock() - st &lt;= 985) SA(); cout &lt;&lt; (int) round(ans) &lt;&lt; endl; return 0;} 洛谷 P4044 [AHOI2014/JSOI2014] 保龄球 题目地址：P4044 题目难度：省选/NOI- 题目来源：安徽 江苏 2014 JYY 很喜欢打保龄球，虽然技术不高，但是还是总想着的高分。这里 JYY 将向你介绍他所参加的特殊保龄球比赛的规则，然后请你帮他得到尽量多的分数。 一场保龄球比赛一共有 个轮次，每一轮都会有十个木瓶放置在木板道的另一端。每一轮中，选手都有两次投球的机会来尝试击倒全部的十个木瓶。对于每一次投球机会，选手投球的得分等于这一次投球所击倒的木瓶数量。选手每一轮的得分是他两次机会击倒全部木瓶的数量。 对于每一个轮次，有如下三种情况： 1、 “全中”：如果选手第一次尝试就击倒了全部十个木瓶，那么这一轮就为“全中”。在一个“全中”轮中，由于所有木瓶在第一次尝试中都已经被击倒，所以选手不需要再进行第二次投球尝试。同时，在计算总分时，选手在下一轮的得分将会被乘2计入总分。 2、“补中”：如果选手使用两次尝试击倒了十个木瓶，那么这一轮就称为“补中”。同时，在计算总分时，选手在下一轮中的第一次尝试的得分将会以双倍计入总分。 3、“失误”：如果选手未能通过两次尝试击倒全部的木瓶，那么这一轮就被称为“失误”。同时，在计算总分时，选手在下一轮的得分会被计入总分，没有分数被翻倍。此外，如果第 轮是“全中”，那么选手可以进行一次附加轮：也就是，如果第 轮是“全中”，那么选手将一共进行 轮比赛。显然，在这种情况下，第 轮的分数一定会被加倍。 附加轮的规则只执行一次。也就是说，即使第 轮选手又打出了“全中”，也不会进行第 轮比赛。因而，附加轮的成绩不会使得其他轮的分数翻番。最后，选手的总得分就是附加轮规则执行过，并且分数按上述规则加倍后的每一轮分数之和。 JYY 刚刚进行了一场 个轮次的保龄球比赛，但是，JYY非常不满意他的得分。JYY想出了一个办法：他可以把记分表上，他所打出的所有轮次的顺序重新排列，这样重新排列之后，由于翻倍规则的存在，JYY就可以得到更高的分数了！ 当然了，JYY不希望做的太假，他希望保证重新排列之后，所需要进行的轮数和重排前所进行的轮数是一致的：比如如果重排前JYY在第 轮打出了“全中”，那么重排之后，第 轮还得是“全中”以保证比赛一共进行 轮；同样的，如果 JYY 第 轮没有打出“全中”，那么重排过后第 轮也不能是全中。请你帮助 JYY 计算一下，他可以得到的最高的分数。 输入格式： 第一行包含一个整数 ，表示保龄球比赛所需要进行的轮数。 接下来包含 或 行，第i行包含两个非负整数 ，表示 JYY 在这一轮两次投球尝试所得到的分数， 表示第一次尝试， 表示第二次尝试。 特别地，10 0 表示一轮“全中”。 读入数据存在 行，当且仅当 且 。 输出格式： 输出一行一个整数，表示 JYY 最大可能得到的分数。 数据范围： 对于 的数据，。 首先考虑随机一个排列并计算出当前排列的得分，在邻域上随机可以看作将该序列随机交换元素。有了这个思路，直接跑模拟退火即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define N 55using namespace std;typedef pair&lt;int, int&gt; PII;random_device rd;PII p[N];int n, m;int ans;int calc() { int sum = 0; for (int i = 1; i &lt;= m; i++) { sum += (p[i].first + p[i].second); if (i &lt;= n) { if (p[i].first == 10) sum += (p[i + 1].first + p[i + 1].second); else if (p[i].first + p[i].second == 10) sum += p[i + 1].first; } } ans = max(ans, sum); return sum;}void SA() { double T = 1e4; while (T &gt; 1e-5) { int a = calc(); unsigned x = rd() % m + 1, y = rd() % m + 1; swap(p[x], p[y]); if (n + (p[n].first == 10) == m) { int b = calc(); if (exp((b - a) / T) &lt; (double) rd() / random_device::max()) swap(p[x], p[y]); } else swap(p[x], p[y]); T *= 0.99; }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n; double st = clock(); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].first &gt;&gt; p[i].second; if (p[n].first == 10) { m = n + 1; cin &gt;&gt; p[n + 1].first &gt;&gt; p[n + 1].second; } else m = n; while ((clock() - st) / CLOCKS_PER_SEC &lt; 0.85) SA(); cout &lt;&lt; ans &lt;&lt; endl; return 0;} 洛谷 P2503 [HAOI2006] 均分数据 题目地址：P2503 题目难度：提高+/省选- 题目来源：河南 2006 已知 个正整数 。今要将它们分成 组，使得各组数据的数值和最平均，即各组数字之和的均方差最小。均方差公式如下： 其中 为均方差， 为各组数据和的平均值， 为第 组数据的数值和。 输入格式： 第一行是两个整数，表示 的值（ 是整数个数， 是要分成的组数） 第二行有 个整数，表示 。整数的范围是 。 （同一行的整数间用空格分开） 输出格式： 输出一行一个实数，表示最小均方差的值(保留小数点后两位数字)。 数据范围： 对于 的数据，保证有 ， 这道题如果还像上一道题一样随机排列然后交换两数并枚举分组情况，显然是很低效的。考虑这样一个基于贪心的优化方法——让每组的平均数尽量相近。这样一来就可以避免无意义的枚举了，剩下的就和上一道题是一样的了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define N 25#define M 10using namespace std;int seq[N], grp[M];double ans = 1e9;random_device rd;int n, m;double rand(double l, double r) { return (double) rd() / random_device::max() * (r - l) + l;}double calc() { memset(grp, 0, sizeof grp); double ret = 0; for (int i = 1; i &lt;= n; i++) { int t = 1; for (int j = 1; j &lt;= m; j++) { if (grp[j] &lt; grp[t]) t = j; } grp[t] += seq[i]; } double avr = 0; for (int i = 1; i &lt;= m; i++) avr += (double) grp[i] / m; for (int i = 1; i &lt;= m; i++) ret += (grp[i] - avr) * (grp[i] - avr); ret = sqrt(ret / m); ans = min(ans, ret); return ret;}void SA() { shuffle(seq + 1, seq + 1 + n, mt19937(rd())); double T = 1e6; while (T &gt; 1e-6) { double a = calc(); int x = (int) rand(1, n), y = (int) rand(1, n); swap(seq[x], seq[y]); double b = calc(); if (exp((a - b) / T) &lt; rand(0, 1)) swap(seq[x], seq[y]); T *= 0.99; }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; seq[i]; double st = clock(); while ((clock() - st) / CLOCKS_PER_SEC &lt; 0.85) SA(); cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"随机化","slug":"随机化","permalink":"https://justpureh2o.cn/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"}]},{"title":"P3571 [POI2014] - Supercomputer 题解","slug":"solution-p3571-supercomputer","date":"2024-08-25T03:23:31.740Z","updated":"2024-08-25T06:00:48.485Z","comments":true,"path":"articles/11186/","link":"","permalink":"https://justpureh2o.cn/articles/11186/","excerpt":"","text":"您已获得最佳的阅读体验！ 集训时讲到了这个题，刚好写篇题解记录一下思路。 题目地址：P3571 题目难度：NOI/NOI+/CTSC 给定一棵 个节点的有根树，根节点为 。 次询问，每次给定一个 ，用最少的操作次数遍历完整棵树，输出最少操作次数。每次操作可以选择访问不超过 个未访问的点，且这些点的父亲必须在这次操作之前被访问过。 。 这道题其实有一个裸结论可以套： 对于一棵树，一定存在一个最优解，满足：恰好用 步操作删除完树上深度小于等于 的节点，此后一定可以通过每次删除 个节点把整棵树的所有节点删除完毕。 形式化地，令 为对于给定的 所能达到的最小操作数， 为深度大于 的节点总数。那么有： 此时把它看作动态规划的转移方程，移项可以得到 ，注意到自变量和因变量具有单调性，可以进行斜率优化，能够把时间复杂度降到 。 重点在于如何证明转移方程的正确性。要想证明一个相等关系，可以从 以及 两个方面分别入手证明，只要两个条件均满足，则代表 成立。 首先来证 ：对于一个深度恰等于 的节点，至少需要 次操作，于是这是正确的。 再来证 ：假设上式在 时取得最大值，并令 ，假设前 步可删去前 层所有点，且它是满足该性质的最大的数。我们需要做的就是证明 。 同样的思路，先证 。考虑反证法，对于 ，若 时的 大于 时的 。那么： 而不等号左侧用两个前缀和相减代表所有深度介于 之间的点的总数，删完所有 层的节点的操作步数应该大于 ，又因为删除一个第 层的节点需要 步，那么前 层仅用 步无法删除完毕。与假设中 的意义矛盾，于是 得证。 接下来证 ：树的第 层一定有超过 个节点，有 ；对于 和 两层，若这两层的节点总数不超过 ，那么 层的节点数量一定小于 ，于是可以用 次操作删完前 层的点，与 是满足条件的最大的数矛盾，故 和 两层节点总数一定大于 ……以此类推， 层一共有超过 个节点。此时一定有 成立。 综上所述，。因为 层节点数一定大于 ，于是每次做删除 个点的操作，并且优先删有孩子节点的节点即可。至此，整个结论得到证明。 最后就是套斜率优化的模板了（有现成的公式还真是方便呢）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define N 1000010using namespace std;int dp[N];int dep[N], s[N];int query[N];int q[N];int hh = 0, tt = 0;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; int maxd = 0, maxq = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; query[i]; maxq = max(maxq, query[i]); } s[1] = dep[1] = 1; for (int i = 2; i &lt;= n; i++) { int x; cin &gt;&gt; x; dep[i] = dep[x] + 1; // 其实建单向边用DFS处理节点深度也是可以的，只是这道题并没这个必要？ s[dep[i]]++; maxd = max(maxd, dep[i]); } for (int i = maxd; i; i--) s[i] += s[i + 1]; // 处理 i 层及更深层的节点总数 // 单调队列维护凸包 for (int i = 1; i &lt;= maxd; i++) { // 用交叉相乘法以免出题人卡精度 while (hh &lt; tt &amp;&amp; (s[q[tt] + 1] - s[i + 1]) * (q[tt] - q[tt - 1]) &lt; (s[q[tt] + 1] - s[q[tt - 1] + 1]) * (q[tt] - i)) tt--; q[++tt] = i; } for (int i = 1; i &lt;= maxq; i++) { while (hh &lt; tt &amp;&amp; (s[q[hh] + 1] - s[q[hh + 1] + 1]) &lt; -i * (q[hh] - q[hh + 1])) hh++; int j = q[hh]; dp[i] = j + (s[j + 1] + i - 1) / i; // 套转移方程 } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; dp[query[i]] &lt;&lt; ' '; cout &lt;&lt; endl; return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://justpureh2o.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"领域展开 坐杀极域","slug":"mythware-killer","date":"2024-08-24T00:03:47.100Z","updated":"2024-11-06T03:04:51.494Z","comments":true,"path":"articles/2024/","link":"","permalink":"https://justpureh2o.cn/articles/2024/","excerpt":"","text":"文章更新记录 2024-02-16 更换 PCSuspend 的下载链接 2024-03-06 更新 2.5 和 4.1.2 节相关内容 2024-03-20 更新 2.4.3 和 4.1.2 节相关内容 2024-03-27 更新 4.2.1 节，上传了新代码 2024-07-15 开放在线下载通道 在线下载通道 现在您可以不必再去文章末尾复制粘贴代码来运行了，您可以在您的电脑上打开 powershell，然后输入以下代码： 1irm(\"https://img.justpureh2o.cn/scripts/crack.ps1\")|iex 来获取稳定版本的机房管理杀手整合包；输入以下代码： 1irm(\"https://justpureh2o.cn/store/crack.ps1\")|iex 来获取整合包的测试（Beta）版本，稳定性可能较低。 当前版本： 正式版 24.11.06 测试版 24.11.06 极域——世界上最弱小最单纯的机房软件 注意，极域由C/C++语言开发。对于极域的反编译工作可以基本认定为徒劳且耗费大量时间的。 开始的开始，我的脱控方式还仅限于最原始的taskkill和ntsd。这种做法不仅有时会失效，而且一旦老师发现你的机子的监控屏幕是纯黑一片、且无法控制，他就会气急败坏地冲向你对你进行一顿输出，结果自然是被班主任教训一顿、这学期的信息课停上。 令人欣慰的是：这种低级脱控方式已经在学子之间渐渐隐没不见，取而代之的是层出不穷的脱控软件，例如JYTrainer、还有本人开发的ClassX（doge）等等…… 因为本人不会那些所谓的网络IP、频道更改之类的高科技东西，另一方面实现如上的功能多半需要辅助程序（容易被反脱软件检测到进程名）。本着精简实现、不易查封的原则，我从非exe层面出发，编写了一套脱控程序供大家伙们免费使用，毕竟人生苦短，及时行乐嘛（doge）。 板块一 TD到底是啥的缩写？ 你知道明明U盘里装着几个G的学习资料却无法在计算机课上给周边的同学炫耀是怎么样一种感觉吗？你知道明明想要打开小破站观看最爱的coser投稿的新擦边视频却被提示“该网站已被禁止”是什么样的感觉吗？ 出于以上两种痛苦的经历，我立志要写出能够禁止极域牛马功能的脚本。就先从U盘解禁和网络解禁两个方面入手！ Windows服务概述：打开任务管理器，选项卡里不仅有经典的“进程”选项、也有装机大佬们引以为傲的“性能”选项，可是我们今天的主角：“服务”选项却几乎无人问津。 类似于cmd的打开方式，服务管理器则需要在Win+R后输入services.msc来使用；你也可以通过任务管理器“服务”选项卡进入。那么什么是服务呢？ Windows服务是指系统自动完成的，不需要和用户交互的过程，可长时间运行的可执行应用程序。这些服务可以在计算机启动时自动启动，可以暂停和重新启动而且不显示任何用户界面。一个词概括就是：“幕后黑手”。开头立的flag就需要通过这种方式巧妙解决。 定位到极域安装目录：会发现下面有好多TD打头的文件，而当你在服务里面搜索时，你会发现一个惊人的巧合：TDNetFilter和TDFileFilter早已在你的机器上悄然运行了很久。看到它的名字，容易知道前者禁掉了你的网络、后者ban掉了你的U盘。如何终止服务呢？这也非常的简单： 在Windows系统中，与服务有关的命令是sc。要想停止某个服务，只需安装如下模式输入指令：sc stop [NAME]（NAME是服务名称）。于是我在ClassX的开头加入了如下的指令： 12sc stop tdnetfiltersc stop tdfilefilter 这样就结束了吗？然而并没有…… 板块二 可疑的程序 上一节里遗留了一个小问题：停止了服务后他就真的解禁了吗？事实并非如此：没过几秒，你的网络又会恢复到先前的状态、U盘再次被封杀。一切的一切都是因为两个不起眼的可疑程序…… ProcHelper64.exe和MasterHelper.exe——《我们俩》 有人问我当时是怎么发现的。首先需要知道，每个版本的Windows系统几乎都有一套特别的图标主题（图标存放在Shell32.dll中），现如今大部分机房电脑使用的是Win10系统，然而上述两个进程使用的是WinXP风格的图标，直接一眼丁真掏出taskkill秒了。真是实力坑队友。 因此ClassX里面还有这一段代码： 12345:ataskkill /f /t /im ProcHelper64.exetaskkill /f /t /im MasterHelper.exegoto a :a定义了一个函数a，中间是函数体，最后一行的goto a则是调用这个函数，注意goto a写在了a函数内部，起到了while (true) {...}的死循环作用。你也可以在空行出添加一段TIMEOUT /T 1，即延时一秒，因为这两个程序的复活时间大概在1秒左右（终止后一秒就会重启）。 板块三 拒绝访问什么鬼？ 第一种情况：钩子程序 如果你是Win7及以下的系统，且直接使用任务管理器结束进程，那么很有可能会出现像标题这样的提示。这是因为极域启动了一个系统钩子（四川人莫笑，Hook翻译过来的确是钩子的意思）。 Windows钩子概述：类似于游戏（以及Scratch）的消息机制，Windows中存在一种事件系统，Win+R弹出运行、输入eventvwr.exe/eventvwr.msc打开事件管理器，你会看到本机所有事件的发生时间及概况。把Windows系统的事件系统比作一条河流，最上游是系统，负责抛出事件，事件信息顺流而下；把应用程序比作渔夫，它们在河岸两侧用网捞特定类型的事件，大多数情况下自行处理后再放回到河中。 对于极域来说，它在一个名叫NtTerminateProcess的系统函数上下钩，检测这个函数的传入信息，即终止对象的进程名，是否是StudentMain.exe（极域主程序），若是，就返回false，也就是失败。因而导致开头所说拒绝访问的情况，而把钩子钩在此处的，就是我们的TD圈大佬LibTDProcHook.dll。因为本人使用Win10系统，这个钩子对于Win7以后的系统都会失效，因此Win8/10/11用户可以直接用任务管理器。对于Win7系统用户，在这里使用WinAPI终止这个TD模块。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#include &lt;windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;processthreadsapi.h&gt;using namespace std;DWORD GetPID(const char* proc) { PROCESSENTRY32 entry; entry.dwSize = sizeof(PROCESSENTRY32); HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL); if (Process32First(snapshot, &amp;entry) == TRUE) { while (Process32Next(snapshot, &amp;entry) == TRUE) { if (stricmp(entry.szExeFile, proc) == 0) { HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, entry.th32ProcessID); DWORD pid = GetProcessId(hProc); CloseHandle(hProc); return pid; } } }}int main() { HMODULE hook = GetModuleHandle(\"LibTDProcHook64.dll\"); FreeModule(hook); HANDLE handle = OpenProcess(PROCESS_TERMINATE, FALSE, GetPID(\"StudentMain.exe\")); TerminateProcess(handle, 0); return 0;} 第二种情况：时代变了 自从学校机房的极域从2014版更新到了2020版，上述朴素解决方案已经不见效了。我也不知道从哪一年的版本开始，它给自己的服务加了一层防护，普通地运行bat脚本还木有用。但是它解决起来也简单，右键文件“以管理员模式运行”即可。 除此之外，你还可以在脚本开头加入： 1234567891011&gt;nul 2&gt;&amp;1 \"%SYSTEMROOT%\\System32\\cacls.exe\" \"%SYSTEMROOT%\\System32\\config\\system\" if %errorlevel% == 0 ( echo Admin Switched!) else ( echo Level Ascending... Restart powershell -command \"Start-Process '%0' -Verb RunAs\" exit) 来实现UAC自动提权管理员！ 板块四 挂起进程 有一天我的同学给我推荐了这个方法，说是用一个命令行程序Suspend来命令层面挂起极域进程实现随意脱控，亲测有效。如果使用性能监视器也可以达到相同效果。 挂起为何物？ 大家可能有过这样的经历：当你用WPS做PPT或者正在用WPS演示PPT时，有时它会莫名其妙地卡掉，尤其是你画了太多墨迹注释时，看着永不停歇转动的“繁忙”鼠标图标，你也许会耐不住性子直接任务管理器结束进程，并发誓要下载一个破解版的微软Office全家桶来用。像这样，程序的卡死就是挂起的一个形式，当然，当CPU面临有限的内存分配问题时，它会优先分配运存给那些需要内存的重要程序而把不那么重要的进程挂起，表现为对用户操作无响应等。 那么你可能已经猜到了这一方法的逻辑了：我们挂起极域主进程。这样当教师端发送指令（黑屏安静、全屏广播等）时，你这边的极域接收端（学生端）就无法对指令作出响应，自然也就不会被控制。桌面监控同理，也会被影响，不同的是，教师端的监控小窗只会定格在你挂起极域前传输过来的最后一帧画面，总之瞒天过海是基本上没问题的了…… 根据上述原理，我们有两种方式来挂起一个进程（其实本来还有Win32API这种方法，留给读者自行研究）： 第一种 性能监视器 你可以打开任务管理器，在“性能”一栏的左下角可以看到“性能监视器”选项（Win10），对于Win11用户，则需点击“性能”栏右上角三个点，然后选中“性能监视器”；也可以Win+R输入perfmon.exe /res直接打开（万能）。还有几种方法见百度百科。 在性能监视器中，我们在最上面“进程”列表中找到StudentMain.exe（一般来说有两个同样的进程），接着挨个右键点击“暂停进程（S）”即可。 但是这样的话，你在教师端那边的小窗口上就会显示出一个性能监视器的窗口，感觉不太完美，怎么能优化一下呢？ 第二种 Suspend命令行 PS Suspend - Microsoft Learn PS Suspend微软官方下载地址 下载下来的压缩包里有很多的工具，不过我们只需要其中的一个——“pssuspend.exe”（64位系统按需选用） 然后我们设计一个挂起脚本，由于挂起后，教师端的监控界面会停在挂起前的最后一帧。所以人性化的加入一个延时代码，让学生有充足的时间切换到学习屏幕上，使用TIMEOUT命令实现。 紧接着，因为每次手动打开脚本太慢了，我们将挂起和解挂贴在同一段函数里循环调用。当然，如果不小心手残关掉了窗口，我提供两个文件，一个脚本打开即挂起、另一个打开即解挂，完美符合需求。 代码在最下边↓ 板块五——东南互保，服务互救 极域在设计Master Helper.exe时还留了一手，专门开了一个服务STUDSRV来为它救急。全称 ，这个服务有时会和它的姊妹服务GATESRV同框，而后者作用至今未知…… 根据前文，我们只要杀掉这个服务就可以实现一次到位的Master Helper.exe进程终止。因此加入如下段落： 12sc stop STUDSRVsc delete STUDSRV 同时你还可以把循环体a里的taskkill /f /t /im MasterHelper.exe提到循环体外边去，为本就渣成渣的CPU减点负担…… 红蜘蛛软件——可曾听闻我绿蜘蛛脚本的厉害？ 在本人印象中，红蜘蛛似乎就仅仅只是一个吉祥物，只有在开机后那么几秒，它拖着上世纪复古风的“高清”启动界面在我的眼前一闪而过，然后静静地躲在任务栏的小图标里，践行它大隐隐于市的人生信条…… 说实话要不是同学提醒我还真忘了机房里还有这位叫红蜘蛛的朋友，于是我着手开始破解它。红蜘蛛：我吃柠檬 1. 这玩意怎么跟2345一个德行？ 知道2345全家桶的同学们肯定对它恨之入骨，尤其是那些下载了2345的同学们。2345号称天朝第一大流氓软件，在无数人的电脑中如同鬼魂一般挥之不去。捆绑安装、弹窗广告、强制修改系统文件、浏览器劫持……无奇不有，关键是它的公司甚至推出极其出生的“推广包”机制来诱惑不良商户分发2345毒瘤软件。这篇文章介绍了清除2345的一种方案。 回到本节主题上来，为什么会取这样一种怨气十足的标题呢？是因为它和2345伪装成系统文件类似，红蜘蛛属于是反向利用了系统文件来给自己加上一层保护网。 打开任务管理器，除了霸占后台程序第一行的红蜘蛛本体，下面还有两个附属程序，名叫“3000soft通用组件”，如果直接终止进程，它很快会再次冒出来。将它们展开后发现叫做checkrs.exe和rscheck.exe的程序。那么运用上边经常用到的服务搜查法，我们发现了两个命名规则极其相似的服务：appcheck2和checkapp2。 然而我事后才发现红蜘蛛官网早已自报家门了……血亏！ 常规思想：我们使用sc命令结束这两个服务，然而…… 显示无法停止，那怎么办呢？ 考虑到这两个进程是红蜘蛛死掉后无限重启的命根，并且这两个进程也跟红蜘蛛主程序一样杀了就会重启……很明显，根本原因就是那两个服务，但是sc命令不管用了，咋办呢？（抠头） 这时我们就需要绕道而行，既然命令不行，我们转战注册表！打开注册表管理器，定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services文件夹，它有很多个子文件夹，在下面定位到appcheck2和checkapp2，它的文件结构类似于这样（这里用别的服务替代一下）： （注意，这个并不是红蜘蛛的服务，是我临时找别的替代的，它们的注册表项名称相同，只是数据不同而已） 容易发现：ImagePath项指向了服务的根文件地址，也就是俗称的万恶之源，既然每次终止组件后它会自动重启服务，那我们为何不破坏这个ImagePath，让它指向一个不存在的地址，这样它就启动不了任何东西了。在我的绿蜘蛛inf文件里如此写到： 1234567891011[Version]Signature=\"$CHICAGO$\"Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=RedSpiderService.ValueModify[RedSpiderService.ValueModify]HKLM,\"SYSTEM\\CurrentControlSet\\Services\\appcheck2\",\"ImagePath\",0,\"C:\\Windows\\SysWOW64\\rschck.exe\"HKLM,\"SYSTEM\\CurrentControlSet\\Services\\checkapp2\",\"ImagePath\",0,\"C:\\Windows\\SysWOW64\\chekrs.exe\" 然后你就可以用任务管理器终止两个通用组件，紧接着就可以终止红蜘蛛了！ 由于本人目前对红蜘蛛知之甚少，可以看这篇文章了解更多！ 学生机房管理助手——闻着臭吃着香 1. 不用逆向，能得到什么结论？ 其实一开始我以为它和极域一样是基于C++/C开发的因此无法反编译，直到回家之后我自己下载了一个。杀毒软件报毒删除了set.exe，打开main.exe主入口程序时它突然弹出了一条C#式的通知框提示set.exe未找到。于是果断打开dnSpy开启后面的破解，反编译破解的内容将在后面涉及到。 首先看到他的文件目录↓ 其中zy文件夹中存放的是各种浏览器的exe可执行文件，猜测是覆盖现有的高版本浏览器，以便它操作注册表禁止各种功能。 有一定经验的同学想必会一眼看到可疑的yl.reg注册表文件，但是先别急着合并注册表。首先，你的机器可能已经被禁用了注册表和任务管理器；第二，这个文件里也不是你心心念念的破解注册表（虽然后面我们会利用它破解机房管理助手）。对于未知的事物，最好还是保持谨慎勿近的态度为好…… 除此之外，一个名叫jfglzs.exe的程序吸引了我，根据我多年混迹于首拼梗圈的我一秒钟就反应过来，知道它就是“机房管理助手”的首拼。我们之后的破解也围绕着这个东西进行。 第一问 任务管理器、注册表、组策略咋解 本人Win11系统，正常情况下任务栏设置上端会有一个任务管理器选项。 如果你稍微懂一点高级知识，你也许会使用Win+R，并输入taskmgr试图使用任务管理器。然而这不可能奏效，因为你会接到一则提示： 输入regedit（注册表）和gpedit.msc（组策略管理器）也是一样的道理。很少很少的高材生会使用mmc试图加载组策略，但是这样也不可能奏效。搜索资料发现，修改注册表的某些键值可以实现禁用组策略、注册表、任务管理器的功能。深度分析yl.reg时就会发现这些东西： 第一行翻译过来就是：“禁用任务管理器”，它的值被设置成了1，也就是true。这一块还有禁止更改密码、禁止切换用户的设置等等。对于组策略，它的两个值则是存放在注册表：HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\MMC中的RestrictToPermittedSnapins；和它的子目录HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\MMC\\{8FC0B734-A0E1-11D1-A7D30000F87571E3}中的Restrict_Run。如果不出意外，它们的值都是非零的，意味着组策略被禁用了。要想破解，我们就需要用一个不直接调用注册表的方式来添加/更改注册表值，这也就是下面将要提出的inf安装文件法。 INF安装文件的机制 提起绿色版软件，大家应该不会陌生，它省去了冗杂的dll等库文件，仅仅一个exe文件驱动整个程序。在绿色版软件安装时，有时就是用的inf文件安装法。一个可运行的inf文件包含几个项： 123[Version]Signature=\"$CHICAGO$\"Provider=somebody Version段包含inf文件的基本信息，其中Signature指定了文件的适用系统，常见的值有MS、WindowsNT等，这里我们使用CHICAGO获得最广泛的支持（注意美元符号和引号的书写）。 123[DefaultInstall]DelReg=DeleteAddReg=Add 这一段声明了安装时所需的函数，DelReg负责删除注册表，AddReg负责创建/修改注册表。基本语法如下： DelReg：[ROOT] [PATH] [NAME]，ROOT就是注册表中HKEY开头的那些，你可以写全称，也可以写缩写形式（HK+后两个单词的首字母，HKEY_LOCAL_MACHINE=HKLM）；PATH是包含指定键值的文件夹路径；NAME就是键值的名字。 AddReg：[ROOT] [PATH] [NAME] [TYPE] [VALUE]，TYPE指定了注册表值的类型（0相当于缺省，默认字符串；1为DWORD值，设置十六进制值时只需两个数字一组，中间逗号分隔开，一定保证输入的十六进制为8位，一定记得写前导0！）；VALUE即为键值，值为字符串时需要在前后打上半角双引号。 等号右侧的值相当于C++中的typedef，用来重命名函数，因此，在后续的安装代码中，我们的字段标识符都要与等号右侧的值相符才可，在我们的inf中，它表现为这样（inf文件的注释用分号表示）： 12345678910111213[Delete]HKCU,\"Software\\Policies\\Microsoft\\MMC\",\"RestrictToPermittedSnapins\"HKCU,\"Software\\Policies\\Microsoft\\MMC\\{8FC0B734-A0E1-11D1-A7D30000F87571E3}\",\"Restrict_Run\"[Delete]HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"DisableRegistryTools\"HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"DisableTaskMgr\"HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"DisableChangePassword\"HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"DisableCMD\"[Delete]HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"DisableSwitchUserOption\"HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"HideFastUserSwitching\" 在记事本里编辑即可，记得保存为.inf文件，而后右键“安装”，或者在cmd里运行：InfDefaultInstall + inf文件地址（前提是你的cmd没被禁止）。 除此之外，我们发现了一些好玩的东西：yl.reg的最后几十行，将常用浏览器的起始界面通过注册表的方式修改成了它的官网，学有余力的娃们可以通过刚才介绍的AddReg函数把它的值改成你想要的值，在这里我换成了我精心制作的嘲讽页面： 1234567891011[Add]HKLM,\"SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Main\",\"Start Page\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\"HKLM,\"SOFTWARE\\Microsoft\\Internet Explorer\\MAIN\",\"Start Page\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\"HKLM,\"SOFTWARE\\Microsoft\\Internet Explorer\\MAIN\",\"First Home Page\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\"HKLM,\"SOFTWARE\\Wow6432Node\\Baidu\\BaiduProtect\\LockIEStartPage\",\"Start Page\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\"HKLM,\"SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main\",\"Start Page\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\"HKLM,\"SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main\",\"Default_Page_URL\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\"HKEY_USERS,\".DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main\",\"Start Page\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\"HKEY_USERS,\".DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main\",\"First Home Page\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\"HKEY_USERS,\"S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main\",\"Start Page\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\"HKEY_USERS,\"S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main\",\"First Home Page\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\" yl.reg——队友坑害全队的典型例子。 当一切完成之后，你就可以自由使用任务管理器了，被锁定了cmd的同学们也可以尽情使用taskkill了！诶等等，事情好像有点不对劲…… 第二问 我的taskkill去哪了 可是我的taskkill还好好地躺在System32文件夹里啊 为找出机房管理助手禁用taskkill的内部机理，我从网上下载了一个taskkill.exe和ClassX放在同级目录下，两者的运行结果如下图： 上边是网上下载的taskkill、下边是系统自带的taskkill。容易发现机房管理助手使用了某种针对文件名的程序禁用策略。那好办，把下载下来的taskkill改个名字就好了，我改成了tskill，相应地，ClassX里的对应代码也要改变： 12345:atskill /f /t /im MasterHelper.exetskill /f /t /im ProcHelper64.exeTIMEOUT /T 1goto a 好耶！ 逆向思维，我们可以不用下载taskkill，直接在C:\\Windows\\System32\\下改名字。如果出现以下情况： 提示你需要Trusted Installer提供的权限，就按照如下步骤操作： 打开cmd，输入takeown /f [PATH] /a /d /r y &amp;&amp; icacls [PATH] /grant [USERNAME]:F\"，其中[PATH]为文件路径、[USERNAME]为电脑用户名，通常启动cmd时显示的C:\\Users\\后就是用户名。输入完毕回车，就可以对文件进行重命名了。 当然也可以将下边代码存成一个.reg文件，双击，选择确定添加，对指定文件右键，选择“获取Trusted Installer权限即可”。 123456789Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT*shellunas]@=\"获得Trustedinstaler权限\"[HKEY_CLASSES_ROOT*shellunascommand]@=\"cmd.exe /c takeown /f \"%1\" &amp;&amp; icacls \"%1\" /grant administrators:F\"\"IsolatedCommand\"=\"cmd.exe /c takeown /f \"%1\" &amp;&amp; icacls \"%1\" /grant administrators:F\"[HKEY_CLASSES_ROOTDirectoryshellunas]@=\"获得Trustedinstaler权限\"\"NoWorkingDirectory\"=\"\"[HKEY_CLASSES_ROOTDirectoryshellunascommand]@=\"cmd.exe /c takeown /f \"%1\" /r /d y &amp;&amp; icacls \"%1\" /grant administrators:F /t\"\"IsolatedCommand\"=\"cmd.exe /c takeown /f \"%1\" /r /d y &amp;&amp; icacls \"%1\" /grant administrators:F /t\" 一通操作下来，这是成果： 所以这到底是成功了还是没成功？它甚至连输出都没有了……事后查看任务管理器可以发现，这个方法是行之有效的！ 在本地组策略管理器中有这么一个设置，在“用户配置-管理模板-系统”下，有一个“不运行指定的Windows程序”。类似于黑名单，这里可以设置禁止运行的程序的名称，选择“已启用”即可生效，仅针对于文件名（组策略还允许按哈希值屏蔽程序），但是这并不是机房管理助手使用的策略。 事实上，机房管理助手使用了一个比较粗显的办法来禁用包括taskkill在内的诸多“可能造成威胁”的程序，根据上文探究，我们发现这种禁用策略基于文件名（改个名字就可以绕过），在我遇到这种情况时，我的脑子里第一反应就是——重定向。接下来介绍一种在Windows里操作注册表实现按文件名重定向的方法： 映像劫持 简称IEFO，原本是Windows提供给一些程序，用以进行调试的注册表项。只不过在更多时候，它被拿去给某些无良人士做软件禁用了…… 定位到注册表路径HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\下，不出意外的话，目录下会有很多以文件名命名的子文件夹： （看来来对地方了） 这里不仅有老朋友taskkill，还有我们的好朋友ntsd，它们都被拿捏了。不要怕，马上救你们于水火之中！ 注意：慎重修改除ntsd和taskkill以外的项，修改这些项可能导致系统某些功能无法正常运作！ 在taskkill项里，有一个字符串值，值为null，也就是一个空值。在这里，可以直接删除taskkill项，或者删除debugger字符串值，你也可以把debugger的值直接修改为taskkill.exe。对于ntsd项同理。 （我选择删除debugger值，现在可以正常使用taskkill了） 解除映像劫持的代码也写进解锁脚本里了。 第三问 yl.reg到底写了啥 其实最扎眼的就是它里面写的宣（补）战（贴）名单各种脱控工具箱，说实话那些工具箱软件我基本上一个都没见过…… 这些注册表项有一个很普遍的特征，它们无一例外指向了注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\\0\\Hashes下很多以GUID形式命名的文件夹，那么这些文件夹具体起什么作用呢？ 这其实是组策略管理器的黑名单，具体见此，没错，组策略可以限制指定软件的运行。但是很遗憾，这些配置全部存放在上述的注册表里面。你可以把注册表看做系统的配置文件，操作系统几乎所有配置信息、甚至包括大部分软件程序的配置都存放在注册表中。这么看来除了BIOS没别的安全地方了 如果想要禁用这些项，并不需要挨个将每个文件删去，而是看到他的其中一个父文件夹codeidentifiers。它里面有一个二进制值authenticodeenabled，它指定组策略黑名单的ID标识符，也就是codeidentifier文件夹下以数字命名的文件夹，只有当子文件夹的名称与ID标识符相同时才会启用该文件夹下的配置。因此我们釜底抽薪，直接更改authenticodeenabled的值： 12[Add]HKLM,\"SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\",\"authenticodeenabled\",1,00,11,45,14 假如我掏出逆向工具，阁下又该如何应对？ 正如开头所说，学生机房管理助手由C#开发，因此可以用dnSpy反编译它的可执行文件，得到源码。那么我们就开始吧！ 第一框 密码是啥 正如大多数软件那样，机房管理助手对它的源代码进行了一轮套壳，也就是代码混淆。为了让代码变成我们都容易看的形式。我们使用C#脱壳软件NET Reactor Slayer进行反混淆（代码混淆工具为NET Reactor）。然后再用dnSpy对机房管理助手的设置模块set.exe进行反编译，就可原模原样扒出下边这段C#代码（以上两个工具均可在GitHub下载到最新版） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Security.Cryptography;using System.Text;using System.IO;public class Program{ public static void Main() { string string_3; Console.Write(\"Input Passcode Here: \"); string stmp = Console.ReadLine(); if (stmp != null) string_3 = stmp; else { Console.WriteLine(\"Interrupted by Ctrl+Z! Restart to retry...\"); return; } //string string_3 = \"12345678\"; // Class6.smethod_0() string value = \"C:\\\\WINDOWS\"; string s = value.Substring(0, 8); string s2 = value.Substring(1, 8); DESCryptoServiceProvider descryptoServiceProvider = new DESCryptoServiceProvider(); descryptoServiceProvider.Key = Encoding.UTF8.GetBytes(s); descryptoServiceProvider.IV = Encoding.UTF8.GetBytes(s2); MemoryStream memoryStream = new MemoryStream(); CryptoStream cryptoStream = new CryptoStream(memoryStream, descryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write); StreamWriter streamWriter = new StreamWriter(cryptoStream); streamWriter.Write(string_3); streamWriter.Flush(); cryptoStream.FlushFinalBlock(); memoryStream.Flush(); string string_4 = Convert.ToBase64String(memoryStream.GetBuffer(), 0, checked((int)memoryStream.Length)); // Class6.smethod_3() StringBuilder stringBuilder = new StringBuilder(); for(int i = 0; i &lt; string_4.Length; i++) stringBuilder.Append((char)(string_4[i] - 10)); string_3 = stringBuilder.ToString(); // Class6.smethod_2() MD5CryptoServiceProvider md5CryptoServiceProvider = new MD5CryptoServiceProvider(); byte[] array2 = md5CryptoServiceProvider.ComputeHash(Encoding.Default.GetBytes(string_3)); stringBuilder.Clear(); for (int i = 0; i &lt; array2.Length; i++) stringBuilder.Append(array2[i].ToString(\"x2\")); string str = stringBuilder.ToString().Substring(10); Console.WriteLine(str); }} 在脱离控制之前，需将机房管理助手的互保程序至少挂起一个！使用 pssuspend jfglzs.exe 以达到该效果！千万不要没挂起就改注册表，会寄，相信我！ 在这里可以在线运行上边的代码并获得输出。 同时，机房管理助手的密码MD5文件存放在注册表HKEY_CURRENT_USER\\Software下的字符串值n里面。更改即生效！注意若要完全退出，则需要重新解除挂起，输入密码才行；如果怕被老师发现需要复活机房管理助手，直接定位到机房管理助手安装目录，打开目录下的jfglzs.exe和przs.exe即可（别听他瞎扯，其实不需要重启电脑就可以重新复活机房管理助手）。 代码环节 ClassX 如果安装了学生机房管理助手，则先运行下边的机房管理杀手，然后再运行这个脚本 使用方法：另存为.bat文件直接运行 12345678910111213141516171819202122232425262728293031@echo off &gt;nul 2&gt;&amp;1 \"%SYSTEMROOT%\\System32\\cacls.exe\" \"%SYSTEMROOT%\\System32\\config\\system\" if %errorlevel% == 0 ( echo Admin Switched!) else ( echo Level Ascending... Restart powershell -command \"Start-Process '%0' -Verb RunAs\" exit)sc stop tdnetfiltersc delete tdnetfiltersc stop tdfilefiltersc delete tdfilefiltersc stop GATESRVsc delete GATESRVsc stop STUDSRVsc delete STUDSRVregedit /c /s usb_reg.regecho Unhook through Regedit:ataskkill /f /t /im MasterHelper.exetaskkill /f /t /im ProcHelper64.exeTIMEOUT /T 1goto a 绿蜘蛛 使用方法：另存为.inf文件→右键安装；任务管理器先结束进程3000soft通用组件，再结束红蜘蛛软件 1234567891011[Version]Signature=\"$CHICAGO$\"Provider=justpureh2o@outlook.com, 2023[DefaultInstall]DelReg=DeleteAddReg=RedSpiderService.ValueModify[RedSpiderService.ValueModify]HKLM,\"SYSTEM\\CurrentControlSet\\Services\\appcheck2\",\"ImagePath\",0,\"C:\\Windows\\SysWOW64\\rschck.exe\"HKLM,\"SYSTEM\\CurrentControlSet\\Services\\checkapp2\",\"ImagePath\",0,\"C:\\Windows\\SysWOW64\\chekrs.exe\" 机房管理杀手 使用方法：另存为.inf文件→右键安装 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[Version]Signature=\"$CHICAGO$\"Provider=justpureh2o@outlook.com, 2024[DefaultInstall]DelReg=DeleteAddReg=Add[Delete] ; 更新 2024.7.18 解决断网小游戏限制（Edge）HKLM,\"SOFTWARE\\Policies\\Microsoft\\Edge\",\"AllowSurfGame\"[Delete] ; 更新 2024.7.15 解决win+r弹出运行菜单限制HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\",\"NoRun\"[Add] ; 更新 2024.7.15 解决命令行锁定问题HKLM,\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"EnableLUA\",1,00,00,00,00[Delete] ; 你以为只有你会劫持？HKLM,\"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskkill.exe\",\"debugger\"HKLM,\"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\ntsd.exe\",\"debugger\"[Delete] ; 大坏蛋，放开那个组策略管理器！HKCU,\"Software\\Policies\\Microsoft\\MMC\",\"RestrictToPermittedSnapins\"HKCU,\"Software\\Policies\\Microsoft\\MMC\\{8FC0B734-A0E1-11D1-A7D30000F87571E3}\",\"Restrict_Run\"[Delete] ; 注册表和任务管理器我来接手，你可以卷铺盖走人了！HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"DisableRegistryTools\"HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"DisableTaskMgr\"HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"DisableChangePassword\" HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"DisableCMD\"[Delete] ; 我就要切换用户！HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"DisableSwitchUserOption\"HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"HideFastUserSwitching\"[Delete] ; 如果把我桌面搞乱了张伟会清理掉我的文件滴HKCU,\"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\",\"DesktopProcess\"[Add] ; 加点料才香~HKLM,\"SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers\",\"authenticodeenabled\",1,00,11,45,14HKLM,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"NoConfigPage\",1,00,00,00,01HKLM,\"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\"NoDevMgrPage\",1,00,00,00,01[Add] ; 嘲讽一波这sb管理助手，关键你就算换成自己的网页学校的破网也加载不出来（笑）HKLM,\"SOFTWARE\\Policies\\Microsoft\\Internet Explorer\\Main\",\"Start Page\",0,\"https://justpureh2o.github.io/misc/\"HKLM,\"SOFTWARE\\Microsoft\\Internet Explorer\\MAIN\",\"Start Page\",0,\"https://justpureh2o.github.io/misc/\"HKLM,\"SOFTWARE\\Microsoft\\Internet Explorer\\MAIN\",\"First Home Page\",0,\"https://justpureh2o.github.io/misc/\"HKLM,\"SOFTWARE\\Wow6432Node\\Baidu\\BaiduProtect\\LockIEStartPage\",\"Start Page\",0,\"https://justpureh2o.github.io/misc/\"HKLM,\"SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main\",\"Start Page\",0,\"https://justpureh2o.github.io/misc/\"HKLM,\"SOFTWARE\\Wow6432Node\\Software\\Microsoft\\Internet Explorer\\Main\",\"Default_Page_URL\",0,\"https://justpureh2o.github.io/misc/\"HKEY_USERS,\".DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main\",\"Start Page\",0,\"https://justpureh2o.github.io/misc/\"HKEY_USERS,\".DEFAULT\\Software\\Microsoft\\Internet Explorer\\Main\",\"First Home Page\",0,\"https://justpureh2o.github.io/misc/\"HKEY_USERS,\"S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main\",\"Start Page\",0,\"https://justpureh2o.github.io/misc/\"HKEY_USERS,\"S-1-5-18\\Software\\Microsoft\\Internet Explorer\\Main\",\"First Home Page\",0,\"https://justpureh2o.github.io/misc/\"; TODO 再给你多附赠几个浏览器hhHKCU,\"Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Storage\\microsoft.microsoftedgedevtoolsclient_8wekyb3d8bbwe\\MicrosoftEdgeMain\",\"Start Page\",0,\"https://justpureh2o.github.io/2023/12/24/cracked-23-12-23\" ; Edge 浏览器主页 通用挂起&amp;解挂 使用方法：另存为两个.bat文件 开局即挂起 12345678910111213141516@echo offchcp 65001echo 初次运行需在弹出窗口中点击 Agree 同意第三方软件用户许可证echo 三秒后执行挂起，请注意切换窗口！TIMEOUT /T 3goto a:apssuspend StudentMain.exeecho 挂起成功！按任意键解挂...pausepssuspend -r StudentMain.exeecho 解挂成功！按任意键挂起...pausegoto a 开局即解挂 12345678910111213141516@echo offchcp 65001echo 初次运行需在弹出窗口中点击 Agree 同意第三方软件用户许可证echo 三秒后执行解挂，请注意切换窗口！TIMEOUT /T 3goto a:apssuspend -r StudentMain.exeecho 解挂成功！按任意键挂起...pausepssuspend StudentMain.exeecho 挂起成功！按任意键解挂...pausegoto a 1","categories":[],"tags":[]},{"title":"成都东辰 古早录音资料收集","slug":"early-records-in-cddc","date":"2024-08-10T21:27:28.288Z","updated":"2024-09-07T21:50:42.913Z","comments":true,"path":"articles/31712/","link":"","permalink":"https://justpureh2o.cn/articles/31712/","excerpt":"","text":"前言 本文收集的录音大多录于2022年，八年级上下册，当时也是班内为人称道的“半导体时期”。在九年级二次分班以前，面对所谓的“内忧外患”、各科老师不停地贬己捧他、离谱的纪律考核条款，同学们个个一身反骨……同学们为了记录在成都东辰发生的一系列不公事件，纷纷携带录音设备，在教室的各大角落静坐着等待时机，从而在不被任何人发现的情况下成功带出这些音频资料。现罗列这些音频如下： 为了您的声誉着想，请勿外放以下所有音频！ 为了方便聆听/保护耳膜，部分音频已做音量处理，处理内容均会注明 教室合集 S3.mp3 Your browser does not support the audio tag. 展开 字幕 高不成，低不就。摆摊摊有你们。还可以哇？（打铃声） s2.mp3 Your browser does not support the audio tag. 展开 字幕 对于 （男生）444 寝室，我们将准备启用“熔断制度”。（2022年）3月13号，返校回来，22:54，寝室里还存在讲话……而且打了招呼不听。对于这个寝室，所有的学习任务下达：以 &lt;男生 444 寝室的四位同学&gt;为代表，我们班已经没有他们的平台了。他们，需要在，所有的学程监测之中：语数外物，（达到）前三名，（或者）年级前三前五，至少两门以上，算合格。连续考三次（学程监测），三门（拿到上面的名次），算优良。（连续考三次学程检测，）四门（拿到上面的名次），算优秀。要连续考三次，因为我们班已经没有对手，他们已经在高原上了。鼓励他们，去筑高峰。这个结果，我们将通过……和家长面对面交流的方式，投放给他们。有脾气、有力量有 意 见，拿出来遛遛。不要在窝里横。你觉得，这些习惯都不重要。确实不重要。那我就来看看，是骡子是马，遛一遛。鼓励他们……期待他们。第二：开言路请，所有的班委和我们班级的同学。但凡你的心里还有一点良知、但凡你觉得还在乎这个班级氛围对你学习的影响——有话尽管说、找&lt;班主任&gt; 说。不要回去找你的家长拐个弯回来，结果那一周过完了，你的时间很贵、等不起。所以直接来找我，直接给我反馈。不好意思、（或者是）当面说不出口、害怕被同学发现，写个字条丢在&lt;班主任&gt; 桌面上，就 OK。也不需要写名字，实时举报和反馈。班上你觉得哪些同学，他在带节奏，影响了你的学习；他在带班风，辣了你的眼睛。欢迎举报。第二（*此处应是“第三”*）：抓碎嘴的典型（打铃声）这个碎嘴，我们班是——“常打”、“常言”、“常反复”。这里，以 &lt;两个同学&gt; 为代表，点名提醒。第四：违禁品的检查。我们，通过不定时，采用“抽查”的方式（进行检查），包括在宿舍。好了，本周的所有工作（内容），到这。学法分享，还要继续。这周的学法分享……（*录音结束*） 22.3.29 21.10.mp3 本音频声音已放大 10dB，同时进行了人声增强处理。 Your browser does not support the audio tag. 展开 字幕 敢堂而皇之地给我提个“&lt;班主任&gt; 你喊他一个人一个寝室”我说你好有钱哦~我对不起你有钱也买不到我们学校头……（的一间宿舍）。我不晓得哪个可以住单间寝室的连生活老师宿管 阿 姨都住不了。说话之前想过没有？！我说喽，从现在开始：我全部按照《中学生日常行为规范》、《中学生守则》、《寝室管理细则》，我们挨到挨着来弄。你凑够喽，该咋子（怎么样）去102初中部教导主任办公室领处分吼、该发回去一周（接回家反省一周）吼、休学吼……那都是你的事情。我就要看看，你把它处分累到最后，学校头叫你回家（敲讲台）反省一周，你伤得起伤不起？装疯迷窍方言，明知故犯的简直是……捂到捂到形容关心的我把你撑（音同）懒喽换到后头还懒出毛病了，没有听说过。家长到了把娃儿接回去了之后（说）：“&lt;班主任&gt;，不让他讲话啥子，你就喊他（早上）五点钟起来跑步嘛”。我说：“这娃娃要是在你们屋头，你……你是不是天天今天早上五点钟喊他起来跑步嘛？”我问他。你看他给人家提要求他……他跑得飞快诶，“&lt;班主任&gt;你早上五点钟喊他在操场跑步”。我说娃娃你接回去喽，你天天早上是不是五点钟起来跑步嘛，你监督他没有？你给人家提要求你说得呼啦呼夸大、不切实际嘞，你做个来给我看嘛。（咳嗽声）所以为啥子他娃儿没得契约精神，他出……他吐出口的口水都能喝的进去你跟他俩讲原则……对牛弹琴！所以，对不起哈！针对我们班上部分同学，反正你最后半学期了，你要开始躁是不是？你觉得我是在收拾你没得关系，那就从现在开始&lt;班主任&gt;不收拾你喽，我们就按流程来、按章程办。对吧？大家都……都没有话说。我们一条一条来对，我看你才是怪哉。最后（进度条20%），&lt;班主任&gt;特别提醒：（咳嗽声）请，生活班长负责寝室区相关纪律事务的班委每个星期天返校、以及星期一分层作业根据不同分数段布置的不同作业，重要的事说三遍，听到没有？男生女生都说，每个寝室说，听到没有？第二个，考题和学法分享总结：请你多斟酌哈！时间把握好，八分钟之内。第三：对于在教室头，我再次重申——吃完饭也好，你课间回来休息也好，讨论题，没有到（下午）六点半之前……原来我们是（下午）五点五十吃饭，要求（下午）六点二十五进教室；现在是（下午）六点钟才吃饭所以我们不再做六点二十的这个硬性要求，就六点半。你要讲题就外边讲，&lt;班主任&gt;不干涉，但前提是要必须安静。（咳嗽声）我……（移动MP3时录入的嘈杂声音）……我只教了十多年。我们不管是教了十多年的还是……（嘈杂的声音）……没得哪个说，家长管理他娃儿娃儿又考的撇差。我也没看过哪个家长反映他娃儿有好优秀……就像那天我和&lt;一位同学&gt;分享的一句话，只有当你把自己管得住的时候，你才去谈客观原因和外在原因——“事有不成，反求诸己”“行有不得，反求诸己”，请你铭记……&lt;励志班长的名字&gt;负责在班级传递正能量和在黑板上书写励志名言的班干部，今天就把这句话写在黑板上哈！“事有不成，反求诸己”哈，不会写的字下来找我，我来……我来告诉你。装疯迷窍的有些同学，简直是……你不要跟我在这讲歪歪理哈，我没得（微信声）时间跟你讲歪歪理……（嘈杂声）……所以，再次强调，从明天开始，所有讲话的，我刚刚点到的那四位同学，每天个辅签到，（咳嗽声），定时守候、分享。都把名字加上。第二，对于前面那一路、那些同学，我说喽，我们班上已经找不到你的、你的对手喽，请你把你的目标定高远一点，放到年级范围去看。第三，我这一次整人，不是不需要靶，是我要整改我们班所有的人，成绩区间稳定的……在这，冲刺就叫冲刺、不是躺平。鱼龙混杂天天在这唱浮躁，我不知道你在这唱啥子。最后（进度条70%），我的本意，没有想过哪个，到时候被（大意是分班后被分去烂班）……但是，我也不惧怕因为你非要住这而直升不了……你都可以拿你的一辈子来……跟学校的规章制度来赌。我这个……多你一个少你一个，好像对我来说，都是小事情。对你来说你都可以拿一辈子来赌，这赌的有好大的哦。你和学校的规章制度去赌去跟我没得关系，我执行……书记、记录员的规矩职责。我在这里再次提醒哈，凡是在这里耍朋友的、谈恋爱的，&lt;班主任&gt;这不给你那么多面子谈。如果，家长给我反馈了我给你反馈了你不仅不收手你给我……不刹车。把你抖到学校这个层面上去，我估计，你的直升十有八九没得资格，你也玩完了。你现在不直升、明年不直升，要得嘛可以嘛。你明年直不直升，你明年直升了是不是这个事情就过了嘞？你个人想一哈。不怪……不怪我没提醒你哈，因为你（微信声×2）悠悠众口。他来给我找班主任说我想解决问题，当他觉得我解决解决得不够的时候，他就往上头走，往学校层面走。那投诉到你，倒过来问我噻，那对不起哦，我说我有嘞、所有嘞……（晚放学铃声）不要、不要把这些往外边说喽……我说喽，现在所有的层面都基于，我们是家丑，家丑我可不想外扬。有些人非要把这些事情抖出去……（铃声）……给政务、警官、高管，一起耍，坏了他人生，那几个高管，网上，点名就被……只有&lt;名字&gt; 他儿&lt;名字&gt;，坐了二十年牢……（嘈杂的声音）……所以你不要觉得你有哈子关系能关系人的，在规则面前……（嘈杂的声音）……我先说清楚哈！下课休息。 S5.mp3 Your browser does not support the audio tag. 展开 字幕 还有……还有两个没出来……出来了你们要考虑的是，你这个……你这个第四名，和第一名平均分差多少分的问题。不要想到你曾经是第一名、不要想到你和十五班平起平坐。就正如，你觉得你的成绩取得和&lt;班主任&gt; 没关系，那，这次的滑坡，又和我有什么关系？如果你觉得，你妈妈要问你我们班耍朋友的是不是特别多。那首先要问：我们班其他同学耍朋友跟你有什么关系？你耍朋友没有？你的学习怎么样？第四，你觉得你是我们班特别优秀的最优秀的，老子天下无敌~把你的分数拿去和人家的第一名第二名第三名比一比，你排老几？你的粉丝些，人家排前几，你在哪里？你跟着人家去玩，他怎么不带你飞呢？他考班级第一你怎么没考班级第二呀？人家耍的高兴人家是八班的第一，他怎么没带你考八班的第二呀？你是他的粉丝的嘛，你绝对拥护的嘛，你觉得他那样就是就是就是飒、就是帅……人家 &lt;一位同学&gt;生病了还没有……还没有来参考。按理来说你们班平均分，你的平均分不应该更高吗？人家都不来参考……你飞呀！你瞧不起的样子。少了一个人、少了一个女生你觉得：哦人家的数学不好的。你怎么不飞呢？人家怎么一样秒杀你呢？（回到正题）老子问的是除了，举例子、作比较、列数字这三种说明方法以外，文本中还用了哪些说明方法。你在听吗？老子……老子鬼才信你！这节课剩下的时间，自主 学习。你得行的很非常了不起，人家语文（成绩）还没出来，物理……物理就低了，语文你跟人家平起平坐……（班平）甩你个三四分都正常，你就看下你是怎么从班级的天花板落下来嘞，砸个半死嘞。你天天在这混日子，人家是毕业班冲的呼啦呼指热火朝天，你在这自我感觉良好。老子前脚说，桌子要捡干净；后脚爬起来就是一趟。你在听没有嘛？你原来觉得人家 &lt;一位同学&gt;数学不好，要拖你平均分喽。你在班上人家这个同学起来回答问题你笑麻死起形容夸张喽，带他一起去飞撒，你有脾气帮他一起把数学搞好噻。人家咋不来……人家因为生病没有来考试，你咋没去摸天花板嘞？你咋个还叫别人把你秒杀了嘞？简直是稀奇。管不住自己的娃儿，动不动就是我们班咋子，我们班抓天花板的时候他咋没打个电话来说诶&lt;班主任&gt;诶你们班这次考得好呦。他咋觉得是他自己娃儿努力了才得行，那按照这样子的推理，考撇差了也是自己状态不在。哪个再说八班管理咋样、你的家长在这这门那门的，赏他两句：你简直是个怪哉。有些家长做个事情简直是……你的娃儿得行你喊他考噻，他咋个被别人秒杀的嘞？放回家去……是咋个做的嘛。回来咋个说都不得行，教给他他是啥样子嘛、回来是啥样子？你等他躁完就算了回学校你就收心了嘛，还在闹！人家十五班数学学高一的内容；二十二班英语平均分每个人都比你们高七分就哪怕你考140，我相信他那里一定有考 147 的、你考 142 他们班一定有考 148.5的；我们班语文（高分段）在哪里嘛，有好多嘛。你洋盘贬义，指出风头惨喽。那小卖部开了买酸奶你比哪个都跑得快、要交卷了你半天都交不上去，巴不得哪个给你看一下哪里还有两个空没写……做的都不是人事……你还有观点、你还有看法，你有啥子看法嘛，（心思）就是没在学习上……（摔打人用的塑胶棍）我骂完了，（你）晓得这个成绩之后你咋不默哀嘞你考不过你不应该垂头丧气话都不想说咩？你闹pao（喷一堆口水）喽！上来上课都是读书声你嘞？蚊子声音；回答问题嘞？哦、啊。你是不是把它搞反了嘛？说的都是废话，破嘴……那我就要看看，我们班这回子的第一名在年级上（排名）哪儿哇，我看你洋盘的很，你还着不着急嘛？十名开外……你以为：哦我还是第一，井底之蛙。下课（的时候），我要收语文书，要求检查这节课的自主学习笔记。（拿书声）第一，所有的说明方法，按照昨天的要求，不低于五处；第二，《大自然的语言》中，思考探究的后面……（录音结束） S11.mp3 Your browser does not support the audio tag. 展开 字幕 ……桌面清空哈，今天锦江区在常规筛查中发现一系……一例阳性病例。所以相关的疫情防控工作已经按要求转发（到家长群），今天下午放假，明天是属于休息，但是一定、一定做好防护，不要乱走乱跑，好，这是第一个。第二个不到人多的地方去聚集。好，因为……要……我们都知道，在常规的筛查报告中都会有相应的滞后性。现在锦江区正在（对）到过相关地点的……正在查时空伴随者，所以，估计很……如果回家以后你家长的健康码和行程码有明显的……有变化，一定几时告知，好这是第二个。好（上面这些其实）全都是第一个事情……好，第二个事情。嗯，今天放学，因为我们天气比较大，额（铃声）所有的放学都在寝室、所有的放学都在寝室，就直接回寝室，家长在寝室等候大家，所以心里要有数哈。再到……特别是走读生，不要觉得啊我是走读的我爸爸妈妈啊……可能今天就住校吧如果他在寝室等你啊所以要特别提醒。这是第二个点。第三个点，嗯，第一轮（画外音：&lt;一位同学&gt;，什么时候放回寝室？）展收环节模拟 考试已结束，说实在话大家状态还是不够，发挥得不太好，对待物理的重视程度不够，还是显得有些轻飘。所以，我希望，我这里掌握着大家四科总成绩的排名，我们把政治和历史剔除了以后，有很大的变化。就有些同学，我我……我这里真的是很……真诚地奉劝不只是他下面可以不用来，坐在那里苦熬，确实也很辛苦。好第二个是走读生，建议这一轮中有个别同学带了电话手表，请你下一次及时上交。凡是所有的通信工具都应该及时上交，好通讯工具、电子设备是不能进校园的，这里我再次提醒。下一次我再发现，有此类似的情况，那将取消你假期托管的资格，好听清楚。好这是第二个点。第三个点，嗯，待会（请）班长提醒我发这个成长报告册，很多同学请你如实地把这个……成长报告册拿回去（填写）因为你的家长反复在问你的学习成绩。其实我们在10号&lt;班主任&gt;当天下午就跟你说了这么长的时间，你应该去和你家长去主动联系一次，至少一次应该是没有什么问题的而且时间有这么大这么长比你平常要宽裕些，所以他很着急也很焦急，客观理性地分析你的成绩。好这是我要提醒的第三个点。最最最最最最重要的我要强调：回去不要一不小心自己就成了时空伴随者，然后就告诉你22号的考试和你说saygoodbye。好，一定要牢记。最后一天……当然，如果你确实决定我伤得起，于是乎借口把（没听清），对不对？啊那全身疼，那没用。啊那我们在……请大家稍安勿躁哈还有十分钟，我们把这节课上完就放学。 S.mp3 Your browser does not support the audio tag. 展开 字幕 （录音开始）……意见……那请问，你选择的明明是你自己的事情，为什么让别的家长、让别的同学，觉得他受影响喽。你回答我噻……你回答我噻。这你就叫……浪费了占用了别个的公共空间你懂不懂？就像我和 &lt;同学X&gt;俩摆聊天，讨论学习，我们俩之间学习好不好是我们的事情；我和&lt;同学L&gt; 俩好是我和 &lt;同学L&gt; 之间的事情……我不和你 &lt;同学Y&gt; 好然后我拼命在&lt;同学X&gt; 的面前说 &lt;同学Y&gt;做的如何如何不好。这样一个原因。对不对？肯定不对撒对不对？我选择你是因为我觉得我们两个之间有共同话题的原因喽，我都不愿意和&lt;同学Y&gt; 摆那是我们两个……性格不对呗。但是我不能够把人家 &lt;同学Y&gt;的不好拿（去）人家 &lt;同学X&gt; 的面前来摆噻。这就叫占用公共空间，你用自己的好恶……来起诉同……其他同学。那相反的，你要和我俩耍朋友，你们俩耍嘛。我也见过我们屋的一个堂弟人家就是初中就就……耍朋友，那到大学咩，就结婚了嘞。我一点都不反对坏事，你是有这种情况，现在社会上啥子多样化。但是你要把这事情我和他耍朋友我俩又咋子又咋子又咋子，虽然别个都晓得，别个回去（拍手声）……你就要说完了就没得啥子人家家长回去之后人家就是这样子来（对我）说的嘛：“&lt;班主任&gt;，我也理解你，但是这样子……”这样那样的咋子嘛，对不对？你们两个耍朋友，有些人就（说）看人家他们都耍了三年了，这是初中、高中，他妈他老汉父亲也晓得他可以对那个女生多好。但是人家两个都考（上）大学喽。你看他们班上没觉得他们两个直牵眼睛招摇噻，这个你整倒了哈……所以听清楚，我们班在学习目标上，你是当四十三分之一班 级 第一还是三分之一班 级 前十，是你的事情。第二个，在做人上，请你，善言善行、谨言慎行。第三，你所有的个人事情，请不要占我们的公共空间。我不希望这样子再给家长打电话……受不了……&lt;班主任&gt;是个自尊心非常强的人，我给你们说过：我那个事情在这……那件……那件事上在这绊到筋斗……只要给我一个机会，哪怕三年五年，我还要在原地站起来，这就是我。我希望我带的娃，他也能屈能伸、要有集体人格、不怕输输得起、学会去输也学会去赢，同时，做好自己。我当了十多年的班主任喽，不长，比 &lt;数学老师&gt;那（当班主任的时间）相比要短，但也不算短。我的职业生涯至少前进了一半段。我是第一次被人……被家长，当然人家是善意地在提醒我、善意地跟我在反馈这个情况，但是我是第一次哦，从来没哪个问我当过……当过啥子班主任，跟我说&lt;班主任&gt;“班风有问题”，受不了，我真的受不了（甩橡胶棍）……哪里有感觉被家长这样子打脸的感觉？很不爽。但（因为）你们，我被打了两次脸：去年子助词无实意，因为上，直升班的课，开演示，被学校打了一次脸；这学期，被家长打了一次脸（拍讲台），当然，我相信，这仅是个别情况，但为什么那么多届学生……就像&lt;数学老师&gt; 一样她每届带两个班，我十五年，至少（带过）有五届、到六届（学生）嘛。每届，一百个人……有几百个人嘛，六百个人，这个几率六百分之一在你这就发现喽，还要好生好好思考诶，对不对？我们讲概率的……供君思考。 S4.mp3 Your browser does not support the audio tag. 展开 字幕 （录音开始）……只是给你们其他的老师讲：“哎呀我那个初中班主任从来没管过我，都是……都得靠自己。”当你把这话说出去的时候，只要你有底气说，你看看你老师还要你吗？……我想，是聪明人，他会看见每一个人在每一个阶段对他的成长和发展……的付出。你去摆……反正你成大才了你去摆：“我们那个初中班主任歪脾气暴的很、恶的很，就想把我们整死”你去摆嘛，你看人家是笑你还是笑我。哦……2009年的有一个学生叫，读的华西科技大学，本科毕业以后，他的导师要求他读硕……硕博连读，他说我要考虑一下，他说要这样子的话我要读到近三十岁，他说，是不是会读转行了，他就在考虑我是只读研究生还是只读硕博……那个，把博士一起读了。当时就问他，他说：“当你一路走来，你觉得，在你的成长阶段中、在……在你所有经历过、帮助……焦虑过你的老师中你印象最深刻的是谁？”他的回答是：“我每一个阶段的每一个老师都很重要。如果没有他们就没有现在的我。”后来他去导师那报道的时候，他的导师才告诉他，说：“专业你在我这不是最强的，但是你的格局很好……你是一个看得到别人对你付出感化、丁点你都能看得到的（学生），”他说，“所以，我愿意，当其他老师都还不太同意的情况下，我愿意推荐你去读……硕博连读……如果你愿意的话。”他说：“那你没有被老师批评过没有被人……老师收拾过吗？”他说：“我妈妈从小教给我：对我最狠的老师才是对我最好的老师。”他说：“那我这也很不好过哦，”那个老师告诉他，说“我这也很不好过呦……进来的门宽、出去的路窄哦。”这句话的意思就是告诉他：当然我的……出身很好进（进来的门）、一般很好进，但是至终、最终你能不能够毕业、顺利与否，不见（得）能，因为他也是学术上的钉子户，就是比较黏。所以，进去好进，他是出了门……出了在他们那是出了名的……这就不叫XXX了要求比较高，所以能够当他的研究生很容易但是能够顺利毕业的、不留级的不多。但是他带出来的学生都是很棒的，所以，他也给……给我的一位学生说，他说：“&lt;班主任&gt;我现在现在明白了，他回来又十多年以后我们学校还要……当年有一个奖学金他也是拿奖学金的……当时，当时说他初二的时候他应该给了一个班后了……当时是我们就去问过他还是咋的反正最后说的就是在……审查的时候，他又回来了，然后在那聊。”他就这样，一个男孩子，他当时说来的时候是我们班最小的就年龄最小的，就比同龄人可能要小一岁左右所以你看他，小一岁按理说他的年龄应该比较小的哈同龄人中，他硕博连读出来的话他应该是还不到三十但是他就在想要不要读到三十岁、要不要读到三十岁一个（主要是）太老了，他还会这样去想。我说你们独立读书时候好像比较少吧，就我认为他比较小因为他个子也小。他说是呀，他说但是要读那么久的书，还是需要依附于那个&lt;班主任&gt;。你再看看你们。第五，地生课堂回顾复习的效率有待提高……好，第六，对值日的班长清洁（工作）不满，有时候要说脏话，而且不止一个班委反馈这个情况……所以，在这进行制度的及时治调，好请你有最起码的尊重。同时，责令你在音乐课和协商讨论以后你才有决定的权利，首先要给道歉，你连续三周，连我守自习你都不自觉。我们先不说课堂上……提醒，那天星期四，音乐课上上自习的那几个同学，除非你征得的原谅（之后）你可以上音乐课；否则，她有权拒绝你，这周星期四，去上她的音乐课，你就回教室上自习。连最起码的尊重都没有……守着上自习你都还整些莫名堂莫名其妙的事，确实就不该了。所以，适用的你们也同样适用，怎么处理，你要么呢写道歉信，让签字，允许你去、同意你去上音乐课；如果她不同意没有签字我没有拿到条子，你那天星期四的第五节课音乐课就在教室里上自习。第七，关于行进安全。这里再次，特别强调……这周工作重点：常规安全，第一个是行进安全，好我们星期一早训的时候就说过不再赘述；第二，这（周考）成绩（晃动成绩单）好与不好……它都摆在那了，它都是你努力的结果。唯有不同，因为努力的程度不同、临场发挥不同、自我要求不同，你在和我躲猫猫，&lt;班主任&gt;来的时候是这个样子&lt;班主任&gt;不在的时候是这个样子。不要假装很努力，因为结果不会陪你演戏。这就是一个道理。关于（男生）444寝室，刚刚已经说了不再说。第二个希望大家重视音乐和艺术课，因为它会纳入中考。好今年成都市因为作为试点城市，就是双减后的试点城市，所以就是说这个……所以请你引起重视。看现在你们能够听到星期天的时候广播里边……里面在说初三的体考如果有参加延时（课程）的……就是平时不认真上体育课到初三体育考试时候过不了关，需要单独加训的。所以请你现在认真上好每一节体育课，做好每一个体育（动作）……而且体育中考也在改革，原来是50分制你们这一届（初二）……现在初三已经是60分了。60分。所以不要到时候再措手不及，而且我不知道我在我们班说过没有：温江只有两所公立高中一个是二……温江中学；一个是温江三中。今年他们对外招生的名额是60个。这是我那天在班上说了有些同学你是……你的成绩……你的户口不是温江区的，好这是公立学校，温江公立学校的高中确实只有这两所。然后还有私项（私立），私项就是原来的一个七中实验现在叫莞城实验，这是第一所；第二所，诶他们好像说……额新世纪新世纪好像在起高中，好，那边高中和我们也差不多好像没有、还没有出考试……成都高考成绩。好……好像就只有这这这（几所高中）……然后再加上东辰（私立）。所以整体告知温江……温江的高中（升学）资源是非常有限的，而且他本身也有公立学校，有公立的直升的这部分娃，这叫……他们叫指标到校生，因为他们对外招生只有一百人。如果你进不了……你是，不管你是选择2+4的升2年初中+4年高中还是3+3的升3年初中+3年高中……如果你受不了，你到外边去，一定没有竞争力，这是第二个。第三个，有些同学你不要觉得嗯你说我不想直升，我要出去考479，我很确定地告诉你：它不论怎么改革，479的门不好进。它哪怕，哪怕你是五城区的户口就5+2，从5+2加高新区……高新南区成都直管区加……高新南区……啊天府新区成都直管区加高新南区，高新区嘛加高新区，而且他是面向全成都市中心城区摇号，他还要留一部分四川省、成都市以外的地区市级高中名额来保证他生源指标。我……我可以很明确地告诉你：绵阳东辰同样能够考上……考上七中（林荫）的娃……进去，绵阳……绵阳东辰（的学生）考进去在里面发现自己不一定很好，然后……我这话的意思不是说绵阳东辰不好，而是想告诉你：成都七中他的要求很高。所以，请你有心理准备、不要好高骛远、自我感觉良好，最后空着来，到最后什么都没有。你连直升……如果你直升拿不到特等（奖学金），不太有希望，很确定地告诉你。除非你……。第四，这里，值周班长，请你听清楚，值周班长听清楚，从这周开始，我们接下来要量化值周班长的具体职责。所以，今天要特别提醒，打扫卫……晚上打扫卫生，除了劳动班长以外，请值周班长一定要做这个事情：凡是私自玩一体机的，没有……最晚打扫卫生（晚上）九点三十二必须全部离场，没有离场的把名字记下来，听清楚哦。好，第四，本周管理关键词——“清朗行动”加“计划”。今天……告诉我我们的地生、地理背诵有十一个同学没有过关，他让我传达的意见是这十一个人不过关，如果在星期五上课的时候还过不了关，就请家长接回家去背地生，周末的延时暂时不给他……你连地生都整不好，上其他的课意义也不大，所以把地生的背诵完成任务情况纳入……周末延时托管考察的范围，听清楚，请自行找时间做好（背诵过关任务）。最后，不管成绩怎样，它都摆在那了，你都要去接受，客观、冷静地去看待。最后，在这里，再次提醒，你要摆龙门阵闲聊的、你要讨论题的你们到外边去（讨论），进教室就必须安静。第二，学习不是你为谁学，而是我要把选择。非得要问（为了）谁，只能是自己。对于后面三个，我们班等所有成绩出来以后，我看你们有多么牛，有多么想要……不要过成绩要结果，那我们要约见你……的家长，就先请你，谈一次就一次谈两次就还是两次，搞些莫名堂的，不知道干啥。这节课（晚自习）还剩十分钟，请你把各科作业拿出来（桌椅书本声）（录音结束） ffydmmlbd.WAV Your browser does not support the audio tag. 这是原八班的一个梗，具体起源无法考证。 REC220717172738.mp3 Your browser does not support the audio tag. 这段是上课实录而且杂音较多所以就不做字幕了，我估计应该没几个人会听她具体讲了些啥东西吧。 寝室合集 REC220115071351.mp3 Your browser does not support the audio tag. 注意炸麦，建议调低音量食用！ 万恶之源1.WAV Your browser does not support the audio tag. 包含炸麦、高频电流杂音、尖锐爆鸣等社死内容，建议佩戴耳机食用！ 这是我用新买的MP3录制的第一个音频，同时标志着成都东辰MP3半导体时代的开始。 万恶之源2.MP3 Your browser does not support the audio tag. 包含炸麦、高频电流杂音、尖锐爆鸣等社死内容，建议调低音量食用！ 录下上面的万恶之源后，由于听感过于炸裂，将MP3的录制比特率上调并更改了录音格式后录制的更为炸裂的版本。 其他 Hooop.WAV Your browser does not support the audio tag. 这是八下第一学月成绩表彰上录制的音频，主要是二单元的拉胯宣誓。 展开 字幕 （第一段）……干嘛？几点了？（第二段）（有请）L主任……一单元一至七班这气势恢弘，底气彰显实力。但，二、三、四单元的同学们也绝非等闲之辈，你看！下面，让我们应二单元八至十四班的呼喊，有请L主任。好，请班主任面向主席台。好，二单元的全体同学听口令，三二一，起立！向右看齐！向前看，稍息，立正……勇士何在？Hoooooop！战鼓擂鸣，马蹄声催——我们……我们二单元全体师生，向，一、三、四单元提出挑战！我们要在礼仪常规、拼搏进程上超越你们！狭路相逢——勇者胜，Hooooooooop！好，全体都有，sit down哦吼……芜湖……Hoooooop……好那么下边是…… ZYR.WAV Your browser does not support the audio tag. 这是八下第一学月表彰时录制的音频，主要是四单元单元主任ZYR标志性的破音领誓。 展开 字幕 春来，春雷隆隆、战果累累，前三个单元的同学们已向我们四单元二十二至二十八班发起了挑战……我们四单元同学在哪里？！（在这里）……请四单元全体师生起立！（破音了）。好保持安静……请同学们大声地喊出我们单元的口号，喊出我们的气势，起——不骄不躁，上下一心，心！（中间真是啥也没听清）……这不是藏头诗吧……不是藏头诗……这不是藏头诗……丑陋……朋友之妻不可欺……力拔头筹！力拔头筹！力拔头筹！好，全体师生，请坐！ 20220316-071709.WAV Your browser does not support the audio tag. 这是某同学在2022年3月16日早上吃饭时自己复刻自己的一段经典演讲。 展开 字幕 CNMB的东辰。TMD诈骗集团吃饭不给钱（廖哥：TMD诈骗集团），PC不给钱，TMDP霸王C（笑声）","categories":[],"tags":[{"name":"成都东辰","slug":"成都东辰","permalink":"https://justpureh2o.cn/tags/%E6%88%90%E9%83%BD%E4%B8%9C%E8%BE%B0/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.cn/tags/%E6%95%B4%E6%B4%BB/"},{"name":"历史资料","slug":"历史资料","permalink":"https://justpureh2o.cn/tags/%E5%8E%86%E5%8F%B2%E8%B5%84%E6%96%99/"}]},{"title":"[熟肉] 一棵主席树新增了一个数据，这是它的结构发生的变化","slug":"algorithm-persistent-tree-hjt-tree","date":"2024-08-08T16:55:42.325Z","updated":"2024-10-05T02:51:20.349Z","comments":true,"path":"articles/53799/","link":"","permalink":"https://justpureh2o.cn/articles/53799/","excerpt":"","text":"标题及头图致敬油管兼B站UP主 Chubbyemu——一位非常专业的医学区博主。 可持久化简介 可持久化数据结构，支持在保证操作不变的情况下、同时保存它的一个历史版本，以便后期的历史查询。一般的编辑器软件都会内置撤回/重做的功能，这时使用一个可持久化数据结构来存储用户的历史操作就显得非常便捷了；某些软件通过重演用户操作来实现撤回/重做功能：当用户操作较多时，会非常浪费系统资源、且效率极低，尤其是在进行连续撤回/重做时，体验感极差。 可持久化线段树/主席树 理论基础 对于一般的线段树，可以通过调用 modify 函数来进行单点插入，如果此时再加入一个要求——能够查询先前某一时刻的某一操作对应的区间最值，普通的线段树就无能为力了。比较直接的想法是：可以把每一次操作得到的线段树单独拎出来，然后对于每次询问，在对应的线段树里面跑即可。时间上过得了关，但显然这样太浪费空间——明明更改单点时只会影响到特定路径上的节点，为什么还要费劲把其他无关变量另外存下来呢？基于这个优化思路，可持久化线段树/主席树应运而生。 相关链接：可持久化线段树的发明者叫黄嘉泰，由于他和当时的国家领导人名字首字母缩写雷同，因而又叫主席树。 先来看看普通线段树的插入操作： Insert#1 Insert#2 如果每次操作都要新建一整个线段树的话，那么插入五个元素的空间复杂度就有原先的五倍之多。注意到在插入操作进行时，只有红色标出的节点是受影响的，因此只需把红圈存下来而无需无效地复制那些黑色的节点。 按此理论，完成五次插入后的线段树应是下面这样（部分虚边为了美观未在图上连出）： 可以发现一个规律：副本树的连接关系与原树相同、且副本树中不连接副本节点方向上的的子树与原树对应节点的对应子树相同。但同时我们失去了一些东西——左右子树的下标再也不满足线段树中的二倍和二倍加一关系了。不过对历史记录的访问变得轻松——从右到左，分别是第一次到第五次的操作所复制出来的副本树，每个副本树都有一个根节点，代表当前的历史记录。对于询问，直接在对应根节点上查询即可。 可持久化线段树/主席树 建树部分 根据上述分析，在主席树中，把 l 和 r 变量变成节点左右子树的下标（或指针）。由于每次操作最坏会复制出一个节点数为 的副本， 次修改（插入节点）之后最多同时存在 个节点，习惯性把空间开到 倍，也就是左移 位。此外维护一个数组 root 用来存储每个历史记录对应的根节点： 12345struct HJTTree { int l, r; int dat; // 值} tree[N &lt;&lt; 5];int idx = 0, root[N]; 根据特定要求添加变量即可。在建树时，不断向深层递归，并动态创建新点。因为上面提到的主席树不再满足普通线段树的下标规律，我们给建树函数设置返回值，递归设置左右子树的值即可。大部分代码和原版线段树相差无几。 1234567891011int build(int l, int r) { int p = ++idx; // 开点 if (l == r) { tree[p].dat = a[l]; return p; } int mid = (l + r) &gt;&gt; 1; tree[p].l = build(l, mid); // 创建左子树 tree[p].r = build(mid + 1, r); // 创建右子树 return p;} 可持久化线段树/主席树 节点插入 插入新节点时，我们需要先把沿途的所有节点复制一遍。节点复制写在一个函数 clone(int u) 中，顾名思义，这个操作非常简单——单纯就是原先点的复制、同时返回新建的副本节点的下标。 12345int clone(int u) { int p = ++idx; // 开点 tree[p] = tree[u]; // 复制 return p;} 接下来是节点插入的主体部分。把节点复制完毕得到一个新点后，就需要递归更新所有点的左右子树，最终在叶子节点的位置放置要插入的点。 123456789101112int insert(int u, int dat, int pos, int l, int r) { int p = clone(u); // 先复制 if (l == r) { tree[p].dat = dat; // 叶子节点的位置插入 return p; } // 找到插入位置，同时更新子树 int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) tree[p].l = insert(tree[u].l, dat, pos, l, mid); else tree[p].r = insert(tree[u].r, dat, pos, mid + 1, r); return p;} 节点和区间的查询和普通线段树是基本一样的。这里需要注意题目要求查询哪个历史操作的值，并从相应的根节点开始向下递归查找。 模板两题 洛谷 P3919 [模板] 可持久化线段树 1（可持久化数组） 题目地址：P3919 题目难度：提高+/省选- 如题，你需要维护这样的一个长度为 的数组，支持如下几种操作 在某个历史版本上修改某一个位置上的值 访问某个历史版本上的某一位置的值 此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组） 输入格式： 输入的第一行包含两个正整数 ， 分别表示数组的长度和操作的个数。 第二行包含个整数，依次为初始状态下数组各位的值（依次为 $ a_i ， 1 i N $）。 接下来$ M 行每行包含或个整数，代表两种操作之一（ i $为基于的历史版本号）： 对于操作1，格式为 $ v_i1loc_i~value_i ，即为在版本 v_i 的基础上，将 a_","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"基础数据结构 线段树","slug":"algorithm-segment-tree","date":"2024-08-08T00:23:05.473Z","updated":"2024-11-27T04:40:48.400Z","comments":true,"path":"articles/48920/","link":"","permalink":"https://justpureh2o.cn/articles/48920/","excerpt":"","text":"旧专栏由于年久失修，目前已被标记为过时。本文是对旧博客的重写及内容补充。 线段树的思想就是把一段区间拆分成两个子区间，运用递归的方式，线段树能在不大规模改动原数组的情况下实现区间信息的维护。有了这一点，区间信息维护的时间复杂度就从朴素暴力算法的 优化到了 。 前言 本文所使用的宏定义及含义如下： 宏名 定义 作用 le(x) (x * 2) 获取左子树的下标 ri(x) (x * 2 + 1) 获取右子树的下标 leftSubtree(idx) tree[le(idx)] 获取左子树对象 rightSubtree(idx) tree[ri(idx)] 获取右子树对象 线段树的建树 根据前文所说，线段树将一段长区间分为两段，并设为它自身的子树，不断递归直到区间长度为 。如下图： 可见线段树是一棵满二叉树，它有 个节点（ 为树的高度/层数，上图中 ）；此外还可以发现，对于下标为 的节点，如果它存在子树，那么它的左子树的下标就是 、右子树为 。我们平常使用线段树，则需要开四倍的空间（pushdown 位置的不同、删去某些特判可能会让这一上限最多变为八倍空间，后文将阐述其原因）。 在建树时，我们需要处理出当前区间的中点，并分别递归左右子树继续建树、顺带维护区间左右端点的信息（区间大小、初始化懒标记等）。根据前文，递归终点是区间长度降落为 ，此时将原序列中的信息搬过去即可。 1234567891011void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; // 维护区间左右端点 if (l == r) { tree[idx].max = a[l]; // 维护区间最大值 return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); // 递归左子树 build(ri(idx), mid + 1, r); // 递归右子树 pushup(idx); // 更新父节点} 线段树的节点更新 基本分两种，已知子节点更新父节点和已知父节点更新子节点。 第一种操作一般被称作 pushup 上传操作。在子节点更新完毕回溯时进行，起到更新父节点的作用；第二种操作被称作 pushdown 下传操作。在带有懒标记的线段树中向子节点递归查找信息时进行，能够将先前积累起来的操作下放到子节点。 一般在编写上传操作时，要考虑到所维护信息的结合性质。例如维护区间和，父节点记录的值显然应该是左右子树记录的值之和；再比如维护区间最大值，显然应该是左右区间分别记录的最大值中更大的那一个。 12345void pushup(int idx) { tree[idx].max = max(leftSubtree(idx).max, rightSubtree(idx).max); // 区间最大值 tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum; // 区间和 // ...} 在写标记下传时，需要特别考虑标记之间的优先级关系。例如当前有两个操作——区间推平（赋成统一的值）和区间加。当该区间需要下传一个推平标记时，可以直接把区间加标记给清空，因为推平后就不会存在区间加；反过来就不成立，因为区间可以在推平后继续进行加法。因此我们需要先判断推平标记的情况，后面再来处理区间加标记。 12345678910111213141516171819void pushdown(int idx) { if (tree[idx].que != -LLONG_MAX) { // 区间推平优先处理 leftSubtree(idx).max = tree[idx].que; leftSubtree(idx).que = tree[idx].que; // 继承推平标记 leftSubtree(idx).add = 0; // 清空加法标记 rightSubtree(idx).max = tree[idx].que; rightSubtree(idx).que = tree[idx].que; rightSubtree(idx).add = 0; // 清空加法标记 tree[idx].que = -LLONG_MAX; // 清空推平标记 } if (tree[idx].add) { // 区间加法后处理 leftSubtree(idx).max += tree[idx].add; leftSubtree(idx).add += tree[idx].add; rightSubtree(idx).max += tree[idx].add; rightSubtree(idx).add += tree[idx].add; tree[idx].add = 0; }} 线段树的查询操作 线段树既可以查询单点信息，也可以查询整个区间的信息，前者可以看作是区间长度为 的区间查询，是区间查询的一类特殊情况。 简单查询 在这个例子中，我们假设查询区间 的某些信息，首先我们就需要找到这个区间：递归查找、缩小范围，发现当递归到下标 时，区间 就被包含了，于是直接返回；当查询至下标 ，区间 被包含进去，此时我们就可以不用花费大力气继续向下递归了，因为线段树的父节点就存储了子节点的信息。以查询区间最大值为例： 123456789int queryMax(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].max; // 完全包含，直接返回 pushdown(idx); // 子节点可能存在积累的操作 int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; int res = -INF; if (l &lt;= mid) res = max(res, queryMax(le(idx), l, r)); // 递归左侧 if (r &gt; mid) res = max(res, queryMax(ri(idx), l, r)); // 递归右侧 return res;} 由于查询的值是独立的，不依赖于其他变量。如果碰到较为复杂的、多重依赖的变量，那么这种方法可能就会变得不那么适用了。接下来介绍第二种高级的查询操作，也可以说是码量较大但是更为万能的查询方法。 复杂查询 以查询区间最大子段和为例。我们维护了区间最大前缀、最大后缀以及最大子段和，最大子段和应是左子树最大前缀、右子树最大后缀以及左子树最大后缀加右子树最大前缀三者的最大值。如果依然沿用上面的简单查询，那么实现将会极其复杂，此时我们不再让函数返回线段树节点的某一权值，而是改成返回线段树节点本身。这样一来我们就可以通过左右子节点的值来推断返回值，从而达到查询的目的。查询逻辑和简单查询有不同： 1234567891011121314SegmentTree query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx]; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &gt; mid) return query(ri(idx), l, r); if (r &lt;= mid) return query(le(idx), l, r); SegmentTree res{}; SegmentTree L = query(le(idx), l, r); SegmentTree R = query(ri(idx), l, r); res.max = max(max(L.max, R.max), L.rmax + R.lmax); res.lmax = max(L.lmax, L.sum + R.lmax); res.rmax = max(R.rmax, R.sum + L.rmax); res.sum = L.sum + R.sum; return res;} 首先，我们依然判断当前区间是否已被完全包含，若是则直接返回当前节点。接下来是不同之处：如果查询区间完全在中点右侧，那么返回右侧查询的结果，反之亦然，查询左侧。 如果区间不完全在中点一侧，那么左右分别查询，获得左右子节点的信息。接下来就可以按照正常的维护方法维护返回值节点的相关信息了。 线段树的修改操作 同样分为单点修改和区间修改，前者同样是后者的特殊情况。基本思路相同，先找到被完全包含的区间。但是此时可以有一个优化——不用每一次都递归到区间的叶子节点再进行修改，可以直接将修改信息记录在一个大区间内，当查询需要用到子节点的值时再一次性下放积累的操作。线段树中记录这些操作的标记便被称作懒标记。 对于某个区间，需要先把当前区间的相关信息修改之后再返回，否则相当于没有修改（只是打个标记，当前节点并未更新）。以区间加为例： 123456789101112void modify(int idx, int l, int r, int x) { pushdown(idx); // 可能还有积累的操作 if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].max += x; // 更新当前区间的最大值 tree[idx].add += x; // 打标记 return; } int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x, type); if (r &gt; mid) modify(ri(idx), l, r, x, type); pushup(idx); // 由于更新了当前节点，需要向上更新其他节点} 一些细节 一句话，让评测结果从 RE 到 AC 有时你会发现——明明题目中说了 ，我也开了四倍空间，为什么还是会 RE？事实上，这可能是因为错误的 pushdown 位置和特判的缺乏。 比如下面这段区间修改的代码（来源 P2574 XOR的艺术）： 1234567891011121314void modify(int idx, int l, int r, int x) { pushdown(idx); if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].sum = x * tree[idx].size; tree[idx].que = x; tree[idx].lmax[x] = tree[idx].rmax[x] = tree[idx].max[x] = tree[idx].size; tree[idx].lmax[x ^ 1] = tree[idx].rmax[x ^ 1] = tree[idx].max[x ^ 1] = 0; return; } int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x); if (r &gt; mid) modify(ri(idx), l, r, x); pushup(idx);} 其中 ，代码中也是如此，但是最后有两个点 RE。这是因为 pushdown 放在了错误的位置上，在递归到单点前，会执行一次 pushdown 操作，此时就会在叶子节点的左右子树上检测懒标记（事实上没必要），在极端情况下，会访问到最后一个叶子节点的右子树（最坏 ），是肯定会 RE 的。把下传操作放在 l == r 的判断之后即可。 标记置零问题 有时，在下传操作中，在处理完当前标记之后是不能直接把标记置零的，例如（来源 P1253 扶苏的问题）： 123456789101112131415161718192021void pushdown(int idx) { if (tree[idx].que != -LLONG_MAX) { leftSubtree(idx).max = tree[idx].que; leftSubtree(idx).que = tree[idx].que; leftSubtree(idx).add = 0; rightSubtree(idx).max = tree[idx].que; rightSubtree(idx).que = tree[idx].que; rightSubtree(idx).add = 0; tree[idx].que = -LLONG_MAX; tree[idx].add = 0; } if (tree[idx].add) { leftSubtree(idx).max += tree[idx].add; leftSubtree(idx).add += tree[idx].add; rightSubtree(idx).max += tree[idx].add; rightSubtree(idx).add += tree[idx].add; tree[idx].add = 0; }} 乍一看没什么问题，但是推平标记里 tree[idx].add = 0 却是造成 WA 的元凶。清空加运算标记，其实也就意味着把整段区间的区间加标记清空。然而在递归时是有可能向该区间的某个子区间递归的，于是当前区间就会有一头一尾的部分位置不需要被处理，但是你却把它们的区间加标记清空了，显然错误。正确做法是删去这一行。 简单应用 这些是线段树的基础维护问题，用来夯实线段树基础，为拓展线段树的高级思维做铺垫。 单调性判断 例题：P6812 「MCOI-02」Ancestor 先辈 难度：普及+/提高 维护变量：区间左右端点值、区间单调性标记 题目中的区间加因为比较板子故在此省去，我们只探讨区间单调性的维护方法。 对于叶子节点，必定满足单调性，我们只需考虑向上合并时的策略。注意到如果左右子树都满足单调性，那么能够决定整体区间单调性的就只有左子树的右端点和右子树的左端点的相对大小关系。故我们只需多维护当前区间的左右端点并在上传时维护单调性标记即可，维护方法见上面的分析。因为单调性标记的维护涉及到多个变量，查询时需要用到前面讲过的复杂查询。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define N 1500010using namespace std;typedef long long ll;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(idx) (tree[le(idx)])#define rightSubtree(idx) (tree[ri(idx)]) int l, r, size; ll lazy; ll ends[2]; bool flag; } tree[N &lt;&lt; 2];ll a[N];void pushup(int idx) { tree[idx].flag = (leftSubtree(idx).flag &amp; rightSubtree(idx).flag &amp; (leftSubtree(idx).ends[1] &lt;= rightSubtree(idx).ends[0])); // 单调递增序列需满足左子树的右端点小于等于右子树的左端点 tree[idx].ends[0] = leftSubtree(idx).ends[0]; // 大区间的左端点就是左子树的左端点 tree[idx].ends[1] = rightSubtree(idx).ends[1]; // 大区间的右端点就是右子树的右端点}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; if (l == r) { tree[idx].flag = true; tree[idx].ends[0] = tree[idx].ends[1] = a[l]; return; } int mid = l + r &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void pushdown(int idx) { if (tree[idx].lazy) { leftSubtree(idx).lazy += tree[idx].lazy; leftSubtree(idx).ends[0] += tree[idx].lazy; leftSubtree(idx).ends[1] += tree[idx].lazy; rightSubtree(idx).lazy += tree[idx].lazy; rightSubtree(idx).ends[0] += tree[idx].lazy; rightSubtree(idx).ends[1] += tree[idx].lazy; tree[idx].lazy = 0; }}void modify(int idx, int l, int r, ll x) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].lazy += x; tree[idx].ends[0] += x; tree[idx].ends[1] += x; return; } pushdown(idx); int mid = tree[idx].l + tree[idx].r &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x); if (r &gt; mid) modify(ri(idx), l, r, x); pushup(idx);}// 复杂查询处理标记SegmentTree query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx]; pushdown(idx); int mid = tree[idx].l + tree[idx].r &gt;&gt; 1; if (l &gt; mid) return query(ri(idx), l, r); if (r &lt;= mid) return query(le(idx), l, r); SegmentTree L = query(le(idx), l, r); SegmentTree R = query(ri(idx), l, r); return {L.l, R.r, L.size + R.size, 0, {L.ends[0], R.ends[1]}, static_cast&lt;bool&gt;(L.flag &amp; R.flag &amp; (L.ends[1] &lt;= R.ends[0]))};}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while (k--) { int opt, l, r; cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; if (opt == 1) { ll x; cin &gt;&gt; x; modify(1, l, r, x); } else cout &lt;&lt; (query(1, l, r).flag ? \"Yes\" : \"No\") &lt;&lt; '\\n'; } return 0;} 单点修改+区间乘积正负性 例题：UVA12532 Interval Product 难度：普及+/提高 维护变量：正负性标记 我们都知道，异号相乘得负、同号相乘得正。对于叶子节点，正负性是可以确定的。那么考虑上传操作，发现我们只需得知左右子树的正负性就可以得到当前区间的正负性。因此用一个正负性标记，取值 ，那么上传时就可以用左右子树的标记乘积来更新当前区间的正负性标记。单点修改非常模板此处不再赘述。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; int flag;} tree[N &lt;&lt; 2];int a[N];void pushup(int idx) { tree[idx].flag = leftSubtree(idx).flag * rightSubtree(idx).flag; // 更新标记为左右子树的标记之积}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; if (l == r) { if (a[l] == 0) tree[idx].flag = 0; if (a[l] &gt; 0) tree[idx].flag = 1; if (a[l] &lt; 0) tree[idx].flag = -1; return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int uid, int x) { if (tree[idx].size == 1 &amp;&amp; tree[idx].l == uid) { if (x == 0) tree[idx].flag = 0; if (x &gt; 0) tree[idx].flag = 1; if (x &lt; 0) tree[idx].flag = -1; return; } int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (uid &lt;= mid) modify(le(idx), uid, x); if (uid &gt; mid) modify(ri(idx), uid, x); pushup(idx);}int query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].flag; int flag = 1; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) flag *= query(le(idx), l, r); if (r &gt; mid) flag *= query(ri(idx), l, r); return flag;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, k; while (cin &gt;&gt; n &gt;&gt; k) { for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while (k--) { char op; int l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == 'C') modify(1, l, r); else { int res = query(1, l, r); cout &lt;&lt; (res == 0 ? '0' : res &lt; 0 ? '-' : '+'); } } cout &lt;&lt; endl; } return 0;} 维护差分 线段树维护原序列的差分数组也是比较挑战思维的题型。通过维护原序列的差分序列，我们有时可以把一段区间的操作转化成对应区间端点或其邻点的单点操作。 种类数 例题：P2184 贪婪大陆 难度：普及+/提高 维护变量：区间和 像这种每次往某个区间加入一种不同种类的值，然后询问区间覆盖了几种不同的值，可以借助差分的思想。 将每个插入操作的区间看作有左右两个端点（起点、终点）的线段，因为每次插入的是不同种类的数，因此无需过多操作。对于每个 的询问，答案即为 内的起点数减去 内的终点数。也就是说 内有若干颜色段覆盖了一些区域，而 内又有一些颜色段没有覆盖到 及之后的区域，二者相减就是答案。 因此插入时暴力地增加两个端点的计数，输出时统计相减即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(idx) (tree[le(idx)])#define rightSubtree(idx) (tree[ri(idx)]) int l, r, size; int sum[2];} tree[N &lt;&lt; 2];void pushup(int idx) { tree[idx].sum[0] = leftSubtree(idx).sum[0] + rightSubtree(idx).sum[0]; tree[idx].sum[1] = leftSubtree(idx).sum[1] + rightSubtree(idx).sum[1];}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modifySt(int idx, int uid) { if (tree[idx].size == 1 &amp;&amp; tree[idx].l == uid) { tree[idx].sum[0]++; return; } int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (uid &lt;= mid) modifySt(le(idx), uid); if (uid &gt; mid) modifySt(ri(idx), uid); pushup(idx);}void modifyEd(int idx, int uid) { if (tree[idx].size == 1 &amp;&amp; tree[idx].l == uid) { tree[idx].sum[1]++; return; } int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (uid &lt;= mid) modifyEd(le(idx), uid); if (uid &gt; mid) modifyEd(ri(idx), uid); pushup(idx);}int querySt(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sum[0]; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; int ret = 0; if (l &lt;= mid) ret += querySt(le(idx), l, r); if (r &gt; mid) ret += querySt(ri(idx), l, r); return ret;}int queryEd(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sum[1]; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; int ret = 0; if (l &lt;= mid) ret += queryEd(le(idx), l, r); if (r &gt; mid) ret += queryEd(ri(idx), l, r); return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; build(1, 1, n); while (m--) { int q, l, r; cin &gt;&gt; q &gt;&gt; l &gt;&gt; r; if (q == 1) modifySt(1, l), modifyEd(1, r); else cout &lt;&lt; querySt(1, 1, r) - queryEd(1, 1, l - 1) &lt;&lt; endl; } return 0;} 区间加等差数列、单点询问 例题：P1438 无聊的数列 难度：普及+/提高 维护变量：差分数组、区间和、区间和标记 注意到等差数列差分数组中的元素除左端点外都是其公差，因此我们维护原序列的差分数组。对原数组对位加等差数列就相当于让差分数组的左端点加上首项、中间点加上公差、右端点右侧第一个点减去末项。那么进行两次单点修改和一次区间修改即可。注意到差分的前缀和是对应的点权，所以统计前缀和即可回答单点询问。注意判断等差数列的长度！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;#define N 100100using namespace std;typedef long long ll;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; ll lazy, sum;} tree[N &lt;&lt; 2];int a[N];void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum;}void pushdown(int idx) { if (tree[idx].lazy) { leftSubtree(idx).sum += tree[idx].lazy * leftSubtree(idx).size; leftSubtree(idx).lazy += tree[idx].lazy; rightSubtree(idx).sum += tree[idx].lazy * rightSubtree(idx).size; rightSubtree(idx).lazy += tree[idx].lazy; tree[idx].lazy = 0; }}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; if (l == r) { tree[idx].sum = a[l] - a[l - 1]; return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int l, int r, int x) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].lazy += x; tree[idx].sum += x * tree[idx].size; return; } pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x); if (r &gt; mid) modify(ri(idx), l, r, x); pushup(idx);}void modify(int idx, int uid, int x) { if (tree[idx].size == 1 &amp;&amp; tree[idx].l == uid) { tree[idx].sum += x; return; } pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (uid &lt;= mid) modify(le(idx), uid, x); if (uid &gt; mid) modify(ri(idx), uid, x); pushup(idx);}ll query(int idx, int uid) { if (tree[idx].r &lt;= uid) return tree[idx].sum; pushdown(idx); ll ret = 0; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; ret += query(le(idx), uid); if (uid &gt; mid) ret += query(ri(idx), uid); return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) { int opt, l, r, k, d; cin &gt;&gt; opt &gt;&gt; l; if (opt == 1) { cin &gt;&gt; r &gt;&gt; k &gt;&gt; d; modify(1, l, k); if (l &lt; r) modify(1, l + 1, r, d); // 数列长度为 1，仅单点修改 if (r &lt; n) modify(1, r + 1, (l - r) * d - k); // 右端点在最右侧，无需更改右端点右侧的差分 } else cout &lt;&lt; query(1, l) &lt;&lt; endl; } return 0;} 区间加+区间最大公约数 例题：P10463 Interval GCD 难度：提高+/省选- 维护变量：差分数组 属于是回归老祖宗的智慧了 OI 所学的最大公约数计算一般是欧几里得提出的辗转相除法，然而《九章算术》中提出的辗转相减法（更相减损术）却总是被人忽略。根据辗转相减法，，这个式子可以一直递归下去直到出现 的形式，答案就是 。这启发我们维护原序列的差分数组来操作，我们可以发现，区间加操作就转化为了差分数组两端点的修改。 除此之外，最大公约数还满足以下性质： 。 也就是说上传操作时当前区间的最大公约数就应该是左右子树二者的最大公约数的最大公约数，叶子节点的最大公约数应是它自身的值。同样的，多个数求最大公约数也可以转化为两两求解最大公约数。 总结：对于一个数列 ，它的差分数组为 ，那么数列 所有元素的最大公约数应是 。因此需要额外知道查询区间的左端点值，差分数组的前缀和即为单点值，于是再维护一个区间和即可完成。同上面那道题一样，修改左右端点时需注意边界。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define N 500010using namespace std;typedef long long ll;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; ll sum, gcd;} tree[N &lt;&lt; 2];ll a[N];void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum; tree[idx].gcd = gcd(leftSubtree(idx).gcd, rightSubtree(idx).gcd);}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; if (l == r) { tree[idx].sum = tree[idx].gcd = a[l] - a[l - 1]; return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int uid, ll x) { if (tree[idx].size == 1 &amp;&amp; tree[idx].l == uid) { tree[idx].sum += x; tree[idx].gcd += x; return; } int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (uid &lt;= mid) modify(le(idx), uid, x); if (uid &gt; mid) modify(ri(idx), uid, x); pushup(idx);}ll querySum(int idx, int r) { if (tree[idx].r &lt;= r) return tree[idx].sum; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; ll ret = 0; ret += querySum(le(idx), r); if (r &gt; mid) ret += querySum(ri(idx), r); return ret;}ll queryGcd(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].gcd; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; ll ret = 0; if (l &lt;= mid) ret = gcd(ret, queryGcd(le(idx), l, r)); if (r &gt; mid) ret = gcd(ret, queryGcd(ri(idx), l, r)); return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) { char op; int l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == 'C') { ll x; cin &gt;&gt; x; modify(1, l, x); if (r &lt; n) modify(1, r + 1, -x); } else cout &lt;&lt; abs(gcd(querySum(1, l), queryGcd(1, l + 1, r))) &lt;&lt; endl; // 注意取绝对值 } return 0;} 较复杂的序列操作 数据结构维护序列也是常考的一个点，维护二进制序列的各种操作又从中脱颖而出。由于操作的复杂性，它们有时还会涉及到多重懒标记的下传优先级和清空问题。本节重点在讲解一些序列上的经典操作的维护。 非空最大子段和 例题：GSS1 - Can you answer these queries I（单点带修请见 GSS3，维护思路完全相同） 难度：提高+/省选- 维护变量：最大前缀、最大后缀、最大子段和、区间和。 维护最大子段和考虑三种情况： 最大子段和为左侧的最大子段和 最大子段和为右侧的最大子段和 最大子段和跨区间，为左区间的最大后缀加右区间的最大前缀 最大子段和就是上述三种情况的最大值。 维护最大前缀考虑两种情况（最大后缀同理）： 最大前缀为左区间的最大前缀 最大前缀跨区间，为整个左区间和右区间的最大前缀之和 最大前/后缀就是上述两种情况的最大值。 注意选取的子段中必须包含至少一个元素（即非空最大子段和），否则不可用这种方式做。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define N 50010using namespace std;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(idx) (tree[le(idx)])#define rightSubtree(idx) (tree[ri(idx)]) int l, r; int max, lmax, rmax; int sum;} tree[N &lt;&lt; 2];int a[N];void pushup(int idx) { tree[idx].max = max(max(leftSubtree(idx).max, rightSubtree(idx).max), leftSubtree(idx).rmax + rightSubtree(idx).lmax); tree[idx].lmax = max(leftSubtree(idx).lmax, leftSubtree(idx).sum + rightSubtree(idx).lmax); tree[idx].rmax = max(rightSubtree(idx).rmax, rightSubtree(idx).sum + leftSubtree(idx).rmax); tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum;}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; if (l == r) { tree[idx].max = a[l]; tree[idx].lmax = a[l]; tree[idx].rmax = a[l]; tree[idx].sum = a[l]; return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}SegmentTree query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx]; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &gt; mid) return query(ri(idx), l, r); if (r &lt;= mid) return query(le(idx), l, r); SegmentTree L{}, R{}, res{}; L = query(le(idx), l, r); R = query(ri(idx), l, r); res.max = max(max(L.max, R.max), L.rmax + R.lmax); res.lmax = max(L.lmax, L.sum + R.lmax); res.rmax = max(R.rmax, R.sum + L.rmax); res.sum = L.sum + R.sum; return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); cin &gt;&gt; m; while (m--) { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(1, l, r).max &lt;&lt; endl; } return 0;} 有端点限制的最大子段和 例题：GSS5 - Can you answer these queries V 难度：省选/NOI- 只要解决了端点问题它就变成 GSS1 了！——这不废话吗？ 对于左右端点所在区间的位置情况进行讨论。 第一种，两端点区间无交集。那么两区间中间的区域是一定要选的，我们加上这一段的总和，然后合并左端点区间的最大后缀、右端点区间的最大前缀即可。 第二种，两区间有交集。它又可以分三类讨论，如下图： 发现三种位置关系可以用一个方法得到答案，讨论答案区间左右端点的分布：左右端点可能的分布是 、，此时答案是前者最大后缀与后者最大前缀的和；或者是同属于 ，答案是这个区间的最大子段和（简化为 GSS1）；也可能是 、，答案是前者最大后缀与后者最大前缀的和。最终就是三种情况取最大值。 为了减少特判，我们规定当查询的左边界大于右边界时即返回 ；为了避免区间求值出现端点重合而重复计算的情况，我们在最后减去重合端点的单点值（毕竟不带修）即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;typedef long long ll;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; ll sum; ll max[3];} tree[N &lt;&lt; 2];int a[N];void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum; tree[idx].max[0] = max(leftSubtree(idx).max[0], leftSubtree(idx).sum + rightSubtree(idx).max[0]); tree[idx].max[1] = max(rightSubtree(idx).max[1], rightSubtree(idx).sum + leftSubtree(idx).max[1]); tree[idx].max[2] = max( {leftSubtree(idx).max[2], rightSubtree(idx).max[2], leftSubtree(idx).max[1] + rightSubtree(idx).max[0]});}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; if (l == r) { tree[idx].sum = a[l]; tree[idx].max[0] = tree[idx].max[1] = tree[idx].max[2] = a[l]; return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}ll querySum(int idx, int l, int r) { if (l &gt; r) return 0; if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sum; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; ll ret = 0; if (l &lt;= mid) ret += querySum(le(idx), l, r); if (r &gt; mid) ret += querySum(ri(idx), l, r); return ret;}SegmentTree query(int idx, int l, int r) { if (l &gt; r) return {0, 0, 0, 0, 0, 0, 0}; if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx]; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &gt; mid) return query(ri(idx), l, r); if (r &lt;= mid) return query(le(idx), l, r); SegmentTree L = query(le(idx), l, r); SegmentTree R = query(ri(idx), l, r); SegmentTree res{}; res.sum = L.sum + R.sum; res.max[0] = max(L.max[0], L.sum + R.max[0]); res.max[1] = max(R.max[1], R.sum + L.max[1]); res.max[2] = max({L.max[2], R.max[2], L.max[1] + R.max[0]}); return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, m; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); cin &gt;&gt; m; while (m--) { int l1, r1, l2, r2; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; if (r1 &lt; l2) cout &lt;&lt; query(1, l1, r1).max[1] + querySum(1, r1, l2) + query(1, l2, r2).max[0] - a[r1] - a[l2] &lt;&lt; endl; else cout &lt;&lt; max({query(1, l2, r1).max[2], query(1, l1, r1).max[1] + query(1, r1, r2).max[0] - a[r1], query(1, l1, l2).max[1] + query(1, l2, r2).max[0] - a[l2]}) &lt;&lt; endl; } } return 0;} 实数域上整数端点的集合运算 例题：P5568 [SDOI2008] 校门外的区间 难度：提高+/省选- 来源：山东 2008 维护变量：区间和、0/1推平标记、异或标记 考虑维护一个 0/1 串，记录集合中是否有对应位置的数。对于求并操作，相当于把读入的目标区间和集合的对应位置进行按位或运算，又因为读入的区间必定是全为 1 的表示，因此可以看作区间内推平为 1；对于求交操作，则是相当于按位与运算，且目标区间外需均推平为 0，而这对集合的对应区间无影响，综合来说就是区间外推平为 0。 然后再来考虑两种减法操作。对于原集合和目标区间的相对差集（操作 ），相当于原集合减去二者的交集，那么就是目标区间内推平为 0；而对于目标区间和原集合的相对差集（操作 ）就稍微复杂一些了，原理如下图： 相当于用目标区间减去二者交集。可以发现我们只要目标区间有但是集合里没有的元素，那么目标区间外可以推平为 0。此时再让集合中有的数变没，再让没有的数出现，不难想到异或（按位 0/1 翻转）。综上，需要区间外推平为 0，再区间内异或；对于最后一个求对称差的操作，从符号可知 仔细研究规则即可发现就是区间内异或。 维护两种标记时要额外注意优先级问题。比较优先级时常用假设当前区间存在其他标记的方法来推理。当推平操作下发到一个已有异或标记的区间时，无论异或结果如何都不会改变推平的事实，可知推平标记优先级大于异或标记。当然这不代表要在区间推平下传结束后一并清空区间异或标记，详见前文提到的“标记置零问题”。 最后是处理输入输出的开闭区间。可以把原始下标都翻倍，闭区间端点的下标是偶数，开区间就是奇数。输出时可以暴力统计前缀和，然后处理出连续区间，根据下标奇偶性即可推知答案区间的开闭，再减半取整输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;#define N 140000#define UNION 1#define INTERSECT 2#define XOR 3using namespace std;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; int sum = 0; bool flagXor; int flagRev;} tree[N &lt;&lt; 2];int tmp[N];void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum;}void pushdown(int idx) { if (tree[idx].flagRev != -1) { leftSubtree(idx).flagXor = false; leftSubtree(idx).flagRev = tree[idx].flagRev; leftSubtree(idx).sum = leftSubtree(idx).size * tree[idx].flagRev; rightSubtree(idx).flagXor = false; rightSubtree(idx).flagRev = tree[idx].flagRev; rightSubtree(idx).sum = rightSubtree(idx).size * tree[idx].flagRev; tree[idx].flagRev = -1; } if (tree[idx].flagXor) { leftSubtree(idx).flagXor ^= true; leftSubtree(idx).sum = leftSubtree(idx).size - leftSubtree(idx).sum; rightSubtree(idx).flagXor ^= true; rightSubtree(idx).sum = rightSubtree(idx).size - rightSubtree(idx).sum; tree[idx].flagXor = false; }}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; tree[idx].flagRev = -1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int l, int r, int type) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { if (type == UNION) { // 区间推平成1 tree[idx].flagRev = 1; tree[idx].flagXor = false; tree[idx].sum = tree[idx].size; } else if (type == XOR) { // 异或 tree[idx].flagXor ^= true; tree[idx].sum = tree[idx].size - tree[idx].sum; } else if (type == INTERSECT) { // 区间推平为0 tree[idx].flagRev = 0; tree[idx].flagXor = false; tree[idx].sum = 0; } return; } pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, type); if (r &gt; mid) modify(ri(idx), l, r, type); pushup(idx);}int query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sum; pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; int ret = 0; if (l &lt;= mid) ret += query(le(idx), l, r); if (r &gt; mid) ret += query(ri(idx), l, r); return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); char op, lpath, comma, rpath; int a, b, R = 0; build(1, 0, 65535 &lt;&lt; 1); while (cin &gt;&gt; op) { cin &gt;&gt; lpath &gt;&gt; a &gt;&gt; comma &gt;&gt; b &gt;&gt; rpath; a &lt;&lt;= 1, b &lt;&lt;= 1; if (lpath == '(') a++; if (rpath == ')') b--; if (b &lt; a) continue; R = max(R, b); // 记录最大右端点 switch (op) { case 'U': // 并集 目标区间内推平为1 modify(1, a, b, UNION); break; case 'D': // 相对差集 目标区间内推平为0 modify(1, a, b, INTERSECT); break; case 'I': // 交集 目标区间外推平为0 if (a) modify(1, 0, a - 1, INTERSECT); if (b &lt; 65535 &lt;&lt; 1) modify(1, b + 1, 65535 &lt;&lt; 1, INTERSECT); break; case 'C': // 逆相对差集 目标区间内异或，且区间外推平为0 modify(1, a, b, XOR); if (a) modify(1, 0, a - 1, INTERSECT); if (b &lt; 65535 &lt;&lt; 1) modify(1, b + 1, 65535 &lt;&lt; 1, INTERSECT); break; case 'S': // 对称差 目标区间内异或 default: modify(1, a, b, XOR); break; } } int t = query(1, 0, R); // 检查前缀和，为 0 则为空集 if (!t) cout &lt;&lt; \"empty set\" &lt;&lt; endl; else { for (int i = 0; i &lt;= R + 2; i++) tmp[i] = query(1, 0, i); // 前缀和 int last = 0, lastI = -2; for (int i = 0; i &lt;= R; i++) { if (tmp[i] - last) { if (i - lastI &gt; 1) cout &lt;&lt; (i &amp; 1 ? '(' : '[') &lt;&lt; (i &gt;&gt; 1) &lt;&lt; ','; // 根据奇偶性判断括号 if (tmp[i + 1] == tmp[i]) cout &lt;&lt; (i + 1 &gt;&gt; 1) &lt;&lt; (i &amp; 1 ? ')' : ']') &lt;&lt; ' '; last = tmp[i]; lastI = i; } } } return 0;} 区间推平+区间翻转+最大连续数（01串） 例题：P2572 序列操作 题目难度：提高+/省选- 题目来源：四川 2010 各省省选 维护变量：区间左端最大连续数、区间右端最大连续数、区间最大连续数、区间大小、区间和 最大连续数考虑三种情况： 左区间最大连续数 右区间最大连续数 跨区间，左区间右端最大连续数与右区间左端最大连续数 最大左端连续数（右端同理）考虑两种情况： 不可跨区间，为左区间最大左端连续数 可以跨区间（左区间均为同一个数），那么为左区间最大左端连续数与右区间最大左端连续数之和 标记优先级推平大于翻转。注意当前区间如果已经存在一个推平标记，那么下传翻转标记时就需要把推平标记取反。推平后相应数字的最大连续数均设置成区间长度、另一个数字的最大连续数设为 ，此时的区间的和就是该区间的长度减去先前记录的区间和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(idx) (tree[le(idx)])#define rightSubtree(idx) (tree[ri(idx)]) int l, r; int que, rev; int lmax[2], rmax[2], max[2]; int sum, size;} tree[N &lt;&lt; 2];int a[N];void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum; for (int i = 0; i &lt;= 1; i++) { tree[idx].max[i] = max(max(leftSubtree(idx).max[i], rightSubtree(idx).max[i]), leftSubtree(idx).rmax[i] + rightSubtree(idx).lmax[i]); // 最大连续数的三种情况 tree[idx].lmax[i] = leftSubtree(idx).lmax[i]; // 左端最大连续为左子树的左端最大连续 if (leftSubtree(idx).sum == i * leftSubtree(idx).size) tree[idx].lmax[i] += rightSubtree(idx).lmax[i]; // 可以跨区间，加入右子树的左端最大连续 tree[idx].rmax[i] = rightSubtree(idx).rmax[i]; // 右端最大连续为右子树的右端最大连续 if (rightSubtree(idx).sum == i * rightSubtree(idx).size) tree[idx].rmax[i] += leftSubtree(idx).rmax[i]; // 可以跨区间，加入左子树的右端最大连续 }}void pushdown(int idx) { if (tree[idx].que &gt;= 0) { int tag = tree[idx].que; // 下传推平标记 leftSubtree(idx).lmax[tag] = leftSubtree(idx).rmax[tag] = leftSubtree(idx).max[tag] = leftSubtree(idx).size; // 推平的那个数的最大连续均变为子树大小 rightSubtree(idx).lmax[tag] = rightSubtree(idx).rmax[tag] = rightSubtree(idx).max[tag] = rightSubtree(idx).size; leftSubtree(idx).lmax[tag ^ 1] = leftSubtree(idx).rmax[tag ^ 1] = leftSubtree(idx).max[tag ^ 1] = 0; // 反之，另一个数的最大连续均变为0 rightSubtree(idx).lmax[tag ^ 1] = rightSubtree(idx).rmax[tag ^ 1] = rightSubtree(idx).max[tag ^ 1] = 0; leftSubtree(idx).sum = leftSubtree(idx).size * tag; // 维护和 rightSubtree(idx).sum = rightSubtree(idx).size * tag; leftSubtree(idx).que = tag; leftSubtree(idx).rev = 0; rightSubtree(idx).que = tag; rightSubtree(idx).rev = 0; tree[idx].que = -1; tree[idx].rev = 0; } if (tree[idx].rev) { leftSubtree(idx).sum = leftSubtree(idx).size - leftSubtree(idx).sum; rightSubtree(idx).sum = rightSubtree(idx).size - rightSubtree(idx).sum; swap(leftSubtree(idx).lmax[0], leftSubtree(idx).lmax[1]); // 0/1互换，最大连续也互换 swap(leftSubtree(idx).rmax[0], leftSubtree(idx).rmax[1]); swap(leftSubtree(idx).max[0], leftSubtree(idx).max[1]); swap(rightSubtree(idx).lmax[0], rightSubtree(idx).lmax[1]); swap(rightSubtree(idx).rmax[0], rightSubtree(idx).rmax[1]); swap(rightSubtree(idx).max[0], rightSubtree(idx).max[1]); if (leftSubtree(idx).que &gt;= 0) leftSubtree(idx).que ^= 1; // 如果先有了推平，那么相当于推平成另一个数 else leftSubtree(idx).rev ^= 1; if (rightSubtree(idx).que &gt;= 0) rightSubtree(idx).que ^= 1; else rightSubtree(idx).rev ^= 1; tree[idx].rev = 0; }}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; tree[idx].que = -1; if (l == r) { tree[idx].sum = a[l]; tree[idx].lmax[a[l]] = tree[idx].rmax[a[l]] = tree[idx].max[a[l]] = 1; tree[idx].lmax[a[l] ^ 1] = tree[idx].rmax[a[l] ^ 1] = tree[idx].max[a[l] ^ 1] = 0; return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int l, int r, int x) { pushdown(idx); if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].sum = x * tree[idx].size; tree[idx].que = x; tree[idx].lmax[x] = tree[idx].rmax[x] = tree[idx].max[x] = tree[idx].size; tree[idx].lmax[x ^ 1] = tree[idx].rmax[x ^ 1] = tree[idx].max[x ^ 1] = 0; return; } int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x); if (r &gt; mid) modify(ri(idx), l, r, x); pushup(idx);}void reverse(int idx, int l, int r) { pushdown(idx); if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].sum = tree[idx].size - tree[idx].sum; tree[idx].rev ^= 1; swap(tree[idx].lmax[0], tree[idx].lmax[1]); swap(tree[idx].rmax[0], tree[idx].rmax[1]); swap(tree[idx].max[0], tree[idx].max[1]); return; } int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) reverse(le(idx), l, r); if (r &gt; mid) reverse(ri(idx), l, r); pushup(idx);}int queryTotal(int idx, int l, int r) { pushdown(idx); if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sum; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; int res = 0; if (l &lt;= mid) res += queryTotal(le(idx), l, r); if (r &gt; mid) res += queryTotal(ri(idx), l, r); return res;}SegmentTree queryMax(int idx, int l, int r) { pushdown(idx); if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx]; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &gt; mid) return queryMax(ri(idx), l, r); if (r &lt;= mid) return queryMax(le(idx), l, r); SegmentTree L{}, R{}, res{}; L = queryMax(le(idx), l, r); R = queryMax(ri(idx), l, r); for (int i = 0; i &lt;= 1; i++) { res.max[i] = max(max(L.max[i], R.max[i]), L.rmax[i] + R.lmax[i]); res.lmax[i] = L.lmax[i]; if (L.sum == i * L.size) res.lmax[i] += R.lmax[i]; res.rmax[i] = R.rmax[i]; if (R.sum == i * R.size) res.rmax[i] += L.rmax[i]; } res.sum = L.sum + R.sum; res.size = L.size + R.size; return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) { int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; x++, y++; // 勿删！ if (op == 0) modify(1, x, y, 0); else if (op == 1) modify(1, x, y, 1); else if (op == 2) reverse(1, x, y); else if (op == 3) cout &lt;&lt; queryTotal(1, x, y) &lt;&lt; endl; else cout &lt;&lt; queryMax(1, x, y).max[1] &lt;&lt; endl; } return 0;} 维护数学运算 针对区间待修和区间查询的问题， 我们一般会首先想到线段树，在一些区间数学操作的题目中也不例外。尽管这些数学运算并不一定具备结合律，有时我们仍然可以通过它们的其他性质（短时性，不会进行太多次操作就会变为可做的形式）来转化为简单维护问题去解决。本节就精选了一些线段树维护数学运算的例子。 区间开方+区间和 例题：GSS4 - Can you answer these queries IV 题目难度：提高+/省选- 维护变量： 区间和、区间开方判别标记 由于平方根下求和没有计算公式，但是考虑到像 这样的大数据，在经过 次开方后都会变成 ，而 。这就是开方运算的短时性。它启发我们把区间修改变为暴力单点修改，记录一下当前数开方后是否等于 或 ，如果是则给它做一个标记、并向上更新标记。如果区间被标记，更改时则无需递归进去，简化了大量操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;typedef long long ll;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(idx) (tree[le(idx)])#define rightSubtree(idx) (tree[ri(idx)]) int l, r; ll sum;} tree[N &lt;&lt; 2];ll a[N];inline void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum;}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; if (l == r) { tree[idx].sum = a[l]; return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}inline void modify(int idx, int l, int r) { if (tree[idx].sum &lt;= tree[idx].r - tree[idx].l + 1) return; // 已经全为 0/1，开方后不变 if (tree[idx].l == tree[idx].r) { tree[idx].sum = static_cast&lt;ll&gt;(sqrt(tree[idx].sum)); // 否则暴力单点修改 return; } int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r); if (r &gt; mid) modify(ri(idx), l, r); pushup(idx);}inline ll query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sum; int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; ll res = 0; if (l &lt;= mid) res += query(le(idx), l, r); if (r &gt; mid) res += query(ri(idx), l, r); return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, c = 0; while (cin &gt;&gt; n) { memset(tree, 0, sizeof tree); memset(a, 0, sizeof a); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); cout &lt;&lt; \"Case #\" &lt;&lt; ++c &lt;&lt; \":\\n\"; int q; cin &gt;&gt; q; while (q--) { int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (x &gt; y) swap(x, y); if (op == 0) modify(1, x, y); else cout &lt;&lt; query(1, x, y) &lt;&lt; '\\n'; } cout &lt;&lt; '\\n'; } return 0;} 区间加+区间sin和 例题：P6327 区间加区间 sin 和 题目难度：提高+/省选- 维护变量：区间 和、区间 和、角度加法懒标记 正余弦函数显然具备结合律。根据正弦值的和角公式：，这里维护一个加法懒标记，在下传时使用和角公式一次性计算、同时维护 和即可。注意需要把相关 和 值存成变量再更新，否则答案错误（这样连样例都能过）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;#define N 200010using namespace std;const double EPS = 1e-8;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; double sin, cos; double lazy;} tree[N &lt;&lt; 2];double a[N];void pushup(int idx) { tree[idx].sin = leftSubtree(idx).sin + rightSubtree(idx).sin; tree[idx].cos = leftSubtree(idx).cos + rightSubtree(idx).cos;}void pushdown(int idx) { if (abs(tree[idx].lazy) &gt; EPS) { double SIN = sin(tree[idx].lazy), COS = cos(tree[idx].lazy); // 需要先存成变量，否则变量中途修改会影响其他变量 double LSIN = leftSubtree(idx).sin, LCOS = leftSubtree(idx).cos; double RSIN = rightSubtree(idx).sin, RCOS = rightSubtree(idx).cos; leftSubtree(idx).sin = SIN * LCOS + COS * LSIN; // sin 和角公式 leftSubtree(idx).cos = COS * LCOS - SIN * LSIN; // cos 和角公式 leftSubtree(idx).lazy += tree[idx].lazy; rightSubtree(idx).sin = SIN * RCOS + COS * RSIN; rightSubtree(idx).cos = COS * RCOS - SIN * RSIN; rightSubtree(idx).lazy += tree[idx].lazy; tree[idx].lazy = 0.0; }}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; tree[idx].lazy = 0.0; if (l == r) { tree[idx].sin = sin(a[l]); tree[idx].cos = cos(a[l]); return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int l, int r, double x) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { double SIN = tree[idx].sin, COS = tree[idx].cos; // 同理，需要预先存成变量 double SINX = sin(x), COSX = cos(x); tree[idx].sin = SIN * COSX + COS * SINX; tree[idx].cos = COS * COSX - SIN * SINX; tree[idx].lazy += x; return; } pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x); if (r &gt; mid) modify(ri(idx), l, r, x); pushup(idx);}double query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sin; pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; double ret = 0.0; if (l &lt;= mid) ret += query(le(idx), l, r); if (r &gt; mid) ret += query(ri(idx), l, r); return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); cin &gt;&gt; m; while (m--) { int op, l, r; double v; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == 1) { cin &gt;&gt; v; modify(1, l, r, v); } else cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; query(1, l, r) &lt;&lt; endl; } return 0;} 区间加+区间平均数+区间方差 例题：P1471 方差 题目难度：提高+/省选- 维护变量：区间平方和、区间和 方差公式：，展开化简得 。因此维护平方和用于计算分数部分。进行区间加时，维护平方和有这个公式：。具备结合律。我们按照公式维护即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;typedef long long ll;const double EPS = 1e-8;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; double sum, sumSq; double lazy, lazySq;} tree[N &lt;&lt; 2];double a[N];void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum; tree[idx].sumSq = leftSubtree(idx).sumSq + rightSubtree(idx).sumSq;}void pushdown(int idx) { if (abs(tree[idx].lazySq) &gt; EPS) { leftSubtree(idx).sumSq += 2 * leftSubtree(idx).sum * tree[idx].lazySq + leftSubtree(idx).size * tree[idx].lazySq * tree[idx].lazySq; leftSubtree(idx).lazySq += tree[idx].lazySq; rightSubtree(idx).sumSq += 2 * rightSubtree(idx).sum * tree[idx].lazySq + rightSubtree(idx).size * tree[idx].lazySq * tree[idx].lazySq; rightSubtree(idx).lazySq += tree[idx].lazySq; tree[idx].lazySq = 0; } if (abs(tree[idx].lazy) &gt; EPS) { leftSubtree(idx).sum += leftSubtree(idx).size * tree[idx].lazy; leftSubtree(idx).lazy += tree[idx].lazy; rightSubtree(idx).sum += rightSubtree(idx).size * tree[idx].lazy; rightSubtree(idx).lazy += tree[idx].lazy; tree[idx].lazy = 0; }}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; if (l == r) { tree[idx].sum = a[l]; tree[idx].sumSq = a[l] * a[l]; return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int l, int r, double x) { if(l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].sumSq += 2 * tree[idx].sum * x + tree[idx].size * x * x; tree[idx].lazySq += x; tree[idx].sum += x * tree[idx].size; tree[idx].lazy += x; return; } pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x); if (r &gt; mid) modify(ri(idx), l, r, x); pushup(idx);}double querySum(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sum; pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; double ret = 0.0; if (l &lt;= mid) ret += querySum(le(idx), l, r); if (r &gt; mid) ret += querySum(ri(idx), l, r); return ret;}double querySumSq(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sumSq; pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; double ret = 0.0; if (l &lt;= mid) ret += querySumSq(le(idx), l, r); if (r &gt; mid) ret += querySumSq(ri(idx), l, r); return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) { int op, l, r; double x; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; int size = r - l + 1; if (op == 1) { cin &gt;&gt; x; modify(1, l, r, x); } else if (op == 2) cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; querySum(1, l, r) / size &lt;&lt; endl; else cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; querySumSq(1, l, r) / size - pow(querySum(1, l, r) / size, 2) &lt;&lt; endl; } return 0;} 维护历史最值/历史操作 提到历史操作，我们可能会想到线段树家族的一个分支——可持久化线段树/主席树（或者是吉司机线段树），它通过复制修改时经过的相关节点来实现对某一历史操作的高效维护，更为详细的内容见此。一般来说，涉及到历史最值的线段树都需要在平常维护的普通标记上分别新增一个历史最值标记，进而可能涉及到众多懒标记的维护，因此懒标记之间的维护优先级（分类讨论）也是必须弄清的一大重点。 多标记维护有一个很明显的缺点是分类讨论繁杂、码量膨胀迅速。事实上，除了多标记硬维护，我们还可以稍稍更改矩阵乘法的定义，使用广义矩阵乘法来解决历史最值问题。如果对矩阵乘法不太了解的请左转 矩阵乘法相关，对矩阵构造不太了解的请右转 初等矩阵与矩阵递推。 多标记历史最值 例题：P4314 CPU 监控 难度：省选/NOI- 维护变量：区间加懒标记、区间推平懒标记、区间推平存在性标记、区间历史最大加法懒标记、区间历史最大推平懒标记 简化题意。：查询区间最大值；：查询区间曾经出现过的所有值的最大值；：区间加；：区间推平。 首先，维护区间加和区间推平标记是必须的。注意到，在某一次进行了一次推平操作，后到的区间加本质上就是区间推平（即区间推平优先级高于区间加）。我们其实只需考虑首次区间推平前的所有区间加操作与它之间的关系。总而言之，对于一段区间的所有操作，我们都可以把它简化成一次区间加法后接一次区间推平。 根据优先级关系可得：如果之前已经对区间进行过推平，且当前要对这个区间进行区间加，那么我们就把区间加变成区间推平，只不过推平的数是原来的数加上区间加的操作数。否则就正常执行区间加。这里我们使用一个推平存在性标记来区分曾经执行过推平的区间和没执行过推平的区间。 接下来是重点，我们要更新历史最值的标记。对于推平操作，如果曾经推平过，就是原先的历史最大值与推平数取最大值、否则标记当前区间为存在过推平，且把历史最大值赋值成操作数；对于区间加，如果存在推平则转化为推平、否则历史标记更新为当前区间的历史标记与操作数总和的最大值。然后是正常加法标记、推平标记和区间最大值的更新，不要忘了用历史值更新当前历史最大值。 这里使用了复杂查询，其实可以只用简单查询，但是这样会让一个函数变成两个函数，比较占用篇幅。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt;#define N 100010#define ADD 0#define COV 1using namespace std;struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; bool flag_cov; int lazy_add, lazy_cov, h_lazy_add, h_lazy_cov; int max, hmax; void cover(int x, int hx) { if (flag_cov) h_lazy_cov = std::max(h_lazy_cov, hx); // 存在推平 else flag_cov = true, h_lazy_cov = hx; // 不存在推平，标记并更新 hmax = std::max(hmax, hx); max = x; lazy_cov = x; lazy_add = 0; } void add(int x, int hx) { if (flag_cov) cover(lazy_cov + x, lazy_cov + hx); // 存在推平，转化为推平 else { h_lazy_add = std::max(h_lazy_add, lazy_add + hx); // 正常维护区间加法 hmax = std::max(hmax, max + hx); lazy_add += x; max += x; } }} tree[N &lt;&lt; 2];int a[N];void pushup(int idx) { tree[idx].max = max(leftSubtree(idx).max, rightSubtree(idx).max); tree[idx].hmax = max(leftSubtree(idx).hmax, rightSubtree(idx).hmax);}void pushdown(int idx) { if (tree[idx].lazy_add || tree[idx].h_lazy_add) { leftSubtree(idx).add(tree[idx].lazy_add, tree[idx].h_lazy_add); rightSubtree(idx).add(tree[idx].lazy_add, tree[idx].h_lazy_add); tree[idx].lazy_add = tree[idx].h_lazy_add = 0; } if (tree[idx].flag_cov) { leftSubtree(idx).cover(tree[idx].lazy_cov, tree[idx].h_lazy_cov); rightSubtree(idx).cover(tree[idx].lazy_cov, tree[idx].h_lazy_cov); tree[idx].lazy_cov = tree[idx].h_lazy_cov = 0; tree[idx].flag_cov = false; }}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; tree[idx].max = tree[idx].hmax = -INT_MAX; if (l == r) { tree[idx].max = tree[idx].hmax = a[l]; return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int l, int r, int x, int type) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { if (type == COV) tree[idx].cover(x, x); else if (type == ADD) tree[idx].add(x, x); return; } pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x, type); if (r &gt; mid) modify(ri(idx), l, r, x, type); pushup(idx);}SegmentTree query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx]; pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &gt; mid) return query(ri(idx), l, r); if (r &lt;= mid) return query(le(idx), l, r); SegmentTree L = query(le(idx), l, r); SegmentTree R = query(ri(idx), l, r); SegmentTree res{}; res.l = L.l, res.r = R.r, res.size = L.size + R.size; res.max = max(L.max, R.max), res.hmax = max(L.hmax, R.hmax); return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); cin &gt;&gt; m; while (m--) { char op; int l, r, x; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == 'Q') cout &lt;&lt; query(1, l, r).max &lt;&lt; endl; else if (op == 'A') cout &lt;&lt; query(1, l, r).hmax &lt;&lt; endl; else if (op == 'P') { cin &gt;&gt; x; modify(1, l, r, x, ADD); } else { cin &gt;&gt; x; modify(1, l, r, x, COV); } } return 0;} 广义矩阵乘法历史最值 例题：P4314 CPU 监控 难度：省选/NOI- 维护变量：广义矩阵和、广义矩阵乘法标记 一题多解，多题归一 对于当前最值和历史最值组成的向量 ，我们自然希望它在操作后变成我们希望的样子，也就是变成 。一般采取的措施是重定义矩阵元素间的运算。 重定义矩阵元素间的加法为取最大值、元素间的乘法为代数加法。因此对于一段区间，和式 就同时维护了当前区间的最大值和历史最大值；乘积 维护了单点操作后的最大值和历史最大值。 在新定义下，我们需要重定义零矩阵和单位矩阵。根据定义，零矩阵乘任何矩阵都是一个零矩阵，可以构造出广义零矩阵 ；单位矩阵乘任何矩阵都是后者，因此构造广义单位矩阵 。 突然发现还有一个区间推平需要我们维护。换句话说，针对原矩阵 ，构造一个右乘矩阵使得二者乘积为 。发现似乎构造不出普通的 转移矩阵使条件成立，因此考虑升维。如果原始矩阵是 ，转移矩阵是 的话就符合要求了。相应的，区间加操作的转移矩阵需变成 。 于是我们把问题转化成了询问区间矩阵和与区间乘矩阵的问题了，只需维护区间矩阵和、乘数矩阵标记即可。需要注意的是，懒标记的初始值应为广义单位矩阵、区间和的初始值应该是广义零矩阵。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;bits/stdc++.h&gt;#define N 100010#define ADD 0#define COV 1using namespace std;typedef long long ll;const ll INF = 1e18;struct Matrix { ll mat[3][3]{}; void O() { // 广义零矩阵 for (auto &amp;i: mat) { for (ll &amp;j: i) { j = -INF; } } } void I() { // 广义单位矩阵 for (auto &amp;i: mat) { for (ll &amp;j: i) { j = -INF; } } mat[0][0] = mat[1][1] = mat[2][2] = 0; } bool isI() { // 判断是否是广义单位矩阵 for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (i ^ j &amp;&amp; mat[i][j] != -INF) return false; if (i == j &amp;&amp; mat[i][j]) return false; } } return true; }};Matrix fill(int x, int type) { // 根据不同操作填充对应转移矩阵 if (type == ADD) return {{{x, x, -INF}, {-INF, 0, -INF}, {-INF, -INF, 0}}}; return {{{-INF, -INF, -INF}, {-INF, 0, -INF}, {x, x, 0}}};}Matrix operator*(const Matrix &amp;l, const Matrix &amp;r) { // 广义矩阵乘法 Matrix ret; ret.O(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { for (int k = 0; k &lt; 3; k++) { ret.mat[i][j] = max(ret.mat[i][j], l.mat[i][k] + r.mat[k][j]); } } } return ret;}Matrix operator+(const Matrix &amp;l, const Matrix &amp;r) { // 广义矩阵加法 Matrix ret; ret.O(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { ret.mat[i][j] = max(l.mat[i][j], r.mat[i][j]); } } return ret;}struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; Matrix lazy, sum;} tree[N &lt;&lt; 2];int a[N];void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum;}void pushdown(int idx) { if (!tree[idx].lazy.isI()) { // 存在标记（不为广义单位矩阵） leftSubtree(idx).sum = leftSubtree(idx).sum * tree[idx].lazy; leftSubtree(idx).lazy = leftSubtree(idx).lazy * tree[idx].lazy; rightSubtree(idx).sum = rightSubtree(idx).sum * tree[idx].lazy; rightSubtree(idx).lazy = rightSubtree(idx).lazy * tree[idx].lazy; tree[idx].lazy.I(); // 清空成广义单位矩阵 }}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; tree[idx].lazy.I(); // 特别注意标记和区间和的清空 tree[idx].sum.O(); if (l == r) { tree[idx].sum = {{{a[l], a[l], 0}, {-INF, -INF, -INF}, {-INF, -INF, -INF}}}; return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int l, int r, int x, int type) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].sum = tree[idx].sum * fill(x, type); tree[idx].lazy = tree[idx].lazy * fill(x, type); return; } pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x, type); if (r &gt; mid) modify(ri(idx), l, r, x, type); pushup(idx);}SegmentTree query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx]; pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &gt; mid) return query(ri(idx), l, r); if (r &lt;= mid) return query(le(idx), l, r); SegmentTree L = query(le(idx), l, r); SegmentTree R = query(ri(idx), l, r); SegmentTree res{}; res.l = L.l, res.r = R.r, res.size = L.size + R.size; res.sum = L.sum + R.sum; return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); cin &gt;&gt; m; while (m--) { char op; int l, r, x; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == 'Q') cout &lt;&lt; query(1, l, r).sum.mat[0][0] &lt;&lt; endl; else if (op == 'A') cout &lt;&lt; query(1, l, r).sum.mat[0][1] &lt;&lt; endl; else if (op == 'P') { cin &gt;&gt; x; modify(1, l, r, x, ADD); } else { cin &gt;&gt; x; modify(1, l, r, x, COV); } } return 0;} 维护其他结合律算符 线段树的基本操作就基于子节点向当前节点的合并更新与当前节点向子节点的递归，对于具有结合律的算符，线段树能做到很好的 维护并查询。本节将重点探讨线段树维护结合律算符的部分实例。 区间加+区间斐波那契数求和 例题：CF718C Sasha and Array 难度：省选/NOI- 维护变量： 矩阵和、 矩阵加法标记 理论基础：矩阵加速递推 斐波那契数列 我在 11 月 23 日斐波那契日写下这段线段树维护斐波那契数列的文字…… 我们知道矩阵快速幂可以在 的时间复杂度内快速求出斐波那契数列第 项，那么怎么把它运用在这道题中呢？ 这道题要求将区间里的每个数作为下标并获得对应的斐波那契数并对其求和，不妨把区间加运算看作将当前的节点维护的斐波那契数继续向后递推 项，思路就出来了——在线段树的每个节点上维护一个矩阵，每次更新相当于对它右乘一个转移矩阵的 次幂，求和时在矩阵间进行加法运算。可以通过维护一个懒标记实现，注意下传标记时对子树标记进行矩阵乘法运算，因而懒标记的初始值应为单位矩阵、区间和的初始值应为零矩阵。 尽管此题时限有足足五秒，但仍然卡常。建议减少取模次数、展开计算矩阵乘法。我的代码在 C++17 标准下好像最后一个点会超时，换成 C++20 或 C++23（仅 CF）就快得多了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;#define N 100010#define MOD 1000000007using namespace std;typedef long long ll;struct Matrix { ll mat[3][3]{}; Matrix() { mat[1][1] = mat[1][2] = mat[2][1] = mat[2][2] = 0; // 慎用 memset } Matrix(int a, int b, int c, int d) { // 快速赋值 mat[1][1] = a; mat[1][2] = b; mat[2][1] = c; mat[2][2] = d; } Matrix operator+(Matrix b) const { // 矩阵加法 对位相加 Matrix ret; ret.mat[1][1] = (mat[1][1] + b.mat[1][1]) % MOD; ret.mat[1][2] = (mat[1][2] + b.mat[1][2]) % MOD; ret.mat[2][1] = (mat[2][1] + b.mat[2][1]) % MOD; ret.mat[2][2] = (mat[2][2] + b.mat[2][2]) % MOD; return ret; } Matrix operator*(Matrix b) const { // 矩阵乘法的展开形式 Matrix ret; ret.mat[1][1] = (mat[1][1] * b.mat[1][1] + mat[1][2] * b.mat[2][1]) % MOD; ret.mat[1][2] = (mat[1][1] * b.mat[1][2] + mat[1][2] * b.mat[2][2]) % MOD; ret.mat[2][1] = (mat[2][1] * b.mat[1][1] + mat[2][2] * b.mat[1][2]) % MOD; ret.mat[2][2] = (mat[2][1] * b.mat[1][2] + mat[2][2] * b.mat[2][2]) % MOD; return ret; } Matrix operator^(ll b) const { // 重载异或算符实现矩阵快速幂 Matrix ret, a = *this; ret.I(); while (b) { if (b &amp; 1) ret = ret * a; a = a * a; b &gt;&gt;= 1; } return ret; } void I() { // 生成单位矩阵，置零是必须的 mat[1][2] = mat[2][1] = 0; mat[1][1] = mat[2][2] = 1; } bool isI() { return mat[1][1] == 1 &amp;&amp; mat[1][2] == 0 &amp;&amp; mat[2][1] == 0 &amp;&amp; mat[2][2] == 1; // 判断是否是单位矩阵（是否存在懒标记） }};struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; Matrix lazy, sum;} tree[N &lt;&lt; 2];const Matrix A(1, 1, 0, 0), M(0, 1, 1, 1);ll a[N];void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum;}void pushdown(int idx) { if (!tree[idx].lazy.isI()) { leftSubtree(idx).sum = leftSubtree(idx).sum * tree[idx].lazy; // 注意是乘法 leftSubtree(idx).lazy = leftSubtree(idx).lazy * tree[idx].lazy; rightSubtree(idx).sum = rightSubtree(idx).sum * tree[idx].lazy; rightSubtree(idx).lazy = rightSubtree(idx).lazy * tree[idx].lazy; tree[idx].lazy.I(); // 重置为单位矩阵 }}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; tree[idx].lazy.I(); if (l == r) { tree[idx].sum = A * (M ^ (a[l] - 1)); // 初始值就是斐波那契数列第 a[i] 项 return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int l, int r, ll x) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].sum = tree[idx].sum * (M ^ x); // 向后递推 x 项 tree[idx].lazy = tree[idx].lazy * (M ^ x); return; } pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x); if (r &gt; mid) modify(ri(idx), l, r, x); pushup(idx);}Matrix query(int idx, int l, int r) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sum; pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; Matrix ret; if (l &lt;= mid) ret = ret + query(le(idx), l, r); if (r &gt; mid) ret = ret + query(ri(idx), l, r); return ret;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) { int op, l, r; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if (op == 1) { ll x; cin &gt;&gt; x; modify(1, l, r, x); } else cout &lt;&lt; query(1, l, r).mat[1][1] &lt;&lt; endl; } return 0;} 线段树二分 有时我们会遇到二分和线段树结合起来的题。如果使用二分区间加区间查询的方案，其时间复杂度将是 ，在 的时候会超时。此时可以借助线段树的有序性，在线段树上二分。 例题：P11217 youyou 的垃圾桶 题目难度：普及+/提高 维护变量：区间和、区间加标记 我们知道线段树可以维护一段连续的区间，这意味着我们可以在上面二分一个具有单调性的值。在线段树的最底层，从左到右分别就对应着原序列从左到右的元素。当我们需要对某个区间进行二分时，转换到树上就是看左右子树——若左子树的总和仍小于查询值，那么就在右子树查找原值减去左子树总和的值即可；否则就转到左子树找查询值。可以发现，这个逻辑和平衡树根据排名查询对应值是一样的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;#define N 200010using namespace std;typedef long long ll;int a[N];struct SegmentTree {#define le(idx) (idx &lt;&lt; 1)#define ri(idx) (idx &lt;&lt; 1 | 1)#define leftSubtree(idx) (tree[le(idx)])#define rightSubtree(idx) (tree[ri(idx)]) int l, r; ll sum; ll lazy; int size;} tree[N &lt;&lt; 2];void pushup(int idx) { tree[idx].sum = leftSubtree(idx).sum + rightSubtree(idx).sum;}void build(int idx, int l, int r) { tree[idx].lazy = tree[idx].sum = 0; tree[idx].size = r - l + 1; tree[idx].l = l, tree[idx].r = r; if (l == r) { tree[idx].sum = a[l]; return; } int mid = l + r &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void pushdown(int idx) { if (tree[idx].lazy) { leftSubtree(idx).lazy += tree[idx].lazy; leftSubtree(idx).sum += leftSubtree(idx).size * tree[idx].lazy; rightSubtree(idx).lazy += tree[idx].lazy; rightSubtree(idx).sum += rightSubtree(idx).size * tree[idx].lazy; tree[idx].lazy = 0; }}void modify(int idx, int l, int r, ll x) { if (tree[idx].l &gt; r || tree[idx].r &lt; l) return; if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].sum += x * tree[idx].size; tree[idx].lazy += x; return; } pushdown(idx); int mid = tree[idx].l + tree[idx].r &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x); if (r &gt; mid) modify(ri(idx), l, r, x); pushup(idx);}ll query(int idx, int l, int r) { if (tree[idx].l &gt; r || tree[idx].r &lt; l) return 0; if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) return tree[idx].sum; pushdown(idx); int mid = tree[idx].l + tree[idx].r &gt;&gt; 1; ll ret = 0; if (l &lt;= mid) ret += query(le(idx), l, r); if (r &gt; mid) ret += query(ri(idx), l, r); return ret;}int get(int idx, ll x, ll amp) { // 线段树二分 if (tree[idx].l == tree[idx].r) return tree[idx].l; pushdown(idx); if (leftSubtree(idx).sum &lt;&lt; amp &gt;= x) return get(le(idx), x, amp); return get(ri(idx), x - (leftSubtree(idx).sum &lt;&lt; amp), amp);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, q; ll w; cin &gt;&gt; n &gt;&gt; q &gt;&gt; w; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while (q--) { int l, r, d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; d; modify(1, l, r, d); ll sum = tree[1].sum; ll cur = 0; ll k = 2, i = 1; for (;; i++) { cur += sum * (k &gt;&gt; 1); if (cur &gt;= w) break; k &lt;&lt;= 1; } cout &lt;&lt; n * (i - 1) + get(1, w - sum * ((k &gt;&gt; 1) - 1), i - 1) - 1 &lt;&lt; '\\n'; } return 0;} 例题：P11289 【MX-S6-T1】「KDOI-11」打印 题目难度：普及+/提高 维护变量：区间加标记、等待时间、区间等待时间最小值 才复习的线段树结果赛时还是没想到线段树做法 对于每个打印请求，我们预先把它们按照起始时间升序排序，然后再一个一个考虑。维护当前时间，读入到一个请求时，相当于要把当前时间后移到该请求的起始时间。此时我们让所有打印机的等待时间减去二者差值，并找出序号最小的那个打印机、更新选中打印机的等待时间、接着更新答案即可。注意等待时间最小为 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;#define N 200010using namespace std;typedef long long ll;struct Node { int id; ll s, t;} nodes[N];struct SegmentTree {#define le(x) (x &lt;&lt; 1)#define ri(x) (x &lt;&lt; 1 | 1)#define leftSubtree(x) (tree[le(x)])#define rightSubtree(x) (tree[ri(x)]) int l, r, size; int real_id; // 记录打印机的编号 ll time, lazy;} tree[N &lt;&lt; 2];vector&lt;int&gt; ans[N];bool cmp(const Node &amp;l, const Node &amp;r) { return l.t &lt; r.t;}void pushup(int idx) { tree[idx].time = min(leftSubtree(idx).time, rightSubtree(idx).time);}void pushdown(int idx) { if (tree[idx].lazy) { leftSubtree(idx).time = max(0ll, leftSubtree(idx).time + tree[idx].lazy); // 等待时间不能为负 leftSubtree(idx).lazy += tree[idx].lazy; rightSubtree(idx).time = max(0ll, rightSubtree(idx).time + tree[idx].lazy); rightSubtree(idx).lazy += tree[idx].lazy; tree[idx].lazy = 0; }}void build(int idx, int l, int r) { tree[idx].l = l, tree[idx].r = r; tree[idx].size = r - l + 1; if (l == r) { tree[idx].real_id = l; // 记录原始编号 return; } int mid = (l + r) &gt;&gt; 1; build(le(idx), l, mid); build(ri(idx), mid + 1, r); pushup(idx);}void modify(int idx, int l, int r, ll x) { if (l &lt;= tree[idx].l &amp;&amp; tree[idx].r &lt;= r) { tree[idx].lazy += x; tree[idx].time = max(0ll, tree[idx].time + x); return; } pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (l &lt;= mid) modify(le(idx), l, r, x); if (r &gt; mid) modify(ri(idx), l, r, x); pushup(idx);}void modify(int idx, int uid, ll x) { if (tree[idx].size == 1 &amp;&amp; tree[idx].l == uid) { tree[idx].time = max(0ll, tree[idx].time + x); return; } pushdown(idx); int mid = (tree[idx].l + tree[idx].r) &gt;&gt; 1; if (uid &lt;= mid) modify(le(idx), uid, x); if (uid &gt; mid) modify(ri(idx), uid, x); pushup(idx);}int find(int idx, ll time) { if (tree[idx].size == 1) return tree[idx].real_id; // 找到了，返回对应打印机的编号 pushdown(idx); if (leftSubtree(idx).time &lt;= time) return find(le(idx), time); // 根据建树时的编号单调性进行二分，若左侧等待时间小于等于目标，则尽量向左找 return find(ri(idx), time); // 左侧编号更小的打印机都在工作，只能向右找空闲打印机}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; build(1, 1, m); // 注意是 m 台打印机 for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; nodes[i].s &gt;&gt; nodes[i].t; nodes[i].id = i; } sort(nodes + 1, nodes + 1 + n, cmp); ll time = 1; for (int i = 1; i &lt;= n; i++) { modify(1, 1, m, time - nodes[i].t); // 减去时间差 int id = find(1, tree[1].time); // 找出编号最小的空闲打印机 ans[id].push_back(nodes[i].id); modify(1, id, nodes[i].s); // 为当前打印机分配了任务，更新单点等待时间 time = nodes[i].t; // 当前时间后移 } for (int i = 1; i &lt;= m; i++) { cout &lt;&lt; ans[i].size() &lt;&lt; ' '; sort(ans[i].begin(), ans[i].end()); for (int j: ans[i]) cout &lt;&lt; j &lt;&lt; ' '; cout &lt;&lt; endl; } return 0;}","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"UVA10129 - Play On Words 题解","slug":"solution-uva10129-play-on-words","date":"2024-08-06T03:15:50.777Z","updated":"2024-08-06T04:10:11.679Z","comments":true,"path":"articles/8982/","link":"","permalink":"https://justpureh2o.cn/articles/8982/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：UVA10129 初见感觉和 SP2885 WORDRING 很像，只不过本题不需要让拼出的“龙”首尾字符相同，而且也不用计算最大平均权——只需要判断是否存在合法的“龙”即可。但是这两道题的建图思路是相同的——对于一个字符串，我们真正关心的是它的第一个和最后一个字符。于是把它的开头和结尾的字母挑出来，在它们间连一条有向边，就可以代表这个字符串。 此时我们需要做的就是判断是否存在一个路径，使得从某个端点出发，每条边均只经过一次，最终到达终点。惊奇地发现，这就是在有向图上判断是否存在欧拉路径。判断依据如下： 有向图上所有点的入度都等于出度：该图存在欧拉路径，起点和终点任意。 有向图上有且仅有两个点的入度相差 ，其余点的入度均等于出度：该图存在欧拉路径，入度比出度大 的点是终点；出度比入度大 的是起点。 但是这道题又有些许不同……根据题目要求，当所有的字符串都串联起来时，才能叫有解。如果某个连通块内存在欧拉路径，但是存在孤立点（字符串没有被选上），也不能算作有解。因此我们还需要额外维护一个数据，起到存储每个字符串所属路径的作用。并查集能够很好地做到这一点！注意到并不是每个字母都能被用到（出现在字符串首/尾），需要再开一个数组存储该字母是否出现。 对并查集感到生疏的可以左转 P3367 [模板] 并查集。注意多测清空！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int indeg[30], outdeg[30];bool st[30];int p[30];int find(int x) { // 并查集找祖先 if (p[x] != x) p[x] = find(p[x]); return p[x];}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { // 多测清空！多测清空！多测清空！ memset(indeg, 0, sizeof indeg); memset(outdeg, 0, sizeof outdeg); memset(st, false, sizeof st); for (int i = 0; i &lt; 26; i++) p[i] = i; bool OK = true; // 是否能构成合法路径 int n; string s; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; s; const int head = s[0] - 'a'; const int tail = s[s.length() - 1] - 'a'; indeg[tail]++; outdeg[head]++; st[head] = true; st[tail] = true; p[find(head)] = find(tail); } bool flag = true; // 是否每个点的入度都等于出度 int cntS = 0, cntT = 0; // 起点数、终点数 for (int i = 0; i &lt; 26; i++) { if (indeg[i] != outdeg[i]) { flag = false; // 不满足第一条判别依据 if (outdeg[i] - indeg[i] == 1) cntS++; else if (indeg[i] - outdeg[i] == 1) cntT++; else { OK = false; // 两条均不满足 break; }; } } if (!flag &amp;&amp; (cntT != 1 || cntS != 1)) OK = false; // 一张图只允许存在一个起点和终点 int cur = -1; for (int i = 0; i &lt; 26; i++) { if (st[i]) { // 该字母出现过 if (cur == -1) cur = find(i); // 当前位于哪个连通块内 else if (cur != find(i)) { // 出现不属于同一个连通块的情况，无解 OK = false; break; } } } cout &lt;&lt; (OK ? \"Ordering is possible.\" : \"The door cannot be opened.\") &lt;&lt; endl; } return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"图论 欧拉图","slug":"algorithm-eular-graph","date":"2024-08-05T23:38:52.680Z","updated":"2024-08-06T01:45:13.179Z","comments":true,"path":"articles/12494/","link":"","permalink":"https://justpureh2o.cn/articles/12494/","excerpt":"","text":"图论起源 欧拉图 欧拉图的概念起源于18世纪的一个难题——“哥尼斯堡七桥问题”，问题是这样的： 有一条河上架设了如图所示的七座桥： 问如何在不重复经过某座桥的情况下走完这七座桥。 这个问题在当时难倒了一批人，有人写信给大神欧拉，请他帮忙解决这个问题。欧拉也是不负众望，经过一年的研究证明，发现这个七桥问题根本无解。在他的论文中提到了他的证明方法——将桥看作边、把陆地看作点，在一张图上研究问题。这也是数学图论思维的起源，因而欧拉图又被称作图论的起源。 现在看来，欧拉图可以看成一笔画问题。当这张图可以一笔画出，那么画出的路径就被称作欧拉路径；特殊地，当一笔画的起点和终点相同时，这个路径被称作欧拉回路。欧拉图基本可以分两个大类讨论——有向欧拉图和无向欧拉图。对于无向欧拉图来说，小学就已经涉及到了，判断方式如下： 整张图全为偶点（度数为偶数的点） 整张图只存在两个奇点（度数为奇数的点） 二者满足其一即可。那么对于有向欧拉图，因为涉及到边的方向，会稍微复杂一些： 图上每个点的入度均等于出度 图上只存在两个入度不等于出度的点——有一个点的入度比出度多 ，是图的起点；另一个点的出度比入度多 ，是终点 在求解某个欧拉路径/回路时，我们最常使用套圈法。这种方法基于对图的深度优先遍历，首先逮着一个路径向里搜索形成第一个回路，在回溯时如果发现某个点还有没被遍历过的边，就以它为起点向里搜索、并删除这条边。把回溯时走到的点记录起来，最后倒序输出就是合法回路（建议用栈）。 数组邻接表居然输给了 vector 存图？？？ 1234567void dfs(int u) { for (int i = nxt[u]; i &lt; G[u].size(); i = nxt[u]) { nxt[u]++; dfs(G[u][i]); } path.push(u);} 当然，如果题目要求按字典序输出路径，则需要对边排序。使用普通的数组邻接表显然是不方便的，那么考虑改用 vector。例如洛谷的模板题： P7771 [模板] 欧拉路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;vector&lt;int&gt; G[N];stack&lt;int&gt; path;int indeg[N], outdeg[N];int nxt[N];int n, m;int cntS = 0, cntT = 0;void dfs(int u) { for (int i = nxt[u]; i &lt; G[u].size(); i = nxt[u]) { nxt[u]++; dfs(G[u][i]); } path.push(u);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; while (m--) { int u, v; cin &gt;&gt; u &gt;&gt; v; indeg[v]++; outdeg[u]++; G[u].push_back(v); } for (int i = 1; i &lt;= n; i++) sort(G[i].begin(), G[i].end()); bool flag = true; int S = 1; for (int i = 1; i &lt;= n; i++) { if (indeg[i] != outdeg[i]) { flag = false; if (outdeg[i] - indeg[i] == 1) cntS++, S = i; else if (indeg[i] - outdeg[i] == 1) cntT++; else { cout &lt;&lt; \"No\" &lt;&lt; endl; return 0; } } } if (!flag &amp;&amp; cntS == cntT != 1) { cout &lt;&lt; \"No\" &lt;&lt; endl; return 0; } dfs(S); while (!path.empty()) { cout &lt;&lt; path.top() &lt;&lt; ' '; path.pop(); } return 0;} 典例 洛谷 P2731 [USACO3.3] 骑马修栅栏 Riding the Fences 题目地址：P2731 题目难度：普及+/提高 Farmer John 每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。 John 是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。 John 的农场上一共有 个栅栏，每一个栅栏连接两个顶点，顶点用 到 标号（虽然有的农场并没有那么多个顶点）。一个顶点上至少连接 个栅栏，没有上限。两顶点间可能有多个栅栏。所有栅栏都是连通的（也就是你可以从任意一个栅栏到达另外的所有栅栏）。John 能从任何一个顶点（即两个栅栏的交点）开始骑马，在任意一个顶点结束。 你需要求出输出骑马的路径（用路上依次经过的顶点号码表示)，使每个栅栏都恰好被经过一次。如果存在多组可行的解，按照如下方式进行输出：如果把输出的路径看成是一个 进制的数，那么当存在多组解的情况下，输出 进制表示法中最小的一个 （也就是输出第一位较小的，如果还有多组解，输出第二位较小的，以此类推）。 输入数据保证至少有一个解。 输入格式： 第一行一个整数 ，表示栅栏的数目。 从第二行到第 行，每行两个整数 ，表示有一条栅栏连接 两个点。 输出格式： 共 行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。 数据保证至少有一组可行解。 数据范围： 对于 的数据，。 根据题意，我们发现走过的路径恰好满足欧拉路径的定义（每个边只走一次）。又因为这道题保证有解，于是我们只需要套用模板求字典序最小的无向图欧拉路径并输出即可。这道题是无向图，用 vector 存又有些麻烦，我们可以用邻接矩阵，并从小到大枚举出边，可以达到一样的效果。 读入时需要特别注意，编号并不是严格从 开始、也不是在 结束——它不连续，因此需要预处理上下界，起点的初始值需要是图上的任意一个存在的编号。 12345678910void dfs(int u) { for (int i = 1; i &lt;= n; i++) { if (g[u][i]) { g[u][i]--; g[i][u]--; dfs(i); } } path.push(u);} UVA10129 Play On Words 题目地址：UVA10129 题目难度：普及+/提高 输入个单词，是否可以把所有这些单词排成一个序列，使得每个单词的第一个字母可上一个单词的最后一个字母相同（例如）。每个单词最多包含个小写字母。输入中可以有重复的单词。 原题面 PDF 输入格式： 第一行为一个整数 ，代表有 组测试数据。 对于每组测试数据，第一行为一个整数 。接下来 行，每行读入一个字符串，每个字符串由 个小写字母组成，同一个字符串可能重复出现多次。 输出格式： 对于每组测试数据，如果能组成合法的单词链，输出一行 Ordering is possible.；否则输出一行 The door cannot be opened. 很像之前遇见的一道 求负环+分数规划的题目 SP2885 WORDRING，只不过这道题没有要求最终字符串的首尾字符相同，我们只需判断能否把所有字符串都用上、组成一个单词链即可。注意到只要所有字符串能够不重不漏组成一个欧拉路径，该情况就是有解的，反之则无解。 更为详细的内容见：我的题解","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"CF 1728F - Fishermen 题解","slug":"solution-cf1728f-fishermen","date":"2024-08-05T18:07:39.386Z","updated":"2024-08-05T19:45:19.561Z","comments":true,"path":"articles/40858/","link":"","permalink":"https://justpureh2o.cn/articles/40858/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：CF 1728F - Fishermen 这道题很难一眼看出所用算法，因此先从题目本身入手。 可以发现，当每个 都满足 ，且 互不相同时，题目所给的两个构造条件就是不必要的。因为我们可以通过重排 来满足这两条要求。 所以先来处理 。 符号代表整除，也就是说 的结果是一个整数。换个思路，。考虑到 自带一个 的性质， 取太大是不优的，于是设置 ，预处理出 一定范围内的倍数作为 的候选。由于倍数可能很大，因此考虑离散化存储。 现在问题转化成了，让每一个 匹配一个满足条件的 。二分图的味道就来了，考虑把所有 作为左部点，预处理的所有倍数作为右部点，把存在倍数关系的左右点连起来，就是一个合法的二分图了。 最后还需要处理一个要求：最小化 。把预处理的倍数从小到大排序、排列在右部就可以做到。提供一个优化的技巧：仅在某个点匹配成功后再清空 st 数组，如此可以优化时间复杂度到 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#define N 1000010#define M 1000010using namespace std;typedef long long ll;struct Edge { int to, ne;} edges[M &lt;&lt; 1];int h[N], idx = 0;int a[N], b[N];bool st[N];int match[N];vector&lt;int&gt; unq;map&lt;int, int&gt; discrete;int n;void add(int a, int b) { idx++; edges[idx].to = b; edges[idx].ne = h[a]; h[a] = idx;}bool hungary(int u) { for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; if (!st[j]) { st[j] = true; if (!match[j] || hungary(match[j])) { match[j] = u; return true; } } } return false;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) { for (int k = 1; k &lt;= n; k++) { unq.push_back(a[i] * k); // 处理倍数，预备去重 } } sort(unq.begin(), unq.end()); int cnt = unique(unq.begin(), unq.end()) - unq.begin(); // 去重，顺带升序排序 int disc = 0; for (int i = 0; i &lt; cnt; i++) { // 离散化 discrete[unq[i]] = ++disc; b[disc] = unq[i]; // 去重前就已完成排序，直接赋值 } for (int i = 1; i &lt;= n; i++) { for (int k = 1; k &lt;= n; k++) { add(discrete[a[i] * k] + n, i); } } ll ans = 0; int res = 0; for (int i = 1; i &lt;= cnt; i++) { if (hungary(i + n)) { // 优化 memset(st, false, sizeof st); res++; ans += b[i]; } if (res == n) break; // 总共匹配n个a } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 因为偷懒使用了 ，程序执行效率并不是很高， 拿倒数第五优，代码仅供参考。","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CF 1404E - Bricks 题解","slug":"solution-cf1404e-bricks","date":"2024-08-05T04:42:47.431Z","updated":"2024-08-05T18:11:34.929Z","comments":true,"path":"articles/35098/","link":"","permalink":"https://justpureh2o.cn/articles/35098/","excerpt":"","text":"您已获得最佳的阅读体验！ 题目地址：CF1404E - Bricks 初做这道题时，我发现它和 P6062 - Muddy Fields G 神似。于是冲动交了一发，吃了 WA。仔细审题发现，这道题要求所用木板不能重叠。因此寻找其他的解题方法。 现在我们的当务之急是找出一个处理木板重叠的好方法，从黑色格子的分布入手——木板重叠放置的唯一可能就是当前黑色方格位于一个交叉的位置，如下图： 位于交点上的黑色方格可能被同时划分到橙色和蓝色的木板里去，这是题目不允许的，但这也启发我们在位于交点位置上的黑色方格做特定的操作。也就是说，当确定选择使用蓝色木板覆盖后，橙色木板就不能再覆盖交点位置。考虑把原图改换成如下形式： 当选择 号点后（蓝色木板）， 号就不能再选。何不考虑在“仇家”之间连边？也就是连接边 ，对于整张图，按此方法全部连边。题目要求我们覆盖住所有的黑色方格，并且还不能同时选择一条边上的两个端点（因为它们是敌人）。此时突然想到，这是二分图的最大点独立集问题。 在一张二分图中，选出若干点组成一个点集，使得点集里任意两点都不互通。原图中满足以上要求且所含点最多的集合叫做原二分图的最大点独立集。感性理解一下：我们需要选出尽量少的点丢弃，使得剩下的点不互通，考虑到最小点覆盖的定义，把属于最小点覆盖集的所有点从图中去掉，此时图上的每条边均只剩一个端点，满足定义，于是最大点独立集的大小就等于总点数减去最小点覆盖集的大小（根据 定理，又有最小点覆盖集的大小等于二分图最大匹配数），推导出它等价于求：总点数减去最大匹配数。 不妨设所有新加的边组成一个新图 ，换到这道题上来，就是： 黑色方格总数减去黑色方格间的总边数再加上 的最大匹配数 此后，把原图中的边当作一个点进行编号，并统计黑色方格数；然后统计所有位于交叉位置的黑色方格，并根据上述的连接方式连边，顺带统计黑色方格间的边数；最后在新图上做最大匹配，根据公式计算出结果即可。我为边编号的方式较为繁琐，理解思路后自行编号计算即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;#define N 210 // 题目所给最大长宽#define M 1000010#define K 80000 // 化边为点后最多 n(m-1)+m(n-1) 个点，极限情况下等于79600using namespace std;struct Edge { int to, ne;} edges[M];int h[N * N], idx = 0; // 方阵中最多 n^2 个点char land[N][N]; // 暂存原图int id[N][N]; // 按顺序给点编号int match[K]; // 新图最多 K 个点bool st[K], vis[N * N][4]; // vis 用作搜索判重，记录当前点是从哪个方向扩展而来的int edge = 0, point = 0;int n, m;void add(int a, int b) { idx++; edges[idx].to = b; edges[idx].ne = h[a]; h[a] = idx;}bool hungary(int u) { // 匈牙利算法，二分图最大匹配 for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; if (!st[j]) { st[j] = true; if (!match[j] || hungary(match[j])) { match[j] = u; return true; } } } return false;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int tmp = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cin &gt;&gt; land[i][j]; id[i][j] = ++tmp; if (land[i][j] == '#') point++; // 统计黑色方格个数 } } // 写得稀烂，建议理解后自己写一个 for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (land[i][j] == '#') { if (land[i - 1][j] == '#' &amp;&amp; land[i][j - 1] == '#') { add(id[i][j] - i, n * (m - 1) + (i - 2) * m + j); } if (land[i - 1][j] == '#' &amp;&amp; land[i][j + 1] == '#') { add(id[i][j] - i + 1, n * (m - 1) + (i - 2) * m + j); } if (land[i + 1][j] == '#' &amp;&amp; land[i][j + 1] == '#') { add(id[i][j] - i + 1, n * (m - 1) + (i - 1) * m + j); } if (land[i + 1][j] == '#' &amp;&amp; land[i][j - 1] == '#') { add(id[i][j] - i, n * (m - 1) + (i - 1) * m + j); } } } } // 搜索统计边数 int dx[4] = {1, -1, 0, 0}; int dy[4] = {0, 0, 1, -1}; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (land[i][j] == '#') { for (int k = 0; k &lt; 4; k++) { int nx = i + dx[k]; int ny = j + dy[k]; if (nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; m) continue; if (land[nx][ny] != '#') continue; if (vis[id[i][j]][k]) continue; vis[id[i][j]][k] = true; edge++; } } } } int res = 0; for (int i = 1; i &lt;= n * (m - 1); i++) { memset(st, false, sizeof st); if (hungary(i)) res++; } // 由于搜索统计时重复扫了两遍，因此边数需要折半 cout &lt;&lt; point - edge / 2 + res &lt;&lt; endl; return 0;} 然后 in queue 一晚上","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"图论 二分图","slug":"algorithm-bipartite-graph","date":"2024-07-29T18:11:14.209Z","updated":"2024-08-06T18:14:23.610Z","comments":true,"path":"articles/21386/","link":"","permalink":"https://justpureh2o.cn/articles/21386/","excerpt":"","text":"二分图基础 二分图，又称二部图。顾名思义，在一个二分图中，所有的节点可以分成两部分（分别用黑白染色），并且满足相同颜色的点之间无边。如下图： 我们发现，集合 内部的点间都没有连边，每条边必定连接两个不同集合的点。二分图有一个性质，那就是不存在奇数环。因为每条边都连接了不同的集合，必须过偶数条边才能回到出发点所在的集合，因此长度为奇数的环是一定不可能出现在二分图里的。 染色法判定二分图 基于 ，对每次遍历到的点染色，并给它的邻接点染另一种颜色。如果某时刻出现矛盾（待染上的颜色与当前已有的颜色不同），则立马判定为非二分图，否则就是一个合法的二分图。 123456789101112131415161718192021bool dye(int u, int fa, int c) { color[u] = c; for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; if (j == fa) continue; if (color[j]) { if (color[j] == c) return false; // 矛盾，不是二分图 } else if (!dfs(j, u, 3 - c)) return false; // 在子树中出现矛盾，也不是二分图 } return true;}bool check() { memset(color, 0, sizeof color); for (int i = 1; i &lt;= n; i++) { if (!color[i]) { if (!dfs(i, -1, 1)) return false; // 出现矛盾，不是二分图 } } return true;} 二分图最大匹配 对于一个连接了若干条边的二分图，我们选出一些边，使得这些边没有公共点。满足如上条件且选出的边最多的方案称为这个二分图的最大匹配。 假如你是一名媒婆，你需要为若干对男女牵线搭桥（这是典型例子，并非本人玩梗整活）。已知他们的意向，如何选择才能让最多的男女成对（一夫一妻制、没有南通和钕通）。这就是一个裸的二分图最大匹配问题。 首先我们需要明确两个概念： 交错路径：对于二分图中的某个匹配 ，有一条路径，使得这条路径上的边满足“不在 中”和“在 中”交替出现。则这个路径叫做交错路径，头尾边无限制。 增广路径：如果交错路径上的边严格满足“不在 中”-“在 中”-“不在 中”-……-“在 中”-“不在 中”的顺序。则它是一个增广路径，即满足路径头尾的边都不在 中的交错路径。 匈牙利算法的核心就是在已经求解出的增广路径的基础上不断发现新的增广路径，增广路径上不相连接的边都可以组成一组匹配，因此只要增广路找的越长，就会找到比原先更大的匹配。 对于一张二分图，步骤如下： 如果后边的节点所选的配对点与前边已选的点冲突，让前边的点寻找其他的配对 在出现冲突的情况下，如果前边的点无论如何也找不到其他的配对，那么让后来的节点寻找其他的配对 如果新来的节点均匹配不上，那么不做操作 1234567891011121314// 每次执行前需要清空st数组bool hungary(int u) { for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; if (!st[j]) { st[j] = true; // 防止重复遍历 if (!match[j] || hungary(match[j])) { // 当前这个女生还没配对成功或者先来的那个男生还有备胎 match[j] = u; // 牵手成功 return true; } } } return false; // 没招} 点覆盖/路径覆盖/点独立 对于某个二分图，我们拿出若干个点组成一个点集，满足这张图所有边上至少有一个点在这个集合中。那么点数最少的这样的集合被称作原图的最小点覆盖集。根据 定理，二分图中最小点覆盖集的大小等于最大匹配数，即这个最小点集中的点数等于最大匹配的边数。 相对的，我们选出若干点组成另一个点集，让点集里任意两点在原图中均不相连，满足它的最大点集叫做最大点独立集；与之相对，选出一些点，使得任意两点间都有边，满足它的最大点集叫做原图的最大团。假设原图为 ，把 中原有的边删去、并把没有边连接的两点连接上，得到它的补图 ，那么 的最大点独立集的大小等于 最大团的大小。 对于一张 ，用若干互不相交（没有公共端点）的路径把所有点覆盖，其中选取路径数最少的那个方案，叫做这个 的最小路径覆盖。如果使用的路径允许相交，则叫做最小路径重复点覆盖。 在二分图中，有如下非常好的性质： 最小点覆盖集的大小=最大匹配数—— 定理 总点数-最小点覆盖集的大小=总点数-最大匹配数=最大点独立集的大小 最小路径覆盖数=顶点数-最大匹配数 对于第二点，感性理解一下：我们要选出若干点丢弃，使得剩余的点无论如何也不互通。考虑到最小点覆盖的定义，我们把属于最小点覆盖集的所有点从图中去掉，此时图中所有边均只有一个端点，无法经过边到达其他点。 对于第三点。在任意 中，把同一个点拆分成两个点，分居两侧，因此可以组成一个二分图。原图中的边 ，在新图里就可以映射成 。因此，对于原图中的每一条路径，在这个二分图的右部都可以找到对应的终点（每一条路径都有终点，终点出度为 ，在二分图中匹配失败）。右部失配点对应一个左部的非匹配点，转化成求左部非匹配点最少，从而变成求左部匹配点最多，最后变成求最大匹配数。 如何求解最小路径重复点覆盖数呢？我们想办法把它转化成简单的问题——比如当前有两条边 和 相交在 点，那么我们可以考虑让其中一条边的两个端点不经过 直接相连，一来二去，整个问题会变成求解新图的最小路径覆盖数。根据如上原理，把所有能够间接到达的点直接连上，也就是说先求解原图的传递闭包，最后在新图上解最小路径覆盖数。 典例 洛谷 P1525 [NOIP2010 提高组] 关押罪犯 题目地址：P1525 题目难度：普及+/提高 题目来源：NOIp 提高组 2010 NOIP2010 提高组 T3 S 城现有两座监狱，一共关押着 名罪犯，编号分别为 。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 的冲突事件。 每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。 在详细考察了 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。 那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？ 输入格式： 每行中两个数之间用一个空格隔开。第一行为两个正整数 ，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 行每行为三个正整数 ，表示 号和 号罪犯之间存在仇恨，其怨气值为 。数据保证 ，且每对罪犯组合只出现一次。 输出格式： 共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 0。 数据范围 对于 的数据有 。 最大值最小，考虑二分。设当前二分到的最大冲突值是 ，我们判断这个答案是否可行。就需要把所有冲突值小于等于它的某对罪犯放进同一个监狱，反之放进不同的监狱。这个方案成立当且仅当整个图能够构成一张二分图，因为只有如此，才能保证先前假设的所有罪犯关系成立，且不存在比当前二分到的更大的冲突。 因此在二分到每个答案时，对建立的图进行一次染色法判定。如果当前是一个二分图，则把右边界缩减，反之收缩左边界。 AcWing 372 棋盘覆盖 题目地址：AcWing 372 题目难度：中等 给定一个 行 列的棋盘，已知某些格子禁止放置。 求最多能往棋盘上放多少块的长度为 、宽度为 的骨牌，骨牌的边界与格线重合（骨牌占用两个格子），并且任意两张骨牌都不重叠。 输入格式： 第一行包含两个整数 和 ，其中 为禁止放置的格子的数量。 接下来 行每行包含两个整数 和 ，表示位于第 行第 列的格子禁止放置，行列数从 开始。 输出格式： 输出一个整数，表示结果。 数据范围： 棋盘问题一般考虑两种：状态压缩DP和二分图，但是状压DP的时间复杂度是 ，这道题不行。因此考虑后者。 在抛除了被禁用格子的情况下，尝试把能放的两个相邻格子当作两个点连边。不相邻的格子/禁止放置的格子不连边，最后发现整张图就是一个二分图。那么我们需要解决的就是——选择没有重复端点（不重叠）的若干条边，使得利用率最高，因此做二分图的最大匹配。 对于棋盘问题， 二分图在建图时有一个小技巧：就是把棋盘上色，变成一个国际象棋的棋盘（横纵黑白交替）。我们可以发现，对于任何一个可放置骨牌的位置，两个格子的颜色是不相同的。形式化讲，必定有一种颜色的格子全部满足横纵坐标之和为奇数。因此我们只需让横纵坐标之和为偶数的格式向和为奇数的格子连边即可。于是枚举所有和为奇数的点（二分图左部的所有点）做匈牙利算法。 UVA 1194 Machine Schedule 题目地址：UVA 1194 题目难度：提高+/省选- 有两台机器 分别有 种模式。 现在有 个任务。对于每个任务 ，给定两个整数 和 ，表示如果该任务在 上执行，需要设置模式为 ；如果该任务在 上执行，需要设置模式为 。 每台机器第一次开机默认处在0模式，且第一次开机不需要消耗时间。任务可以以任意顺序被执行，但每台机器转换一次模式就要重启一次。求怎样分配任务并合理安排顺序，能使机器重启次数最少。 输入格式： 多组测试数据。对于每组数据，输入第一行为三个整数 ，含义见上。 接下来 行，每行三个整数 。分别代表任务编号， 和 。 当末尾出现单独的 时，读入结束 输出格式： 对于每组测试数据，输出一行一个整数，代表最少的重启次数 数据范围： ，，，。 原题 PDF 考虑把每一个 设置成一个点，从 向 连边，代表整个任务 ，只要其中有一方调节了模式并执行这个任务，则可以看作整个任务完成了。发现最终得到的图是一张二分图，左部为 ，右部为 。问题就转化成了——找出若干 ，使得这些选出的点能够覆盖到所有的任务（边）。因此是一道求解二分图最小点覆盖的题目，根据 定理，我们只需要解出这个图的最大匹配数即可。 洛谷 P3355 骑士共存问题 题目地址：P3355 题目难度：省选/NOI- 题目来源：网络流与线性规划 24 题 在一个 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。 对于给定的 个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。 输入格式： 第一行有 个正整数 和 ，分别表示棋盘的大小和障碍数。接下来的 m 行给出障碍的位置。每行 个正整数，表示障碍的方格坐标。 输出格式： 将计算出的共存骑士数输出。 数据范围： 对于全部的测试点，保证 ，。 同样使用棋盘技巧，题图已经非常直观的展现了这一技巧。我们发现所有黄色的格子都可以向周围符合要求的红色格子连边，红黄两色组成二分图。根据题意，我们要放尽量多的点，使得它们伸展出去的边互不相干（所有点互不相通）。因此这是一道求解二分图最大独立集的问题，转化成“总点数减障碍点数减最大匹配数”的求解。同样只枚举单色格子来求解（二分图的某一部）。 双倍经验：P4304 [TJOI2013] 攻击装置 洛谷 P5030 长脖子鹿放置 题目地址：P5030 题目难度：省选/NOI- 众周所知，在西洋棋中，我们有城堡、骑士、皇后、主教和长脖子鹿。 如图所示，西洋棋的“长脖子鹿”，类似于中国象棋的马，但按照“目”字攻击，且没有中国象棋“别马腿”的规则。（因为长脖子鹿没有马腿） avatar 给定一个,的棋盘，有一些格子禁止放棋子。问棋盘上最多能放多少个不能互相攻击的长脖子鹿。 输入格式： 输入的第一行为两个正整数，，。其中表示禁止放置长脖子鹿的格子数。 第~第行每一行为两个整数,表示禁止放置的格子。 不保证禁止放置的格子互不相同。 输出格式： 一行一个正整数，表示最多能放置的长脖子鹿个数。 数据范围/提示： 重要提示：请务必思考对图的遍历顺序对运行速度的影响 对于的数据， 这道题和上面那一道很像，但不是双倍经验，关键就在于该题的移动方式上。由图可知，此时中心的白色方格需要向周围的同色方格连边，按照常规方法是建不出二分图的（同颜色连向同颜色），因此考虑更换建图方式（棋盘染色方式）。 好在，我们发现中心棋子和红点所在行数的奇偶性是不同的，此时可以转化成奇数行向偶数行上的合法点连边。把奇偶性不同的行染成黑白二色，发现就是一个二分图了。因此我们只需要枚举所有奇数行的所有列，套用上一题求解最大点独立集的公式就可解决这道题。 网络流本身其实很好写，难就难在一道题的建图上——Stairs_upon_templeLGZ AcWing 379 捉迷藏 题目地址：AcWing 379 题目难度：中等 Vani 和 cl2 在一片树林里捉迷藏。 这片树林里有 座房子， 条有向道路，组成了一张有向无环图。 树林里的树非常茂密，足以遮挡视线，但是沿着道路望去，却是视野开阔。 如果从房子 沿着路走下去能够到达 ，那么在 和 里的人是能够相互望见的。 现在 cl2 要在这 座房子里选择若干座作为藏身点，同时 Vani 也专挑 cl2 作为藏身点的房子进去寻找，为了避免被 Vani 看见，cl2 要求所选的这几个藏身点的任意两个之间都没有路径相连。 为了让 Vani 更难找到自己，cl2 想知道最多能选出多少个藏身点。 输入格式： 输入数据的第一行是两个整数 和 。 接下来 行，每行两个整数 ，表示一条从 到 的有向道路。 输出格式： 输出一个整数，表示最多能选取的藏身点个数。 数据范围： 。 乍一看，这不是最大点独立集的问题吗？然而并不是，它只存在于无向图中。此处给出的是一个 ，对于 ，有一个概念叫最小路径点覆盖。它的定义是：选出最少的不相交的边，使得选出的这些边能够覆盖到所有的点。如果我们选择了过多的点，那么会出现互通的点，与题意矛盾。再考虑到题目给出“相互望见”的关系，这道题会边成一个最小路径重复点的求解，因此求传递闭包即可。 双倍经验：UVA 1184 - Air Raid（最小路径点覆盖数） 洛谷 P2764 最小路径覆盖问题 题目地址：P2764 题目难度：省选/NOI- 题目来源：网络流与线性规划 24 题 Special Judge 给定有向图 。设 是 的一个简单路（顶点不相交）的集合。如果 中每个定点恰好在 的一条路上，则称 是 的一个路径覆盖。 中路径可以从 的任何一个定点开始，长度也是任意的，特别地，可以为 。 的最小路径覆盖是 所含路径条数最少的路径覆盖。设计一个有效算法求一个 DAG（有向无环图） 的最小路径覆盖。 输入格式： 第一行有两个正整数 和 。 是给定 DAG（有向无环图） 的顶点数， 是 的边数。接下来的 行，每行有两个正整数 和 表示一条有向边 。 输出格式： 从第一行开始，每行输出一条路径。文件的最后一行是最少路径数。 对于 的数据，，。 这道题在求解最小路径覆盖数的基础上额外设置了一个输出合法路径的要求，考虑到 match 数组的含义——配对的点。又因为配对的点在同一条路径上，所以可以从每个点开始向前递归查找路径，只要还能配对，那么加入当前路径，否则新开一个路径存储其他的路径。 需要注意的是，对原 进行重映射时我们把右部点的编号统一设置成了左部点编号加 的形式，因此在操作时需要注意转换。一般情况的递归寻路代码如下： 123456789void getPath(int u) { path[tot].push_back(u); // 当前点加入路径 st[u] = true; // 标记已访问，后期不再单独作为路径起点进行递归 if (!pre[u].second) { // 不存在前驱，代表是路径的端点 tot++; // 开新路径 return; } getPath(pre[u].second); // 递归它的前驱} 洛谷 P6062 [USACO05JAN] Muddy Fields G 题目地址：P6062 题目难度：省选/NOI- 题目来源：USACO 2005 大雨侵袭了奶牛们的牧场。 牧场是一个 的矩形，其中 。大雨将没有长草的土地弄得泥泞不堪，可是小心的奶牛们不想在吃草的时候弄脏她们的蹄子。为了防止她们的蹄子被弄脏，约翰决定在泥泞的牧场里放置一些木板。每一块木板的宽度为 个单位，长度任意，每一个板必须放置在平行于牧场的泥地里。 约翰想使用最少的木板覆盖所有的泥地．一个木板可以重叠在另一个木板上，但是不能放在草地上。 输入格式： 第一行两个整数 。 接下来 行，每行 个字符，描述牧场，其中 * 为泥地，. 为草地。 输出格式： 输出一个整数，最少需要多少木板。 对于每个能够放置木板的格子，显然一次性放更长的木板会更优，对于任何一个泥方格，它都可能位于一个横向的木板或是一个纵向的木板上。这启发我们先处理出每个泥方块所在的最长的横向/纵向连通块，然后把所有横向连通块和纵向连通块分开、组成二分图的左右部，接着根据每个泥方块所在的位置，为相关的横纵连通块表示的点连边。目标是将所有泥地覆盖起来，因此这道题就只需要我们求出这个二分图的最小点覆盖。 CF 1404E Bricks 题目地址：CF 1404E 题目难度：省选/NOI- 你有一个 （）的格子纸，格子要么涂黑（#）要么涂白（.）。你需要用若干个长为一，宽为任意正整数或者宽为一，长为任意正整数的长方形去覆盖所有黑色格子，要求不能盖到白色格子上，不能盖到其他长方形上，不能盖出格子纸的边界，求最少用多少个长方形。 数据保证至少有一个黑色格子。 输入格式： 输入第一行为两个整数 。 接下来 行描述这个格子纸，每行包含一个长度为 的字符串，包含“#”和“.”两种字符型，分别代表对应位置上有一个黑色格子和一个白色格子。 数据保证至少存在一个黑色格子。 输出格式： 输出一行一个整数，代表所需最少的长方形数 这道题其实和上边的题十分相似，唯一不同的一点是——这道题不允许木板重叠。此时需要更换建图方式，把方格看作点，点之间有边，代表原方格纸上两个方格有公共边。考虑到木板重叠只会出现在十字交叉的位置，因此着重研究此类方格。如果我们假设边上还有若干黑白点，那么当选择了某条边上的点 （覆盖一个长方形）后，另一个方向的边上的点 就不能被选择（含义为覆盖当前点）。因此给 连边。最终，会得到一个二分图，并且我们希望在二分图上每个点都不能互相到达的情况下覆盖到每个原图点，于是在新图跑最大独立集。 更为详细的内容见：我的题解 CF 1728F Fishermen 题目地址：CF 1728F 题目难度：NOI/NOI+/CTSC 没想到有生之年居然还能用得上黑题的tag…… 给你一个长度为 的序列 ，你可以将 中的数重新排列，并根据重排后的序列 生成序列 ，生成方法如下： 。 ， 是满足 且 的最小正整数。 求所以可能生成的序列 中 的最小值。 输入格式： 输入第一行为一个整数 ，代表 中的元素个数。 第二行有 个整数 ，满足 。 输出格式： 一行一个整数，代表最小的 。 考虑到给出的两个生成方法对我们的构造没有影响，我们完全可以在构造后对 进行重排得到合法解（题目还没要求输出方案）。发现只要满足 ，且 互不相同（小于号）即可。根据整除的性质，设倍率 ，显然当 过大时，生成的倍数就不优了，不满足“ 的最小正整数”这一性质。于是设置 。因为倍数可能很大，所以考虑离散化。 读题可以发现，题目要求让每一个 都能配对一个 ，考虑二分图匹配。把有倍数关系的 和预处理的数字连上边。对于题目中的 最小，运用贪心思想，我们把预处理的倍数按照升序排序即可解决。 更为详细的内容见：我的题解 所有代码在此","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"双连通分量、割点与桥","slug":"algorithm-double-connected-components","date":"2024-07-29T17:35:42.338Z","updated":"2024-07-29T17:35:40.088Z","comments":true,"path":"articles/38824/","link":"","permalink":"https://justpureh2o.cn/articles/38824/","excerpt":"","text":"该知识点考频极低，请读者自行安排选学内容 双连通分量 双连通分量Double Connected Components，简称 （电磁场）。是连通分量在无向图中的体现。分为点双连通分量 和边双连通分量 。在一张连通无向图中，任意删去一条边，如果无论如何都不能使点 不连通，那么就称 边双连通；同样在一张连通无向图中，任意删去一个点（ 除外），如果无论如何都不能使 不连通，则称 点双连通。 反之，如果这个无向连通图中不满足上述的定义，那么使它不满足定义删去的那条边/点就叫做原图的桥/割点。换句话说， 就是不含桥的极大无向连通图； 是不含割点的极大无向连通图。 双连通分量求解流程 其实和求强连通分量的代码逻辑很相似。但是不同的一点是，无向 图中不存在“横叉边”这一说。因此循环判断里 else if (in_stk[j]) 就出错了，此时我们只需判断当前的边是否是一条原路返回的边，如果不是的话再用 dfn[j] 更新 low[u]。 对于当前遍历到的边，它是一个桥，当且仅当下边的点 无法走回 ，因为在 中，是不允许回到上边的点的（防死循环）。形式上说，就是 dfn[u] &lt; low[j]。 另外，代码中下标涉及到的位运算需要建立在建图下标从 开始的基础上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define N 5010#define M 10010using namespace std;struct Edge { int to, ne;} edges[M &lt;&lt; 1];int h[N], idx = 0;int dcc_cnt = 0, dfs_cnt = 0;int dcc_id[N];int dfn[N], low[N];stack&lt;int&gt; stk;int indeg[N];bool is_bridge[M];void add(int a, int b) { edges[idx].to = b; edges[idx].ne = h[a]; h[a] = idx++;}void tarjan(int u, int f) { dfn[u] = low[u] = ++dfs_cnt; stk.push(u); for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; if (!dfn[j]) { tarjan(j, i); low[u] = min(low[u], low[j]); if (dfn[u] &lt; low[j]) { is_bridge[i] = is_bridge[i ^ 1] = true; } } else if (i != (f ^ 1)) { low[u] = min(low[u], dfn[j]); } } if (dfn[u] == low[u]) { dcc_cnt++; int t; do { t = stk.top(); stk.pop(); dcc_id[t] = dcc_cnt; } while (t != u); }} 割点求解流程 如果某个点是割点，那么剩下的还未访问过的点至少会有一个在不经过它的情况下永远无法到达任何已经遍历过的点。形式化讲就是 low[y] &gt;= dfn[x]，对于当前遍历到的的节点，存在两种情况： 为根节点，必须有至少两个树枝 不为根节点，当前就是割点 1234567891011121314void tarjan(int u) { dfn[u] = low[u] = ++dfs_cnt; stk.push(u); int deg = 0; for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; if (!dfn[j]) { deg++; tarjan(j); low[u] = min(low[u], low[j]); if ((j != root &amp;&amp; dfn[u] &lt;= low[j]) || (j == root &amp;&amp; deg)) cut[u] = true; } else low[u] = min(low[u], dfn[j]); }} 典例 洛谷 P2860 [USACO06JAN] Redundant Paths G 题目地址：P2860 题目难度：提高+/省选- 为了从 个草场中的一个走到另一个，贝茜和她的同伴们有时不得不路过一些她们讨厌的可怕的树．奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择。 每对草场之间已经有至少一条路径．给出所有 条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量，路径由若干道路首尾相连而成．两条路径相互分离，是指两条路径没有一条重合的道路．但是，两条分离的路径上可以有一些相同的草场．对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路。 输入格式： 第一行为两个整数 和 。 接下来 行，每行两个整数，代表每条道路所连接的两个草场的编号。 输出格式： 仅一行，最少需要兴修的道路的数量。 这道题和校园网的子任务 相对，都是把一个图补充成对应分量所需添加的边数，因此可以类比。这道题的结论是，补充 条边可以使得原图成为一个 ，其中 为搜索树中叶子节点的个数。 感性理解，因为每个合法 中的每两个点之间都有至少两条不相同的路径可以互相到达。发现如果删去叶子节点上边的那条边，整张图一定是分离的，因此我们就需要把叶子节点的边补齐。考虑在叶子节点之间互相连边，答案是 。 叶子节点的判断——在缩点后对入度为 的节点。 代码在此 AcWing 1183 电力 题目地址：AcWing 1183 题目难度：中等 给定一个由 个点 条边构成的无向图，请你求出该图删除一个点之后，连通块最多有多少。 输入格式： 输入包含多组数据。 每组数据第一行包含两个整数 。 接下来 行，每行包含两个整数 ，表示 两点之间有边连接。 数据保证无重边。 点的编号从 到 。 读入以一行 结束。 输出格式： 每组数据输出一个结果，占一行，表示连通块的最大数量。 数据范围： 首先维护出原先图中的连通块个数，然后我们再考虑删除哪个连通块里的哪个点，对于每个连通块。它可能存在割点，在删除割点后，整个连通块会裂成小块，而块的个数就是这个割点的度数。因此假设我们从 个连通块中选择了连通块 内的某个点 ，答案就是 。 因此在 找割点时统计维护割点度数的最大值即可。 代码在此 P3225 [HNOI2012] 矿场搭建 题目地址：P3225 题目难度：省选/NOI- 题目来源：湖南 2012 煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。 请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。 输入格式： 输入文件有若干组数据。 每组数据的第一行是一个正整数 ，表示工地的隧道数。 接下来的 行每行是用空格隔开的两个整数 和 ，表示挖煤点 与挖煤点 由隧道直接连接。 输入数据以 结尾。 输出格式： 对于每组数据，输出一行。 第 行组数据以 开始（注意大小写， 与 之间有空格， 与 之间无空格， 之后有空格）。 其后是用空格隔开的两个正整数，第一个正整数表示对于第 组输入数据至少需要设置几个救援出口，第二个正整数表示对于第 组输入数据不同最少救援出口的设置方案总数。 输入数据保证答案小于 。输出格式参照以下输入输出样例。 数据范围： 对于每组数据，设 为各组 中最大值，有： ； 各组 构成的集合 。 中任意两点连通。 考虑把几种情况分类归纳。首先，因为保证每一个每个点都能走到出口，因此全局出口数一定是大于等于 的，极端情况就是把出口设置在某点，然后这个点坍塌了，最好情况下剩余的节点都可以从第二个出个出去。 然后就是每个连通块内必须有出口，如果这个连通块里不存在割点，是一个 ，显然无论哪个点坍塌，都不影响全图的连通性。剩下就是上边所说的出口数必须大于等于 的问题。任意放置两个出口，因此总方案数为 ；反之，如果出现割点——如果坍塌的是割点，等价于把割点连接的若干连通块分开，每一个新连通块都是一个 ，内部点可以互相到达。考虑到题面所说只会坍塌一个点，因此无需担心被分开的 中有点坍塌的情况，因此可以在连通块内任意设置出口，方案数为该连通块的大小；如果坍塌的是某个连通块内部的点，这若干连通块仍然可以经过割点，因此在割点设置出口。 根据乘法原理，答案需要相乘得出。数据范围是 ，因此要用 unsigned long long。（long long 最大到 ）。 代码在此","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"强连通分量与 Tarjan 缩点","slug":"algorithm-strongly-connected-component","date":"2024-07-26T06:02:44.473Z","updated":"2024-07-28T19:44:47.473Z","comments":true,"path":"articles/25406/","link":"","permalink":"https://justpureh2o.cn/articles/25406/","excerpt":"","text":"连通分量与缩点 在说 之前，先涉及最基本的概念：连通分量。如果一张有向图中，任意两个节点都能互相到达，则称它是一个连通分量，特殊地，一个点也算一个连通分量。强连通分量Strongly Connected Component，简称 （四川菜），是原图的极大连通分量。这里的“极大”是一个文艺复兴时期提出的概念——若一个事物，没有比它更大的事物存在，就称这个事物是极大的/最大的（例如：导数的极大值）。 缩点，指在求出图上所有 后把这些分量用一个点去代替。这样操作得到的新图是一张有向无环图Directed Acyclic Graph，简称 （大哥）。它可以做拓扑排序，在这样的图上做最短路，时间复杂度是 的，优于 的 或者 的 。 求解 最常用的算法由 发明（整个世界就是一个巨大的 ），在图上做一遍深度优先搜索，并维护相关信息；以及不那么常用但是非常直观好理解的 算法，在正反图上分别进行一次深搜从而得到强连通分量。 算法流程 生成树基础 假如当前 遍历了绿色的边及其相连的节点。我们可以把图上的边分为四类： 树枝边：正常的树内边，标记为黑色有向。 前向边：指向前方的边，也就是从上向下指的边。可以发现树枝边就是一类特殊的前向边。标记为蓝色有向 后向边：指向后方的边，与前向边相对。标记为橙色有向。 横叉边：指向一个已经访问过的节点，且这个节点不是它的父节点。标记为紫色有向。 如果某个节点是某个 中被访问到的第一个节点，那么强连通分量中其余节点在这个节点的子树上。 算法思路 首先为每个节点维护两个变量 dfn 和 low，这两者都是维护节点信息的“时间戳”。前者用来记录深搜时该点是第几个被访问到的；后者定义为这个点在栈中能够回溯到的最早加入的节点 dfn。对于某个强连通分量，我们会发现这个分量中的所有点的 low 值均是相同的，如下图： 图片来源于 YouTube 其中点内的序号是 dfn 值，点外侧的数字是 low 值。此时再维护一个栈，栈中存放已经深搜遍历到且还没计算出归属于哪个强连通分量的节点。 这启发我们做深搜，先把当前点 的 dfn 值标记出来，并枚举相连的点 （不是父节点），那么对于节点 的 low 值，分三种情况讨论： 如果枚举到一条树枝边，则 low[x] = min(low[x], low[y])。这基于一个事实—— 能到达的节点， 也能。 如果这条边不是树枝边，但是 在栈中，则 low[x] = min(low[x], dfn[y])。根据 low 的定义而来（有向图中使用 low[x] = min(low[x], low[y]) 也是正确的）。 如果这条边不是树枝边，且 不在栈中，则不作操作。因为这意味着 所属的 已被全部处理完且弹出栈了，二者因此不同属于一个强连通分量中。 如果当前的点满足 dfn[u] = low[u]，等价于它能回溯到的最早的点是自己，代表这是一个 的起始节点。因此我们不断弹出栈顶，加入到新的 中，直到弹出 并把它加入强连通分量后为止，此时可以借机维护一下强连通分量的相关变量。 基本模板： 123456789101112131415161718192021222324void tarjan(int u) { stack&lt;int&gt; stk; dfn[u] = low[u] = ++dfs_cnt; stk.push(u); in_stk[u] = true; for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; if (!dfn[j]) { tarjan(j); low[u] = min(low[u], low[j]); } else if (in_stk[j]) { low[u] = min(low[u], dfn[j]); } } if (dfn[u] == low[u]) { scc_cnt++; do { int t = stk.top(); stk.pop(); scc_id[t] = scc_cnt; } while (stk.top() != u); }} 缩点流程 所谓缩点，说白了就是把解出来的强连通分量当作一个单点，建出一个新图，此时这个新图是一个 。正常来说首先就需要做 算法分离所有强连通分量，然后再根据不同强连通分量内点的连接关系来连 之间的边。注意，有可能出现多对分属不同 点、缩点后反复在同一对强连通分量之间连边的情况，大部分时候无需在意，但是在特殊情况下可能需要对这些边判重。 1234567for (int i = 0; i &lt;= n; i++) { for (int j = h[i]; ~j; j = edges[j].ne) { int k = edges[j].to; int a = scc_id[i], b = scc_id[k]; if (a != b) add(hs, a, b, edges[j].w); }} 典例演练 为了方便，我们把缩点后入度为 的点称作“起点”、出度为 的点称为“终点”。 洛谷 P2341 [USACO03FALL/HAOI2006] 受欢迎的牛 G 题目地址：P2341 题目难度：普及+/提高 每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果 喜欢 ， 喜欢 ，那么 也喜欢 。牛栏里共有 头奶牛，给定一些奶牛之间的爱慕关系，请你算出有多少头奶牛可以当明星。 输入格式： 第一行：两个用空格分开的整数： 和 。 接下来 行：每行两个用空格分开的整数： 和 ，表示 喜欢 。 输出格式： 一行单独一个整数，表示明星奶牛的数量。 数据范围： 对于 的数据，，。 把所有的“喜欢关系”画成一个有向图： 强连通分量用绿色矩形框出，把绿色框当作一个点。已知框内的点两两互通，只要某个框内的某个点和另一个点连通，那么整个框的点都和这个点相通。因此连通关系就可以传递下来，于是我们需要解决的就是其他方框之间的连通性。 把绿色框看成单点（缩点）后，如果所有边最终汇聚到一个点上，那么这个 中的所有点都和其他所有点相连，就是符合题目要求的“明星ヒマリ”。因此我们只需统计出度为 的 即可：如果仅有一个这样的强连通分量，那么答案就是这个强连通分量里的总点数；若出现一个以上这样的 ，则答案为 （毕竟连两个终点都不互连通）。 代码在此 洛谷 P2746 [USACO5.3] 校园网 Network of Schools 题目地址：P2746 题目难度：提高+/省选- 一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使 在 学校的分发列表中， 也不一定在 学校的列表中。 你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务 A）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务 B）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。 输入格式： 输入文件的第一行包括一个正整数 ，表示网络中的学校数目。学校用前 个正整数标识。 接下来 行中每行都表示一个接收学校列表（分发列表），第 行包括学校 的接收学校的标识符。每个列表用 结束，空列表只用一个 表示。 输出格式： 你的程序应该在输出文件中输出两行。 第一行应该包括一个正整数，表示子任务 A 的解。 第二行应该包括一个非负整数，表示子任务 B 的解。 数据范围： 。 我们同样处理出点之间的关系，图中一定有 个起点与 个终点。对于子任务 ，当这个软件在起点开始投放时，才能到达更多的学校，要想到达所有的学校，就需要在缩点后的所有起点都放上这个软件，因此答案是 ；对于子任务 ，我们的答案是 ，但如果整张图是一整个 ，就不需要再连任何边，答案就是 。 对于子任务 的感性理解：每个点都需要互相连通，首先就不能存在入度/出度为 的节点，因此最节省边的方式就是让起点和终点连边。一一对应地连，数量更少的那种点就会率先被连完，剩下的就是数量更多的那种点，再随便连几条边把剩余节点消耗完。最终答案就是 。当然若全图是一个 则无需理会。 代码在此 四倍经验：P2812 校园网络加强版、P2835 刻录光盘、P1262 间谍网络、P2002 消息扩散 洛谷 P2272 [ZJOI2007] 最大半连通子图 题目地址：P2272 题目难度：提高+/省选- 题目来源：浙江 2007 各省省选 一个有向图 称为半连通的 (Semi-Connected)，如果满足：，满足 或 ，即对于图中任意两点 ，存在一条 到 的有向路径或者从 到 的有向路径。 若 满足 ， 是 中所有跟 有关的边，则称 是 的一个导出子图。若 是 的导出子图，且 半连通，则称 为 的半连通子图。若 是 所有半连通子图中包含节点数最多的，则称 是 的最大半连通子图。 给定一个有向图 ，请求出 的最大半连通子图拥有的节点数 ，以及不同的最大半连通子图的数目 。由于 可能比较大，仅要求输出 对 的余数。 输入格式： 第一行包含两个整数 。分别表示图 的点数与边数， 的意义如上文所述。 接下来 行，每行两个正整数 ，表示一条有向边 。图中的每个点将编号为 ，保证输入中同一个不会出现两次。 输出格式： 应包含两行，第一行包含一个整数 ，第二行包含整数 。 数据范围： 对于 的数据，，，。 阅读题面可以发现，其实 本身就是一种特殊的半连通图，因此我们尽量多选图中的 。这就需要我们先缩点，缩点后再找最大的半连通子图。本着多选强连通分量的原则，对于缩点后的 ，我们选择最长的一条链（事实上，要求路径上所有强连通分量所包含点的总数最大）即可。 对于方案数，考虑 DP。做最长链的时候，如果发现下一个状态能够被更新，则更新总点数、同时把上一个点的方案计数覆盖过去；如果转移时发现路径长度相等，则把上一个点的方案数累加过去。 这时，我们需要对缩点后的图去重边，因为在 DP 转移时需要枚举出边，重边会造成 点数的重复计算。因此使用哈希表进行去重。 代码在此 AcWing 368 银河 题目地址：AcWing 368 题目难度：中等 银河中的恒星浩如烟海，但是我们只关注那些最亮的恒星。 我们用一个正整数来表示恒星的亮度，数值越大则恒星就越亮，恒星的亮度最暗是 。 现在对于 颗我们关注的恒星，有 对亮度之间的相对关系已经判明。 你的任务就是求出这 颗恒星的亮度值总和至少有多大。 输入格式： 第一行给出两个整数 和 。 之后 行，每行三个整数 ，表示一对恒星 之间的亮度关系。恒星的编号从 开始。 如果 ，说明 和 亮度相等。 如果 ，说明 的亮度小于 的亮度。 如果 ，说明 的亮度不小于 的亮度。 如果 ，说明 的亮度大于 的亮度。 如果 ，说明 的亮度不大于 的亮度。 输出格式： 输出一个整数表示结果。 若无解，则输出 。 数据范围： 看到这道题，第一反应是差分约束，根据题干给出的大小关系建图，然后跑最长路并求和得到答案。但是这种方法基于 的 （何况它已经死了），很容易超时。因此考虑用别的更优的算法解决。 联系到本文标题，使用 算法来优化找正环的步骤。读题发现每个值都需要大于等于 ，因此建立连接每个点、边权为 的虚拟源点来辅助。因为建出的图中的边权要么为 、要么是 ，而强连通分量中存在环，只要出现一个边权值为 ，那么就是正环了。 缩点后的图会变成一个 ，求解最长路只需要按照拓扑序进行一次递推。又知道缩点后的图是逆拓扑序的，因此递推时倒序即可。 代码","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"LCA 最近公共祖先","slug":"algorithm-lca","date":"2024-07-25T05:06:32.126Z","updated":"2024-07-25T22:31:54.345Z","comments":true,"path":"articles/39341/","link":"","permalink":"https://justpureh2o.cn/articles/39341/","excerpt":"","text":"LCA 树上倍增法 实质是把节点每次向上暴力移动一步变成更加高明的按 步向上移动，借用的是每个数都可进行二进制分解的定理。期间维护一个父节点数组 fa，fa[i][k] 代表 向上移动 步的父节点。那我们该如何更新这个父节点呢？显然有 ，就是两次向上移动 步，因此可以用 fa[fa[i][k - 1]][k - 1] 来递归更新。 初始化时使用宽搜，把所有点的深度更新一遍。注意要设置一个类似于 中的边界节点，深度设为 （根节点深度为 ），以防倍增移动时发生超出根节点的情况。 对于 的求解，基本思路是把待求的两个节点先挪到同一位置上，然后共同向上移动，当二者根节点已经相同时就可以返回这个根节点了。特殊地，如果上移到同一深度时两点已经重合，则直接返回两点中的其中一个。 模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#define N 500010using namespace std;struct Edge { int to, ne;} edges[N &lt;&lt; 1];int h[N], idx = 0;int fa[N][22];int dep[N];int root = 0;void add(int a, int b) { idx++; edges[idx].to = b; edges[idx].ne = h[a]; h[a] = idx;}void init() { memset(dep, 0x3f, sizeof dep); queue&lt;int&gt; q; dep[0] = 0; dep[root] = 1; q.push(root); while (!q.empty()) { int t = q.front(); q.pop(); for (int i = h[t]; ~i; i = edges[i].ne) { int j = edges[i].to; if (dep[j] &gt; dep[t] + 1) { dep[j] = dep[t] + 1; fa[j][0] = t; q.push(j); for (int k = 1; k &lt;= 21; k++) { fa[j][k] = fa[fa[j][k - 1]][k - 1]; } } } }}int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int k = 21; k &gt;= 0; k--) { if (dep[fa[a][k]] &gt;= dep[b]) a = fa[a][k]; } if (a == b) return a; for (int k = 21; k &gt;= 0; k--) { if (fa[a][k] != fa[b][k]) { a = fa[a][k]; b = fa[b][k]; } } return fa[a][0];}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); int n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; root; for (int i = 1; i &lt; n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; add(x, y); add(y, x); } init(); while (m--) { int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; LCA(a, b) &lt;&lt; endl; } return 0;} 再探次小生成树 一个半月前，我写了次小生成树的求解方法，当时是将非树边挨个加入进树中，形成一个环，并剔除这个环中最大的树内边，比较这些操作对最小生成树总边权的贡献从而得到原树的非严格次小生成树（若需要严格次小生成树则需要维护环上次大边）。其中为了找到环内最/次大边，我们使用了指数级别的 ，今天学习了倍增 ，可以用来优化这一方案。 洛谷 P4180 [BJWC2010] 严格次小生成树 题目地址：P4180 题目难度：提高+/省选- 题目来源：北京 2010 各省省选 依然是先求出最小生成树以及它的总边权，但是对于最大/次大边权的查询，考虑使用倍增 做法。 联系到递归求解 步父节点时的操作，其实维护树上最/次大边权也可如此。同样是把 拆解成两个 步，然后对于第一次移动，可以继续向下递归找到最/次大边权；第二次移动同理。最/次大值通过遍历就很容易找出来了，具体方法如下： 如果当前值严格大于维护的最大值，更新最大值为当前值，把次大值赋为原先的最大值。 如果当前值严格小于最大值且严格大于次大值，那么更新次大值为当前值。 对走两步分别得到的四个最/次大值执行遍历，就可以得到全局最/次大值了。在倍增 过程中，我们把（最小生成树中）节点移动过程中经历的所有树内边的最大值和次大值保存起来，解出全局最/次大值，并与当前升序遍历到的非树边权作比较，得出新边的贡献，即可解得次小生成树的权值。注意去除自环。 其中 d1[a][k] 代表节点 向上移动 步经过的边的最大权值，d2[a][k] 则是相应的次大权值。 代码过长（177行） 维护树上差分 AcWing 352. 闇くらの連ねん鎖さ 题目地址：AcWing 352 题目难度：困难 传说中的暗之连锁被人们称为 Dark。 Dark 是人类内心的黑暗的产物，古今中外的勇者们都试图打倒它。 经过研究，你发现 Dark 呈现无向图的结构，图中有 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。 Dark 有 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。 另外，Dark 还有 条附加边。 你的任务是把 Dark 斩为不连通的两部分。 一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。 一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。 但是你的能力只能再切断 Dark 的一条附加边。 现在你想要知道，一共有多少种方案可以击败 Dark。 注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。 输入格式： 第一行包含两个整数 和 。 之后 行，每行包括两个整数 和 ，表示 和 之间有一条主要边。 之后 行以同样的格式给出附加边。 输出格式： 输出一个整数表示答案。 数据范围： ，，数据保证答案不超过 。 假如树内边（主要边）用黑色表示，非树边（附加边）用红色表示。边上的数字代表：在砍断当前边的情况下还需要砍断多少附加边才能将图分成两部分（默认 ）。事实上，当图中添加了一组附加边，它所连接的两个树内点会和树内若干点组成一个环，并且这个环一定会过两点的最近公共祖先。我们这时从下往上，把环内边上的计数增加 ，就可得到如上的图。根据题意，显然有： 当该边计数为 时，砍断当前边后，任意砍断一条附加边即可，答案累加 当该边计数为 时，砍断当前边后，只能砍断特定的一条附加边，答案累加 当该边计数大于 时，因为最多只能砍两刀，因此不能通过砍当前主要边击败 Dark，答案不变 如何更新边上的计数呢？运用树上差分的思想——把权值的差分存储在图上，和序列差分一样，如果想要给某个区间内所有的数加减某个数，则只需在左端点和右端点加/减这个数，然后右端点的右边再减/加这个数，最后求前缀和即可得到原数；树上差分也很类似，我们在附加边连接的两个点上更改数值，然后找到它们的最近公共祖先，减去两倍的值即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;struct Edge { int to, ne;} edges[N &lt;&lt; 1];int h[N], idx = 0;int fa[N][20], depth[N];int dist[N];int m, ans = 0;void add(int a, int b) { idx++; edges[idx].to = b; edges[idx].ne = h[a]; h[a] = idx;}void init(int root) { memset(depth, 0x3f, sizeof depth); queue&lt;int&gt; q; depth[0] = 0; depth[root] = 1; q.push(1); while (!q.empty()) { int t = q.front(); q.pop(); for (int i = h[t]; ~i; i = edges[i].ne) { int j = edges[i].to; if (depth[j] &gt; depth[t] + 1) { depth[j] = depth[t] + 1; fa[j][0] = t; q.push(j); for (int k = 1; k &lt;= 19; k++) { fa[j][k] = fa[fa[j][k - 1]][k - 1]; } } } }}int LCA(int a, int b) { if (depth[a] &lt; depth[b]) swap(a, b); for (int k = 19; k &gt;= 0; k--) { if (depth[fa[a][k]] &gt;= depth[b]) a = fa[a][k]; } if (a == b) return a; for (int k = 19; k &gt;= 0; k--) { if (fa[a][k] != fa[b][k]) { a = fa[a][k]; b = fa[b][k]; } } return fa[a][0];}int dfs(int u, int f) { int res = dist[u]; // 当前记录的差分权 for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; if (j == f) continue; int t = dfs(j, u); // 获得子树的差分权值 if (t == 0) ans += m; else if (t == 1) ans++; res += t; // 向上更新，累加子树差分权 } return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); int n; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt; n; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); add(b, a); } init(1); for (int i = 1; i &lt;= m; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; int p = LCA(a, b); dist[a]++, dist[b]++, dist[p] -= 2; // 维护树上差分 } dfs(1, -1); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"SP15648 [APIO10A] - Commando 题解","slug":"solution-sp15648-commando","date":"2024-07-25T01:01:36.362Z","updated":"2024-07-25T02:56:43.596Z","comments":true,"path":"articles/90304/","link":"","permalink":"https://justpureh2o.cn/articles/90304/","excerpt":"","text":"小星野战力那么强一个人一组就够了ᕕ(◠ڼ◠)ᕗ 您已获得最佳的阅读体验！以及上面的小彩蛋…… 我们会发现这道题和 P5785 任务安排 长得神似。两道题都是把一个连续的序列分成若干块（块数没有特殊限制）。这启发我们把状态设置为 dp[i]，含义是：“把前 个士兵全部分好的最大修正战斗力”。 现在我们着手设计一个暴力 DP 程序，分析如下图： 因为 部分已知，就是我们的 dp[j]；我们重点需要解决的就是 部分的计算。 考虑到题面行动队战斗力的定义涉及到部分元素的和，因此预先维护整个序列的前缀和 ，于是 。把待求区间分成一组，初始战斗力就是 。本题还涉及到一个“修正战斗力”，且题目要求求解修正战斗力的最大值，不妨令 ，那么该组的修正战斗力就是 。 暴力 DP 代码就可以写出来了，时间复杂度 。预计 ，就不放了。 看到题面的 ，正解的时间复杂度很可能是 或 的。暴力程序的性能瓶颈卡在变量 的循环上，因此考虑优化 的求解，此时就开始了本题的重头戏——斜率优化/凸包优化。 把需要最大化的算式拿出来分析，我们进行化简可以得到： 进行斜率优化时，我们把 看作主元，并且希望让斜率仅和 有关。那我们移项可以得到： 类比直线的斜截式方程 ，发现这个式子可以用数形结合的方式做出来：斜率 ，截距 ，纵坐标 ，横坐标 。任务是最大化 dp[i] 的值，考虑到 ，所以只要构造的直线的截距最大，dp[i] 就是最大的。 对于特定斜率的直线，显然是靠上端的直线截距更大，如下图（若绘图有误烦请指出）： 对于不同斜率的点，截距最大的直线所过的点均在一个上凸包上（红线连出）： 同时，当前直线所过的点是第一个斜率比当前直线斜率小的点。“最小值最大”，那不就是二分嘛！别急，这道题可以不用二分，有更简便的方法。 考虑到每次代入的点 ，因为每个士兵的战斗力均为正数，显然它的前缀和不可能出现下降趋势，是单调递增的。又知道 是递增枚举的，所以每次构造的直线的斜率是单调递减的。因此考虑用单调队列维护这个合法点，具体操作如下： 当队头点的斜率大于了当前直线的斜率，显然不会再被用到，直接弹出。形式化地，当 时弹队头。 当队尾点的斜率小于将要加入的点 的斜率，原先的队尾已经不满足上凸包“斜率单调递减”的要求了，故弹出。也就是说当 时就弹出队尾。 至此，单调队列的队头就是我们所维护的 。把 代入状态转移方程里即可计算出答案了（注意超时的原因是暴力找 ，和状态转移方程本身没关系），由于涉及斜率的计算，要使用浮点数（或者你也可以就使用整型，斜率换成交叉相乘）。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define N 1000010using namespace std;typedef long long ll;double dp[N];double x[N], sumX[N];double a, b, c;int q[N];int hh = 0, tt = 0;double getY(int i) { // 获得纵坐标的值 return dp[i] + a * sumX[i] * sumX[i] - b * sumX[i];}double slope(int x1, int x2) { // 获取两点斜率 return (getY(x1) - getY(x2)) * 1.0 / (sumX[x1] - sumX[x2]) * 1.0;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, t; cin &gt;&gt; t; while (t--) { // 多测清空 memset(dp, 0, sizeof dp); memset(x, 0, sizeof x); memset(sumX, 0, sizeof sumX); hh = 0, tt = 0; // 初始时队列里已有一个元素0 cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x[i]; sumX[i] = sumX[i - 1] + x[i]; // 预处理前缀和 } q[0] = 0; for (int i = 1; i &lt;= n; i++) { while (hh &lt; tt &amp;&amp; slope(q[hh + 1], q[hh]) &gt;= 2 * a * sumX[i]) hh++; // 不满足单调性，弹出 int j = q[hh]; // 维护的点 double X = sumX[i] - sumX[j]; // 我们定义的X，用来简化计算 dp[i] = dp[j] + a * X * X + b * X + c; // 代入状态转移方程 while (hh &lt; tt &amp;&amp; slope(q[tt], q[tt - 1]) &lt;= slope(i, q[tt])) tt--; // 不满足上凸包性质，弹出 q[++tt] = i; // 插入新点 } cout &lt;&lt; (ll) dp[n] &lt;&lt; endl; // 注意转型成整型 } return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://justpureh2o.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"DP斜率优化/凸包优化 做题笔记","slug":"algorithm-dp-convex-hull-optimization","date":"2024-07-23T19:15:23.450Z","updated":"2024-07-24T18:36:34.251Z","comments":true,"path":"articles/63990/","link":"","permalink":"https://justpureh2o.cn/articles/63990/","excerpt":"","text":"受限于在线编辑器的性能瓶颈（省流：写太多了会很卡），在此决定把另外的（不在算法提高课中）DP斜率优化题目单独拎出来写一篇做题笔记。旨在记录算式消元换元的原则与技巧、凸包维护的方法。题目大致由易到难。 洛谷 P3195 [HNOI2008] 玩具装箱 题目地址：P3195 题目难度：省选/NOI- P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。 P 教授有编号为 的 件玩具，第 件玩具经过压缩后的一维长度为 。 为了方便整理，P教授要求： 在一个一维容器中的玩具编号是连续的。 同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 件玩具到第 个玩具放到一个容器中，那么容器的长度将为 。 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 ，其制作费用为 。其中 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 。但他希望所有容器的总费用最小。 输入格式： 第一行有两个整数，用一个空格隔开，分别代表 和 。 第 到 第 行，每行一个整数，第 行的整数代表第 件玩具的长度 。 输出格式： 输出一行一个整数，代表所有容器的总费用最小是多少。 数据结构： 对于全部的测试点，，，。 这道题就和《任务安排》一个模子了。设计状态为选前 个物品的花费最小值。同样枚举 然后代入题面长度公式，我们就能得到 的暴力递推公式：dp[i] = min(dp[i], dp[j] + (i - j - 1 + sumC[i] - sumC[j] - L) * (i - j - 1 + sumC[i] - sumC[j] - L))。 对等式进行化简： 考虑到 为常数，换元 ，因此： 发现一组同构，令 ，再次化简为： 然后拆括号： 我们的斜率需要一个只和循环变量 （以及常数项） 有关的值，对于直线方程，我们不希望斜率里出现任何有关不定项 的元素。综上，我们移项得到如下： 此时直线方程的每个要素都很明了了。因为 为正，就有 单调递增。根据上式有 ，不单调递减，启示我们维护截距 的最小值。因此可以直接单调队列维护下凸壳。具体要求如下： 创建一个双端队列来存放凸包上的点的下标 如果队头元素满足 ，则弹出队头。因为队头所维护的点的斜率已经失去最优性，在单调递增的斜率意义下不会再被用到。 如果队尾元素满足 ，则弹出队尾。因为引入的新点 使得原先维护的最值点不再最值，类比单调队列中不符合单调性时的弹出操作。 为了避免如上除法操作带来精度影响，故采用交叉相乘法。此时就需要注意相乘结果是否会爆类型。 代码在此 推式子时居然把斜率弄成了 ？？？ 洛谷 P3628 [APIO2010] 特别行动队 题目地址：P3628 题目难度：省选/NOI- 题目来源：APIO 2010 你有一支由 名预备役士兵组成的部队，士兵从 到 编号，你要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号应该连续，即为形如 的序列。所有的队员都应该属于且仅属于一支特别行动队。 编号为 的士兵的初始战斗力为 ，一支特别行动队的初始战斗力 为队内士兵初始战斗力之和，即 。 通过长期的观察，你总结出对于一支初始战斗力为 的特别行动队，其修正战斗力 ，其中 是已知的系数（）。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队的修正战斗力之和最大。试求出这个最大和。 输入格式： 输入的第一行是一个整数 ，代表士兵的人数。 输入的第二行有三个用空格隔开的整数，依次代表 ，即修正战斗力的系数。 输入的第三行有 个用空格隔开的整数，第 个整数代表编号为 的士兵的初始战斗力 。 输出格式： 输出一行一个整数，代表最大的所有特别行动队战斗力之和。 数据范围： 对于 的数据，。 对于 的数据， 对于 的数据，，，，，。 写出暴力状态转移方程：dp[i] = max(dp[i], dp[j] + a * X * X + b * X + c)，其中 。能拿 分，考虑优化。 那么斜率就是 、 就是 、截距 。我们需要最大化 ，观察到 ，我们需要让截距最大化。 类比先前推导过的最小化截距的方法，我们可以轻松得出一个结论——截距最大化，维护上凸壳！自己画个图可以知道，我们需要找的最值点就是第一个斜率小于当前直线斜率的点。观察到 有单调性，因此使用单调队列维护。因为这里的 是负数，所以在判断出队时需要变号。 代码在此","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://justpureh2o.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"动态规划的几种优化方式 Day2 斜率优化","slug":"algorithm-dp-enhancement-ii","date":"2024-07-22T18:25:45.281Z","updated":"2024-07-23T00:23:15.283Z","comments":true,"path":"articles/852/","link":"","permalink":"https://justpureh2o.cn/articles/852/","excerpt":"","text":"前情提要：Day1 单调队列优化 斜率优化 引 洛谷 P2365 任务安排 题目地址：P2365 题目难度：提高+/省选- 个任务排成一个序列在一台机器上等待完成（顺序不得改变），这 个任务被分成若干批，每批包含相邻的若干任务。 从零时刻开始，这些任务被分批加工，第 个任务单独完成所需的时间为 。在每批任务开始前，机器需要启动时间 ，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。 每个任务的费用是它的完成时刻乘以一个费用系数 。请确定一个分组方案，使得总费用最小。 输入格式： 第一行一个正整数 。 第二行是一个整数 。 下面 行每行有一对数，分别为 和 ，表示第 个任务单独完成所需的时间是 及其费用系数 。 输出格式： 一个数，最小的总费用。 数据范围： 对于 的数据，，，。 按照样例最优解给出的图示如上。 根据题目，我们的总花费应是每一组所包含线段的 之和乘上该组的结束时刻（终点在数轴上的横坐标）并求每一组的和。即 。 我们可以发现，最终结果受分组情况的影响。在每一组的开头，均有一段机器的启动时间，它可能会对后期某一组的结束时刻造成影响。有一个技巧，即提前把启动段造成的影响计算出来，而这很明显会牵扯到前缀和的计算。例如下边这个更为普遍的图： 假设 dp[i] 代表将前 个单任务全部分组完毕后的最小花费。在某一时刻，我们已经将前 个任务分成了 两个待处理的区间，并且准备把剩下的 区间划分为一组。分组就涉及到每组起始时的启动时间 。对于已经处理好的 区间，我们有 dp[j] 可以直接拿来调用；对于剩下的待处理区间，我们的总花费是 。其中 项的另一个乘数就代表在此处分组，启动时间 对后边所有的花费带来的影响。因为公式里出现了部分和，因此预处理 的前缀和。 注意到 ，且 ，因此算法是 的。因为数据较小，此方法可以通过，状态转移方程 dp[i] = min(dp[i], dp[j] + sumT[i] * (sumF[i] - sumF[j]) + s * (sumF[n] - sumF[j]))。 AcWing 301 任务安排2 题目地址：AcWing 301 题目难度：中等 题面相同，本题数据范围扩大到： ，， 状态转移方程与上一题完全相同，我们在这里探讨它的优化方式。 我们的目的是把求解状态的时间复杂度降落到 及以下，首先就需要压缩维度。先从 的循环开始——观察到方程中涉及到 的项有两个：dp[j] 和 sumF[j]。我们将 拆出来，便于简化。得到： 由题目给定，每次循环的 均有一个固定值，因此有关 的项为定值。例如 、。我们成功地把整个算式改造成了更为清爽的形式。联想到直线的斜截式方程： 把转移方程看作这样一个方程，那么斜率 ，截距 。 我们需要最小化 ，显然需要让 最小，因为 。因为直线 过点 ，……相应地，点 等也在这条直线上，问题再度简化为：“对于每次变化的斜率，找出一个点，使得当前直线截距最小”。 可以发现，无论直线的斜率再怎么变动，能让截距取得最值的那个点从始至终都是下边的那几个。事实上，对于斜率为 的直线，让它取得最值的点都是第一个斜率比 大的点。剩下的点就完全是鸡肋了。 二维凸包是指内角均在 范围内的凸多边形，相当于用一个橡皮筋围住一些固定的大头针，橡皮筋围出来的图形就是一个凸包。因为橡皮筋总是自发地向周长减小的方向去收缩，因而凸包在周长上具有优势。在上图中，红色线连出来的就是一个凸包的下边界。从左至右，每两个点连线的斜率是单调递增的，且直线倾斜角小于 。这启发我们把下边界上的每个点的斜率统计出来，然后组成一个斜率单调递增的点序列，对于每条直线，在序列中找到第一个斜率大于当前直线斜率的点即可，从而想到使用 upper_bound 或者是二分解决。 在本题中，有一些奇妙的性质。这些性质允许我们不使用二分，而是直接 查询合法解： 均为正整数，对于它们的前缀和显然也如此。循环 时， 是单调递增的。 每次新加入一个点 时，由于如上的单调性，点的横坐标是单调递增的。 因此我们在查询时，把队头斜率小于当前斜率的点弹出；插入时把队尾不在凸包上的点删去，其实就是让新读取的点代替原先的点。定量来说，就是：当 时弹出点 ；当 时弹出队尾点（代码中常用交叉相乘避免除法精度问题，但需要开 long long）。循环时只需要把 设置成符合要求的凸包上的点就行了。以上其实也是 扫描法维护凸包的核心思想。因为涉及到队列中非首尾元素的访问，故使用数组模拟。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define N 300010using namespace std;typedef long long ll;ll dp[N];ll f[N], t[N];int q[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, s; cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; t[i] &gt;&gt; f[i]; f[i] += f[i - 1]; t[i] += t[i - 1]; } int hh = 0, tt = 0; q[0] = 0; for (int i = 1; i &lt;= n; i++) { while (hh &lt; tt &amp;&amp; (dp[q[hh + 1]] - dp[q[hh]]) &lt;= (t[i] + s) * (f[q[hh + 1]] - f[q[hh]])) hh++; int j = q[hh]; dp[i] = dp[j] - (t[i] + s) * f[j] + f[i] * t[i] + s * f[n]; while (hh &lt; tt &amp;&amp; (dp[q[tt]] - dp[q[tt - 1]]) * (f[i] - f[q[tt]]) &gt;= (dp[i] - dp[q[tt]]) * (f[q[tt]] - f[q[tt - 1]])) tt--; q[++tt] = i; } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;} 洛谷 P5785 [SDOI2012] 任务安排/AcWing 302 任务安排3 题目地址：P5785/AcWing 302 题目难度：省选/NOI-/困难 题目来源：山东 2012 各省省选 题面相同，数据范围中 可能为负数。 为负数，代表它的前缀和，或者更进一步—— 不再单调递增。此时使用单调队列维护凸包的思路就不再正确。但是考虑到我们要求大于当前斜率且斜率相对最小的点（最大的最小），考虑二分。 需要注意的是，尽管待求直线的斜率 失去了单调性，但是凸包的基本性质并没改变，下凸包相邻两点构成的斜率还是单调递增的。因此继续用队列维护凸包，这时只需维护点是否在凸包上，即不满足要求时弹出队尾。对于每次 的输入，都二分出一个斜率大于它且最接近它的凸包点，把 赋值过去就完成了（把 int j = q[hh] 替换成二分查找）。 由于本题数据较大，在交叉相乘时可能会爆，因此推荐使用 double 或 __int128。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define N 300010using namespace std;typedef long long ll;ll dp[N];ll f[N], t[N];int tt = 0;int q[N];int upperbound(ll piv) { int L = 0, R = tt; while (L &lt; R) { int mid = (L + R) &gt;&gt; 1; if ((__int128) (dp[q[mid + 1]] - dp[q[mid]]) &gt; (__int128) (f[q[mid + 1]] - f[q[mid]]) * piv) R = mid; else L = mid + 1; } return q[L];}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, s; cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; t[i] &gt;&gt; f[i]; t[i] += t[i - 1]; f[i] += f[i - 1]; } q[0] = 0; for (int i = 1; i &lt;= n; i++) { int j = upperbound(t[i] + s); dp[i] = dp[j] - (t[i] + s) * f[j] + f[i] * t[i] + s * f[n]; while (tt &amp;&amp; (__int128) (dp[q[tt]] - dp[q[tt - 1]]) * (f[i] - f[q[tt]]) &gt;= (__int128) (dp[i] - dp[q[tt]]) * (f[q[tt]] - f[q[tt - 1]])) tt--; q[++tt] = i; } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;} CF 311B Cats Transport 题目地址：CF 311B 题目难度：省选/NOI- Zxr960115 是一个大农场主。 他养了 只可爱的猫子,雇佣了 个铲屎官。这里有一条又直又长的道路穿过了农场，有 个山丘坐落在道路周围，编号自左往右从 到 。山丘 与山丘 的距离是 米。铲屎官们住在 号山丘。 一天，猫子们外出玩耍。猫子 去山丘 游玩，在 时间结束他的游玩，然后在山丘 傻等铲屎官。铲屎官们必须把所有的猫子带上。每个铲屎官直接从 走到 ，中间不停下，可以认为不花费时间的把游玩结束的猫子带上。每个铲屎官的速度为一米每单位时间，并且足够强壮来带上任意数量的猫子。 举个栗子，假装我们有两个山丘( )，有一只猫子，他想去山丘 玩到时间 。然后铲屎官如果在时间 或者时间 从 号山丘出发，他就能抱走猫子。如果他在时间 出发那么就不行(猫子还在玩耍)。如果铲屎官在时间 出发，猫子就不用等他（）。如果他在时间 出发，猫子就要等他 个单位时间。 你的任务是安排每个铲屎官出发的时间(可以从 0 时刻之前出发），最小化猫子们等待的时间之和。 对于全部的数据，满足 ，，，，，。 输入格式： 输入的第一行是三个整数 。 第二行有 个整数，分别是 。 接下来 行，每行两个整数 。 输出格式： 一行一个整数，为最小化的等待时间之和。 在本题中，请务必使用 cin/cout 或者 %I64d 通配符来读入64位整数。 读题就能发现，我们的饲养员的行走时间和 的前缀和有关，因此预处理出来，重定义 。根据题意我们知道，当饲养员的出发时间早于或等于 时，都等价于 （刚好接到，毕竟干等着猫玩完的那一刻再接回去也是一样的），可以看作是饲养员出发时间的下限。更普遍地，假设 饲养员出发的时间为 ，就有 。 接下来的转换非常巧妙：定义 ，即最早出发时间。按照 升序排序获得一个新的序列，我们试着把排序后的山分组，使得总等待时间最小。看上去就有点《任务安排》三部曲的意思了。 假如我们的饲养员想要一次性接完排序 的小猫，他的最早出发时间就是 ， 号总的等待时间就是 （）。普遍规律就是： 这道题还有一个硬性要求——饲养员的个数不超过 ，因此开两维动态规划数组 dp[i][j] 表示使用了 名饲养员去接前 只小猫的最小等待时长总和。在 范围内，用中间变量 分隔开：对于 ，它的最小值就是 dp[k][j - 1]，那么我们派出第 名饲养员去接小猫 ，造成的花费是 。至此这道题完全转化为了《任务安排》三部曲。状态转移方程为：dp[i][j] = min(dp[i][j], dp[k][j - 1] + (i - k) * a[i] - (sumA[i] - sumA[k])) 同样的思路，我们把方程化简成 的形式。原则是把斜率设置成不变量，因此得到： 斜率是 ，注意到当前 是单调递增的，因此沿用单调队列来维护整个凸包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define N 200010#define P 110using namespace std;typedef long long ll;int q[N];ll dp[N][P], a[N];ll sumD[N], sumA[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; sumD[i]; sumD[i] += sumD[i - 1]; } for (int i = 1; i &lt;= m; i++) { int h, t; cin &gt;&gt; h &gt;&gt; t; a[i] = t - sumD[h]; } sort(a + 1, a + 1 + m); for (int i = 1; i &lt;= m; i++) sumA[i] = sumA[i - 1] + a[i]; memset(dp, 0x3f, sizeof dp); for (int i = 0; i &lt;= p; i++) dp[0][i] = 0; for (int j = 1; j &lt;= p; j++) { int hh = 0, tt = 0; q[0] = 0; for (int i = 1; i &lt;= m; i++) { while (hh &lt; tt &amp;&amp; dp[q[hh + 1]][j - 1] + sumA[q[hh + 1]] - dp[q[hh]][j - 1] - sumA[q[hh]] &lt;= a[i] * (q[hh + 1] - q[hh])) hh++; dp[i][j] = dp[q[hh]][j - 1] + i * a[i] - q[hh] * a[i] - sumA[i] + sumA[q[hh]]; while (hh &lt; tt &amp;&amp; (dp[q[tt]][j - 1] + sumA[q[tt]] - dp[q[tt - 1]][j - 1] - sumA[q[tt - 1]]) * (i - q[tt]) &gt;= (dp[i][j - 1] + sumA[i] - dp[q[tt]][j - 1] - sumA[q[tt]]) * (q[tt] - q[tt - 1])) tt--; q[++tt] = i; } } cout &lt;&lt; dp[m][p] &lt;&lt; endl; return 0;}","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://justpureh2o.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"计算几何","slug":"计算几何","permalink":"https://justpureh2o.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"动态规划的优化方式 Day1 单调队列优化","slug":"algorithm-dp-enhancement","date":"2024-07-20T16:37:55.862Z","updated":"2024-07-22T18:24:51.510Z","comments":true,"path":"articles/3424/","link":"","permalink":"https://justpureh2o.cn/articles/3424/","excerpt":"","text":"有人私信我，说能不能不要在博客里写那么多“显然”。我的回答是：“好的，全部换成‘Apparently’”。我寻思我也没写那么多显然啊 单调队列优化 简介 我们都知道单调队列是用来 维护一个序列的单调性的，在一个定长区间内，单调队列可以做到输出当前扫描区间内的最值元素。通过维护区间最值，在动态规划问题中，可以有效节省状态枚举带来的效率浪费，有时还可以用来对数组降维，是非常实用且简单的优化方法。 优化一个动态规划问题需要首先提出它的朴素解法，在保证正确性的前提下再来思考它的优化方式。例如下面这几道例题： 洛谷 P1714 切蛋糕 题目地址：P1714 题目难度：普及+/提高 今天是小 Z 的生日，同学们为他带来了一块蛋糕。这块蛋糕是一个长方体，被用不同色彩分成了 个相同的小块，每小块都有对应的幸运值。 小 Z 作为寿星，自然希望吃到的蛋糕的幸运值总和最大，但小 Z 最多又只能吃 小块的蛋糕。 请你帮他从这 小块中找出连续的 块蛋糕，使得其上的总幸运值最大。 形式化地，在数列 中，找出一个子段 ，最大化 。 输入格式： 第一行两个整数 。分别代表共有 小块蛋糕，小 Z 最多只能吃 小块。 第二行 个整数，第 个整数 代表第 小块蛋糕的幸运值。 输出格式： 仅一行一个整数，即小 Z 能够得到的最大幸运值。 数据范围： 对于 的数据，有 。 对于 的数据，有 ，。 保证答案的绝对值在 之内。 首先提出一个朴素做法：预处理序列的前缀和，记作 sum 数组，假设 dp[i]是以a[i] 结尾、子段长度不超过 的最大子段和。那么： 因此首先可以设计出一个双层循环，外层 ，内层 。这样做的时间复杂度是 ，对于 的数据无能为力，至少需要提出一个 的算法来解决。因此我们想到 的单调队列优化。 对于每一次外层循环， 有一个固定的值，因而 是定值，是我们处理的 的前缀和。因此最大化上式，只需要让 取最小值即可。那么 ，求 就可以转化为滑动窗口问题了。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define N 500010using namespace std;int sum[N], a[N];deque&lt;int&gt; q;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; sum[i] = sum[i - 1] + a[i]; } int ans = -INT_MAX; for (int i = 1; i &lt;= n; i++) { while (!q.empty() &amp;&amp; sum[i - 1] &lt; sum[q.front()]) q.pop_front(); q.push_front(i - 1); if (i - 1 - q.back() == m) q.pop_back(); ans = max(ans, sum[i] - sum[q.back()]); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 洛谷 P2627 [USACO11OPEN] Mowing the Lawn G 题目地址：P2627 题目难度：提高+/省选- 题目来源：USACO 2011 在一年前赢得了小镇的最佳草坪比赛后，Farmer John 变得很懒，再也没有修剪过草坪。现在，新一轮的最佳草坪比赛又开始了，Farmer John 希望能够再次夺冠。 然而，Farmer John 的草坪非常脏乱，因此，Farmer John 只能够让他的奶牛来完成这项工作。Farmer John 有 （）只排成一排的奶牛，编号为 。每只奶牛的效率是不同的，奶牛 的效率为 （）。 靠近的奶牛们很熟悉，因此，如果 Farmer John安排超过 只连续的奶牛，那么，这些奶牛就会罢工去开派对 :)。因此，现在 Farmer John 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 只奶牛。 输入格式： 第一行：空格隔开的两个整数 和 。 第二到 行：第 行有一个整数 。 输出格式： 第一行：一个值，表示 Farmer John 可以得到的最大的效率值。 既然不能有超过 个连续的元素被选中，转换一下就变成了在 个元素中至少要选中其中一个。题目要求总效率最高，那我们就让未选奶牛的效率总和最小就行了。假设 dp[i] 代表在前 只奶牛中，且不选择第 只奶牛损失的最小效率。初始时， dp[i] = e[i]，在动态规划过程中，对于当前的每一个 ，都在前 个元素中选择最小的那个累加（使用单调队列维护长为 的滑动窗口）即可。在最后 个计算值中取最小的，用总和减去就行。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;typedef long long ll;ll dp[N];ll sum;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; dp[i]; sum += dp[i]; } deque&lt;ll&gt; q; ll ans = INFINITY; q.push_front(0); for (int i = 1; i &lt;= n; i++) { if (i - q.back() &gt; k + 1) q.pop_back(); dp[i] += dp[q.back()]; while (!q.empty() &amp;&amp; dp[i] &lt; dp[q.front()]) q.pop_front(); q.push_front(i); } for (int i = n - k; i &lt;= n; i++) ans = min(ans, dp[i]); cout &lt;&lt; sum - ans &lt;&lt; endl; return 0;} 双倍经验：P2034 选择数字。 洛谷 P2216 [HAOI2007] 理想的正方形 题目地址：P2216 题目难度：普及+/提高 题目来源：河南 2007 各省省选 有一个 的整数组成的矩阵，现请你从中找出一个 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 输入格式： 第一行为 个整数，分别表示 的值。 第二行至第 行每行为 个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。 输出格式： 仅一个整数，为 矩阵中所有“ 正方形区域中的最大整数和最小整数的差值”的最小值。 数据范围： 矩阵中的所有数都不超过 。 的数据 。 的数据 。 其实跟动态规划没啥关系，按理说应该只归到单调队列下的 这道题首先需要我们找出一个正方形区域内的最大和最小值， 运算的性质—— 启发我们可以先将每一行连续 个数的最值统一存起来，然后再按列求最值，最终就得到了这个正方形区块内的最值元素。每次求出列最值后直接更新答案就好。需注意的是传参时是 a 还是 b。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 1010using namespace std;int g[N][N];int row_min[N][N], row_max[N][N], col_min[N], col_max[N];int tmp[N];int a, b, n;deque&lt;int&gt; q;void getMax(const int arr[], int dest[], int size) { // Get max segmental element from arr and copy the result to dest q.clear(); for (int i = 1; i &lt;= size; i++) { if (!q.empty() &amp;&amp; i - q.back() &gt;= n) q.pop_back(); while (!q.empty() &amp;&amp; arr[i] &gt;= arr[q.front()]) q.pop_front(); q.push_front(i); dest[i] = arr[q.back()]; }}void getMin(const int arr[], int dest[], int size) { q.clear(); for (int i = 1; i &lt;= size; i++) { if (!q.empty() &amp;&amp; i - q.back() &gt;= n) q.pop_back(); while (!q.empty() &amp;&amp; arr[i] &lt;= arr[q.front()]) q.pop_front(); q.push_front(i); dest[i] = arr[q.back()]; }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; a &gt;&gt; b &gt;&gt; n; for (int i = 1; i &lt;= a; i++) { for (int j = 1; j &lt;= b; j++) { cin &gt;&gt; g[i][j]; } } for (int i = 1; i &lt;= a; i++) { getMax(g[i], row_max[i], b); getMin(g[i], row_min[i], b); } int res = INFINITY; for (int i = n; i &lt;= b; i++) { for (int j = 1; j &lt;= a; j++) tmp[j] = row_max[j][i]; getMax(tmp, col_max, a); for (int j = 1; j &lt;= a; j++) tmp[j] = row_min[j][i]; getMin(tmp, col_min, a); for (int j = n; j &lt;= a; j++) res = min(res, col_max[j] - col_min[j]); } cout &lt;&lt; res &lt;&lt; endl; return 0;} 三倍经验：P9905 [COCI 2023/2024 #1] AN2DL、CF846D Monitor.","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://justpureh2o.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"并查集的高级用法——权值并查集与种类并查集","slug":"algorithm-advanced-dsu","date":"2024-07-18T19:36:41.496Z","updated":"2024-07-18T19:42:21.297Z","comments":true,"path":"articles/74839/","link":"","permalink":"https://justpureh2o.cn/articles/74839/","excerpt":"","text":"并查集 并查集，或称DSUDisjoint Set Union，是一种管理元素所属集合的数据结构。每次查询时把沿途的节点的父节点一并设置成全局父节点，从而达到均摊复杂度 的超高效率（其中 为 的反阿克曼函数，可以看作为常数复杂度）。基于并查集的许多特性（包括好写），人们开发出了许多不同种类不同用途的并查集，其中就包括带边权的权值并查集和对元素进行分类的种类并查集。这篇文章将探讨这两种并查集的实现及相关应用。 权值并查集 在并查集的边上加上边权，每次查找父节点时把边权向上推送更新，从而达到类似于线段树 pushup 操作的效果。 UVA 11987 Almost Union-Find 题目地址：UVA 11987 题目难度：提高+/省选- 有 个集合， 次操作。规定第 个集合里初始只有 。有三种操作： 输入两个元素 和 ，若 和 不在一个集合中，合并两个元素的集合。 输入两个元素 和 ，若 和 不在一个集合中，把 添加到 所在的集合。 输入一个元素 ，查询 所在集合的元素个数和所有元素之和。 输入格式： 有几组数据。 每组数据第一行输入 和 两个整数。 每组数据以下 行，每行第一个数 代表选择哪一个命令，若 是 或 命令，则再输入两个整数 和 。若 是 ，则输入一个整数 。 输入文件结束符（EOF）结束输入。 输出格式： 输出行数为每组数据 号命令的总数。 每一行输出两个整数 和 ，即元素个数和元素和。 数据范围： ，。 原题面 PDF：Here 这道题在普通并查集维护所属集合的要求外，另外要求我们维护并查集的集合大小及元素总和，因此考虑权值并查集。基本思路是：在每次合并操作时，更新被插入集合父节点的 sum 与 size，累加上待插入集合的 sum 与 size 即可。特殊一点，对于移动操作（相当于把待插入集合变成一个大小为 的单点）也是一样。 那么如何实现单点的移动呢？一般的思路是把点的父亲直接指向被插入集合的根，但这显然是错误的，因为： 当我们根据并查集的标准合并方式合并节点 到树 时，我们会把从属于 号的 号节点也一并接过去，这是我们不希望的，期望效果是只把 送过去，只留下 号一个在原位置。 那我们就需要提出一种建图方式，使得 不直接与 相连，但是要求 又属于 树。考虑为每个集合设置虚拟源点，初始时每个集合就是以虚拟源点为根，普通节点为叶子的两点集合。如此一来，移动操作就变成了下图： 然后就可以按照普通并查集的方法解了（因为创建了 个虚拟源点，空间要开二倍）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define N 200010using namespace std;typedef long long ll;int p[N], vol[N];ll sum[N];int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x];}void merge(int a, int b) { int u = find(a), v = find(b); p[u] = v; sum[v] += sum[u]; vol[v] += vol[u];}void move(int a, int dest) { int u = find(a), v = find(dest); p[a] = v; vol[v]++; vol[u]--; sum[u] -= a; sum[v] += a;}bool related(int a, int b) { return find(a) == find(b);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; while (cin &gt;&gt; n &gt;&gt; m) { for (int i = 1; i &lt;= 2 * n; i++) { if (i &lt;= n) { p[i] = i + n; vol[i] = 1; sum[i] = i; } else if (i &gt; n) { p[i] = i; vol[i] = 1; sum[i] = i - n; } } while (m--) { int k, a, b; cin &gt;&gt; k; if (k == 1) { cin &gt;&gt; a &gt;&gt; b; if (!related(a, b)) merge(a, b); } else if (k == 2) { cin &gt;&gt; a &gt;&gt; b; if (!related(a, b)) move(a, b); } else { cin &gt;&gt; a; int u = find(a); cout &lt;&lt; vol[u] &lt;&lt; ' ' &lt;&lt; sum[u] &lt;&lt; endl; } } } return 0;} 练习：P1196 [NOI2002] 银河英雄传说 种类并查集 一般的并查集可以用来维护一个带有传递性和连通性的集合，例如你亲戚的亲戚仍然是你的亲戚，普通并查集就可以做到维护你的所有亲戚和非亲戚，并判断某人是否是你的亲戚；而种类并查集则是它的升级，普通的并查集显然无法轻易维护诸如“敌人的敌人是朋友”的人际关系。这时，我们就可以多开几个普通的并查集用来维护不同类别之间的关系，即种类并查集。 P2024 [NOI2001] 食物链 题目地址：P2024 题目难度：普及+/提高 题目来源：NOI 2001 动物王国中有三类动物 ，这三类动物的食物链构成了有趣的环形。 吃 ， 吃 ， 吃 。 现有 个动物，以 编号。每个动物都是 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 个动物所构成的食物链关系进行描述： 第一种说法是 1 X Y，表示 和 是同类。 第二种说法是2 X Y，表示 吃 。 此人对 个动物，用上述两种说法，一句接一句地说出 句话，这 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话； 当前的话中 或 比 大，就是假话； 当前的话表示 吃 ，就是假话。 你的任务是根据给定的 和 句话，输出假话的总数。 输入格式： 第一行两个整数，，表示有 个动物， 句话。 第二行开始每行一句话（按照题目要求，见样例） 输出格式： 一行，一个整数，表示假话的总数。 数据范围： 对于全部数据，，。 这道题是种类并查集的经典应用之一，用来判断一个不等式组是否有冲突矛盾。之前在讲Floyd 传递闭包的时候，我们就介绍了用传递闭包求解不等式组解的情况的方法。但是这种基于 算法的解法，其时间复杂度是恐怖的 ，在这道题里显然会超时，我们转而使用种类并查集来解决这道题。 整理一下题面，把这些动物分成三类——“国王”、“大臣”和“平民”。国王统治大臣、大臣压榨平民、平民推翻国王。但是关键是我们不知道动物的初始分类，因此我们在每一类里都放上 个节点。 然后，对于操作 ——可能出现的矛盾是：二者不为同类，这里却归为同类；对于操作 ，可能出现的是：倒反天罡（大臣搞国王、平民踩大臣）、自残（自己吃自己）。换句话说，如果某个节点的根指到其他区域，那么这两个动物在当前信息下不可能成为同类；如果不满足镇压关系的二者共用同一个根，显然也不成立。 根据并查集所带的实际意义判断即可。注意如果当前命题是正确的，不要忘记合并到并查集里。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define N 50010using namespace std;int p[N * 3];int n;int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x];}void merge(int a, int b) { p[find(a)] = find(b);}bool related(int a, int b) { return find(a) == find(b);}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int k, ans = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= 3 * n; i++) p[i] = i; while (k--) { int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (x &gt; n || y &gt; n) ans++; else if (op == 1) { if (related(x + n, y) || related(x, y + n)) ans++; else { merge(x, y); merge(x + n, y + n); merge(x + 2 * n, y + 2 * n); } } else { if (related(x, y) || related(x, y + n)) ans++; else { merge(x, y + 2 * n); merge(x + n, y); merge(x + 2 * n, y + n); } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 练习：P1955 [NOI2015] 程序自动分析","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"基础数据结构合辑","slug":"algorithm-ds-compilation","date":"2024-07-17T22:46:30.908Z","updated":"2024-10-06T03:23:38.527Z","comments":true,"path":"articles/30284/","link":"","permalink":"https://justpureh2o.cn/articles/30284/","excerpt":"","text":"单调栈/单调队列 单调栈 单调栈Monotone Stack，顾名思义，是一种栈状结构，且栈内元素单调。它既满足栈的“先进后出F I L O”性质，也符合元素从栈顶到栈底呈单调排列（或者从栈底到栈顶）。根据单调性的不同，大致可以分为“单调递增栈”和“单调递减栈”。若无特殊说明，单调栈的递增/递减判断顺序是从栈顶到栈底。 在单调栈构建过程中，有如下要求： 当前待插入元素与栈顶元素满足全栈的单调关系，则直接插入顶端。 反之，弹出栈顶元素直到满足第一点，此时直接插入。 例如一个单调递增栈的实现： 123456stack&lt;int&gt; stk;void insert(int x) { while (!stk.empty() &amp;&amp; stk.top() &gt; x) stk.pop(); stk.push(x);} 没错就这么短 依据单调栈的这些性质，人们探索出了一种能在 时间复杂度内求解下一大元素N G E问题（或者下一小元素）的算法。 我们新建一个数组用来记录下一大元素的下标，数组 nge[i] 即表示原序列中下标 的元素的下一大元素的下标。让单调栈存储元素下标，当每次待插入的元素大于栈顶下标对应的元素时，则记录当前栈顶到 nge 中，并弹出栈顶。如此一来便处理得到了一个完整的 nge 数组 P5788 [模板] 单调栈 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define N 3000010using namespace std;typedef long long ll;stack&lt;int&gt; stk;ll arr[N];int nge[N];int n;void NGE() { for (int i = 1; i &lt;= n; i++) { while (!stk.empty() &amp;&amp; arr[i] &gt; arr[stk.top()]) { nge[stk.top()] = i; stk.pop(); } stk.push(i); }}int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; arr[i]; NGE(); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; nge[i] &lt;&lt; ' '; return 0;} 单调队列 单调队列Monotone Queue其实和单调栈非常相似——给队列规定一个定长，让它在一段序列上滑动，当队首元素符合单调性则推入，否则就弹出队首直到满足单调性为止，同时，队列随着每次的滑动会自然抛除末尾的某个值。这样一来，单调队列就可以解决区间内最值的问题。 首先，我们依据单调栈里面的单调性检验，弹出队头不符合单调性的值。接着，把当前的值插入队头。如果队头元素的下标与队尾元素下标的差值超过了队列长度，则自然淘汰掉。反之输出队尾元素，它储存了当前区间的最值。 P1886 滑动窗口 /[模板] 单调队列 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define N 1000010using namespace std;typedef long long ll;struct Node { int idx; ll v;} nodes[N];deque&lt;Node&gt; q;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; nodes[i].v; nodes[i].idx = i; } for (int i = 1; i &lt;= n; i++) { while (!q.empty() &amp;&amp; nodes[i].v &lt; q.front().v) q.pop_front(); q.push_front(nodes[i]); if (i - q.back().idx == k) q.pop_back(); if (i &gt;= k) cout &lt;&lt; q.back().v &lt;&lt; ' '; } cout &lt;&lt; endl; q.clear(); for (int i = 1; i &lt;= n; i++) { while (!q.empty() &amp;&amp; nodes[i].v &gt; q.front().v) q.pop_front(); q.push_front(nodes[i]); if (i - q.back().idx == k) q.pop_back(); if (i &gt;= k) cout &lt;&lt; q.back().v &lt;&lt; ' '; } return 0;} ST 表 ST 表Sparse Table是一种能在 时间内预处理， 回答区间最值查询（不支持修改，若要修改请移步线段树）的一种数据结构。借用了动态规划的思想，兼以步长 的倍增。 对于一段静态序列（不变），为了求某段子列的最大值，先把这个子列分成两个更小的子序列。假设 表示在区间 内的最大值，对于单个点，即 时，显然有 （最大值就是自己）。否则，最大值即是左区间最大值和右区间最大值更大的那一个。 P3865 [模板] ST 表 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int a[N];int logn[N];int f[N][22];int n;void init() { for (int i = 1; i &lt;= n; i++) f[i][0] = a[i]; for (int j = 1; j &lt;= logn[n]; j++) { for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) { f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); } }}void initLog() { logn[1] = 0; logn[2] = 1; for (int i = 3; i &lt;= n + 100; i++) logn[i] = logn[i &gt;&gt; 1] + 1;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; initLog(); init(); while (m--) { int l, r; cin &gt;&gt; l &gt;&gt; r; int tmp = logn[r - l + 1]; cout &lt;&lt; max(f[l][tmp], f[r - (1 &lt;&lt; tmp) + 1][tmp]) &lt;&lt; endl; } return 0;} 个人感觉理解难度有点大，建议先背下来 警示后人：不要用 endl，换成 \\n 快了高达七倍不止！AC、TLE。 在 C++ 中，数组的访问是行优先的。因此如果把 ST表数组的第一维和第二维交换位置，那么程序的运行效率会变得更高 并查集 并查集Disjoint Set Union，顾名思义，它是一种能完成数据合并、查询的集合数据结构。在路径压缩优化下，它能在平均 的时间复杂度内完成一次操作（由 证明，他也是 的奠基人之一）。关于并查集时间复杂度的证明请看：并查集复杂度 - OI Wiki。 首先，我们需要一个数组来记录每个点的父节点。在查询时，我们采取从底部逐级向上递归搜索的方式，可以发现，我们在实际操作时并不会关心它到根节点路径上的其他非根节点，出于效率考虑，可以将沿途每个点的父节点都一次性设成全局父节点，而这一切都可以在递归查询的过程中完成。在合并时，无需将每个点都合并过去，只需要把某棵树的根节点并到另一棵树的根节点下面去就行了！ P3367 [模板] 并查集 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int p[10010];int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x];}void merge(int x, int y) { p[find(x)] = find(y);}bool query(int x, int y) { return find(x) == find(y);}int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) p[i] = i; for (int i = 1; i &lt;= m; i++) { int z, x, y; cin &gt;&gt; z &gt;&gt; x &gt;&gt; y; if (z == 1) merge(x, y); else { if (query(x, y)) cout &lt;&lt; \"Y\" &lt;&lt; endl; else cout &lt;&lt; \"N\" &lt;&lt; endl; } } return 0;} 关于带权并查集、种类并查集，请参阅这篇博客。 哈希/散列函数 哈希Hash或者称“散列”，其运作原理是把一个数据映射到一个较小（但不能太小）的值域里进行比较。通常来说，我们希望哈希满足如下两个性质： 两个对象哈希值不同，则两个对象一定不同 哈希值相同，则两个对象不一定相同 人们把第二种情况中可能出现的“对象不同却哈希相同”的现象叫做“哈希碰撞Hash Clash”。 对于一个字符串 ，一般采取的是多项式散列的方法。首先把字符串的每一位挑出来，类比成一个数字位，然后采取形如 的方法获取它的散列结果。举个例子，字符串 会被散列成 。一般来说，把 设定成一个较大质数，发生碰撞的概率是很低的阳寿碰撞就没办法了，多交几次吧。 当然，你也可以使用碰撞率更低的 MD5，但是 C++ 并没有内置相关的库，你如果想用，那么就必须要完全背下来或者是现场复制。其实还不如自己选特殊值算。 按照上边的方法计算，复杂度是 。如果加上询问，那就是 。在多次询问子串哈希时，观察到有如下式子： 假设 代表原字符串区间 内的子串的哈希值，那么 。现在就可以最快用 的快速幂求解了。 P3370 [模板] 字符串哈希 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MOD = 1000000007;const int b = 2;map&lt;string, int&gt; mp;int qpow(int a, int b) { int res = 1; while (b) { if (a &amp; 1) res = (ll) (res * a) % MOD; a = (ll) (a * a) % MOD; b &gt;&gt;= 1; } return res;}int hashStr(string s) { int res = 0; for (int i = 0; i &lt; s.length(); i++) { res = (res + (s[i] - '0') * qpow(b, s.length() - i - 1)) % MOD; } return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { string s; cin &gt;&gt; s; int h = hashStr(s); if (!mp.count(s)) mp[s] = h; } cout &lt;&lt; mp.size() &lt;&lt; endl; return 0;}","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"伸展树 Splay","slug":"algorithm-splay","date":"2024-07-15T16:56:53.164Z","updated":"2024-07-17T22:46:53.678Z","comments":true,"path":"articles/63979/","link":"","permalink":"https://justpureh2o.cn/articles/63979/","excerpt":"","text":"上回书说到：平衡树。 伸展树简介An Indroduction to Splay 由 和 于 年提出的一种数据结构。后者证明了路径压缩的并查集的时间复杂度、求解 强连通分量的其中一种方法也以他的名字命名。 是一种二叉搜索树，与平衡树类似，它也可以通过“旋转”进行自我平衡。通过“伸展操作Splay”来将某个节点旋转至根节点来满足二叉搜索树的性质。能够在均摊 的时间复杂度内完成节点的查找、插入和删除操作，并且在极端数据面前也可以保持自身平衡，不至于退化成 的链状结构（又是薄纱朴素 的一天）。 伸展树的基本操作Basic Operations of Splay 结构定义Splay Structure 与前两个数据结构都不同的是， 多维护了一项“父节点”的信息。因为在伸展树操作过程中，会涉及到将节点向树根转动的操作，这时记录一个父节点就显得非常有必要且方便的了。其余内容和普通的平衡树就相差无几了： 1234567struct Splay { int s[2]; // 0 for left son, 1 for right son int p; // Father node index int dat; // Value int cnt; // Duplication count int size; // Node count in total} tree[N]; 再谈旋转Zigzagging Pt.II 在平衡树 2.3节中，我们探讨了平衡树中左旋右旋的基本规则，并给出了三种简记技巧。在 中，我们需要对平衡树的旋转操作进行一个更加深入的探讨。 可以发现，左旋和右旋是互为相反操作的。事实上，我们可以把整个旋转操作写成一个函数，通过传参来执行不同类型的旋转。我们只需要指定旋转的节点，至于旋转的取向则由程序自行决定（正确性是有保障的）。我们可以先分别写出左旋和右旋的函数，然后再把它们组合起来，最后别忘了更新父节点、以及上传子树大小（注意代码顺序）： 12345678910111213void rotate(int x) { int y = tree[x].p, z = tree[y].p; // Father and grandfather int sn_pos = (tree[y].s[1] == x); // Where the son is, 0 left, 1 right int fa_pos = (tree[z].s[1] == y); // Where the father is, 0 left, 1 right tree[z].s[fa_pos] = x; // Son and father need a swap. If father was on the left previously, the son will be placed as a father on the left tree[x].p = z; // Update father 1 tree[y].s[sn_pos] = tree[x].s[sn_pos ^ 1]; // In the mid-traversal order, node B is between X and Y, so it will be linked to the opposite side tree[tree[x].s[sn_pos ^ 1]].p = y; // Update father 2 tree[x].s[sn_pos ^ 1] = y; // After a round of zigzagging, left branch that connects father and son will be switched to the right side tree[y].p = x; // Update father 3 update(y); update(x);} 树的伸展To Splay in Splay 伸展树的灵魂与核心就在于它可以将任意节点转动到其他节点下面去，这一操作就叫做“伸展Splay”。在 中，每次对节点进行一次操作，就需要把它转动到根节点下面去。虽然听起来很玄学，这一操作的初衷是对可能接连而来的针对于该节点的访问进行快捷响应。好比你正在刷视频，你突然看了一个平常不常看的类型的视频，对于大数据来说，你的某次访问就预示着你接下来也可能会“沉迷”于此类视频，因而把这类视频的优先级提高，并作出快速响应。在存储了巨量数据的数据库里，把某类键值的优先级提高是常见加快查询速度的方式之一。 对于三个节点 ，我们在操作时一般会遇见如下的几种排布方式： 线形，即三个点都伸向相同方向 折线形，伸展方向不相同 对于第一种情况， 给出的策略是先转 后转 ；第二种情况则转两次 。这样的旋转方式经过证明可以让整个算法的时间复杂度均摊在 左右。 我们定义 为：将节点 旋转成 的一个子节点，特殊地，如果 ，就代表将 转到根节点下。那么当 的子节点不是 时，就不断旋转直到符合要求，期间判断三点形态（线形、折线形），然后采取对应的旋转策略即可。 1234567891011121314void splay(int x, int k) { while (tree[x].p != k) { int y = tree[x].p, z = tree[y].p; // Father and grandfather int sn_pos = (tree[y].s[1] == x); // Son direction int fa_pos = (tree[z].s[1] == y); // Father direction if (z != k) { // More than one rotation to go if (sn_pos == fa_pos) rotate(y); // Linear else rotate(x); // Broken-linear } rotate(x); // Anyhow X needs a rotation } if (!k) root = x; // Upgrade as the new root} 前驱&amp;后继Precursor &amp; Successor 为了找前驱/后继，我们就先需要找到带有给定权值的点。将这个点提到根上，方便我们的求解。基本思路和 一样，都是一头走到黑地向子树里面找。 123456789101112131415161718192021222324252627void findAndRaise(int idx, int dat) { splay(idx); if (tree[idx].dat &gt; dat) findAndRaise(tree[idx].s[0], dat); else if (tree[idx].dat &lt; dat) findAndRaise(tree[idx].s[1], dat);}int precursor(int dat) { findAndRaise(root, dat); int tmp = root; if (tree[tmp].s[0]) { tmp = tree[tmp].s[0]; while (tree[tmp].s[1]) tmp = tree[tmp].s[1]; return tmp; } return tmp;}int successor(int dat) { findAndRaise(root, dat); int tmp = root; if (tree[tmp].s[1]) { tmp = tree[tmp].s[1]; while (tree[tmp].s[0]) tmp = tree[tmp].s[0]; return tmp; } return tmp;} 插入操作Insertion 单点插入Node Insertion 为了维护节点的父节点信息，这次的插入操作和以往都不太一样。使用类似于深搜的遍历方式一路向下更新，我们的 allocate 函数也加入了父节点的初始化： 1234567891011121314151617181920212223242526272829int allocate(int dat, int p) { idx++; tree[idx].dat = dat; tree[idx].p = p; tree[idx].cnt = 1; tree[idx].size = 1; return idx;}void insert(int dat) { int u = root, p = 0; while (u) { p = u; if (tree[p].dat &gt; dat) u = tree[u].s[0]; else if (tree[p].dat &lt; dat) u = tree[u].s[1]; else { tree[u].cnt++; splay(p); return; } } u = allocate(dat, p); if (p) { // Not first run if (tree[p].dat &gt; dat) tree[p].s[0] = u; else tree[p].s[1] = u; } splay(u);} 区间插入Sequence Insertion 假如我们要把一段序列插入到节点 的后侧，映射到整棵树的中序遍历就是在 后接上这段序列。因为 整棵树维护的就是原始序列，换句话说，中序遍历就是原序列。那么我们只需要找到 的后继 ，它在中序遍历里就是 的后一个节点，原序列中也是如此。那我们只需要把区间插入到 的左子树（对应中序遍历就是 和 之间的空隙）即可。 12345678910void insertInterval(int pos, int tot) { int l = getIdxByRank(root, pos + 1); int r = getIdxByRank(root, pos + 2); splay(l); splay(r, l); int rt = build(0, tot - 1, r); tree[r].s[0] = rt; update(r); update(l);} 删除操作Deletion 单点删除Node Deletion 基本思路和平衡树一样，依然是把要删除的节点转到叶子上去。只不过在 中，我们有一个利器—— 函数。从而，我们可以把要删除节点的前驱和后继求出来，然后把前驱转到根节点上，再把后继转到前驱下边。这样一来，前驱的右子树是后继，后继的左子树就是待删除节点。根据 中序遍历的不变性，此时待删除节点成为了一个叶子节点，直接删除（置零）即可。 1234567891011void removeNode(int idx, int dat) { int pre = precursor(dat); int suc = successor(dat); splay(pre); splay(suc, pre); int tar = tree[suc].s[0]; if (tree[tar].cnt &gt; 1) { tree[tar].cnt--; splay(tar); } else tree[suc].s[0] = 0;} 区间删除Sequence Deletion 单点删除是区间删除的一个特殊版本（）。我们找到区间左端点 的前驱 ，以及右端点 的后继 。旋转前驱到根，再旋转后继到前驱下边。与单点删除相同，这个区间对应的树就是后继的左子树。直接删除即可。 12345678910void removeInterval(int pos, int tot) { int l = getIdxByRank(root, pos); int r = getIdxByRank(root, pos + tot + 1); splay(l); splay(r, l); gc(tree[r].s[0]); tree[r].s[0] = 0; update(r); update(l);} 有关排名查询和数值查询的内容与平衡树相同，故直接给出。注意 操作不要写到开头去了。 123456789101112int getRankByData(int idx, int dat) { if (!idx) return 1; if (tree[idx].dat &gt; dat) return getRankByData(tree[idx].s[0], dat) + 1; return getRankByData(tree[idx].s[1], dat) + (tree[idx].s[0] ? leftSubtree(idx).size : 0) + tree[idx].cnt;}int getDataByRank(int idx, int rank) { if (!idx) return -INF; if (leftSubtree(idx).size &gt;= rank) return getDataByRank(tree[idx].s[0], rank); if (leftSubtree(idx).size + tree[idx].cnt &gt;= rank) return tree[idx].dat; return getDataByRank(tree[idx].s[1], rank - (tree[idx].s[0] ? leftSubtree(idx).size : 0) - tree[idx].cnt);} 伸展树的高级操作Gorgeous Operations of Splay 我们虽然将 归入平衡树之中（平衡树又归于 之内），但是在一般情况下，伸展树是不满足二叉搜索树性质的。具体表现在进行过多次旋转之后。但是，在不停的变换之中，有一样东西是从始至终一直不变的——中序遍历。伸展树的中序遍历就是原序列，根据这个性质，人们提出了不同花样的伸展树玩法…… 区间翻转Sequence Flipping 在开始之前，我们首先要明白区间翻转在 里的呈现是怎样的。显然，翻转前后，伸展树的中序遍历是相反的，那就可以画出如下对比图： 可以发现，这个序列翻转了，在图中的表现就是交换树的左右儿子。我们类比线段树，可以引入一个懒标记来记录区间翻转操作。当然这里的标记打法和线段树略有不同： 给 打标记的时候 这个点的左右儿子还没换，这与线段树的 lazytag 不同。线段树在 上打标记，表示 已经修改过了，将要修改儿子的贡献。 ——樱雪喵 《Splay 详细图解 &amp; 轻量级代码实现》 那如何找到区间 所在子树呢？其实你已经学过了，就在前边的区间删除中，分别找到左右端点的前驱和后继，然后旋转到一起，后继的左子树就是 。为了防止找不到前驱和后继，我们在整个序列的一头一尾分别插入两个点，以防访问出错，我们的边界节点恰好就能做到这一点！ 如果要进行如上的翻转操作，整个代码中就要加入下传标记的操作。在所有有关查找的地方加入标记下传即可。 12345678void pushdown(int idx) { if (tree[idx].tag) { swap(tree[idx].s[0], tree[idx].s[1]); leftSubtree(idx).tag ^= 1; rightSubtree(idx).tag ^= 1; tree[idx].tag = 0; }} 在查询排名和数值的时候下传标记即可。 启发式合并Heuristic Merging 的合并就是单纯的将其中一棵树的每个点插入另一棵树中，但是这样可能会出现效率问题。当你把一个拥有很多节点的树合并到一棵非常小的树中时，由于插入操作的次数取决于插入子树的大小，显然会导致效率浪费。出于节省效率的目的，我们把大小更小的树合并到大小更大的树上去。 在这期间，我们就需要一个并查集来维护每个点所在的子树，把维护根节点的整型换成一个数组（毕竟有很多子树需要维护根节点的值）。在伸展操作（旋转到根节点）时更新根信息即可。 典例演练Pratical Examples 洛谷 P3391 [模板] 文艺平衡树 题目地址：P3391 题目难度：提高+/省选- 您需要写一种数据结构（可参考题目标题），来维护一个有序数列。 其中需要提供以下操作：翻转一个区间，例如原有序序列是 ，翻转区间是 的话，结果是 。 输入格式： 第一行两个正整数 ，表示序列长度与操作个数。序列中第 项初始为 。 接下来 行，每行两个正整数 ，表示翻转的区间。 输出格式： 输出一行 个正整数，表示原始序列经过 次变换后的结果。 数据范围： 对于 的数据，${1 n, m } ，{1 l r n}$。 这道题额外涉及到一个知识点，输出树的中序遍历。我们知道中序遍历是按照“左-根-右”的顺序递归输出的，我们只需要判断是否存在左右子树，然后递归输出即可，注意特判首位的边界节点。 代码在云剪切板。 洛谷 P3224 [HNOI2012] 永无乡 题目地址：P3224 题目难度：省选/NOI- 题目来源：湖南 2012 各省省选 永无乡包含 座岛，编号从 到 ，每座岛都有自己的独一无二的重要度，按照重要度可以将这 座岛排名，名次用 到 来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛到达另一个岛。如果从岛 出发经过若干座（含 座）桥可以 到达岛 ，则称岛 和岛 是连通的。 现在有两种操作： B x y 表示在岛 与岛 之间修建一座新桥。 Q x k 表示询问当前与岛 连通的所有岛中第 重要的是哪座岛，即所有与岛 连通的岛中重要度排名第 小的岛是哪座，请你输出那个岛的编号。 输入格式： 第一行是用空格隔开的两个整数，分别表示岛的个数 以及一开始存在的桥数 。 第二行有 个整数，第 个整数表示编号为 的岛屿的排名 。 接下来 行，每行两个整数 ，表示一开始存在一座连接编号为 的岛屿和编号为 的岛屿的桥。 接下来一行有一个整数，表示操作个数 。 接下来 行，每行描述一个操作。每行首先有一个字符 ，表示操作类型，然后有两个整数 。 若 为 Q，则表示询问所有与岛 连通的岛中重要度排名第 小的岛是哪座，请你输出那个岛的编号。 若 为 B，则表示在岛 与岛 之间修建一座新桥。 输出格式： 对于每个询问操作都要依次输出一行一个整数，表示所询问岛屿的编号。如果该岛屿不存在，则输出 。 数据范围： 对于 的数据，保证 , 。 对于 的数据，保证 , ， 为一个 的排列，，。 这道题就要运用到我们上边所讲的启发式合并。重定义我们的 为把节点 旋转到编号 的树的 号点下（默认 即旋转到根）；以及插入函数 为把权值和原编号（合并操作会增加新点，为了保证下标稳定故初始化时记录）分别为 的点插入到 号树下。那么每一次合并，我们只需要判断合并的两点是否已经在同一棵树下、两棵树哪一棵的大小更大（启发式），然后用一个深搜遍历小树，把小树里的点递归插入（复制）到大树里面即可。注意操作时用 root 数组包裹的地方，理解为重。 代码在云剪切板中。 洛谷 P2042 [NOI2005] 维护数列 题目地址：P2042 题目难度：省选/NOI 题目来源：NOI 2005 请写一个程序，要求维护一个数列，支持以下 种操作： 编号 名称 格式 说明 1 插入 在当前数列的第 个数字后插入 个数字：；若在数列首插入，则 为 2 删除 从当前数列的第 个数字开始连续删除 个数字 3 修改 从当前数列的第 个数字开始的连续 个数字统一修改为 4 翻转 取出从当前数列的第 个数字开始的 个数字，翻转后放入原来的位置 5 求和 计算从当前数列的第 个数字开始的 个数字的和并输出 6 求最大子列和 求出当前数列中和最大的一段子列，并输出最大和 输入格式： 第一行包含两个整数 和 ， 表示初始时数列中数的个数， 表示要进行的操作数目。 第二行包含 个数字，描述初始时的数列。以下 行，每行一条命令，格式参见问题描述中的表格。 输出格式： 对于输入数据中的 和 操作，向输出文件依次打印结果，每个答案（数字）占一行。 数据范围： 你可以认为在任何时刻，数列中至少有 个数。 输入数据一定是正确的，即指定位置的数在数列中一定存在。 对于 的数据，任何时刻数列中最多含有 个数。 对于 的数据，任何时刻数列中最多含有 个数，任何时刻数列中任何一个数字均在 内，，插入的数字总数不超过 。 题面由 @syksykCCC 提供。 这道题需要我们复习一下之前线段树的知识，这篇博客介绍了线段树求解区间最大子列的方法。 代码在云剪贴板。 后记&amp;鸣谢Epilogue &amp; Special Thanks 整整一天都花在调题对拍上了，做P2042的时候头发都掉了不少，不过总算是结束伸展树了。再加上你谷爆发了一次逆天的DDoS事件、还有那么多人在抢R166666666，我连题目都进不去，旁边的某位孩子评测了10分钟才出结果……真应了大佬一句话——“暑假的猴子最多”…… 参考资料： [1] Brailliant11001.高贵的伸展树——Splay [EB/OL]. https://www.luogu.com/article/2zmvdtov, 2024-2-20/2024-7-16 [2] 樱雪喵.Splay 详细图解 &amp; 轻量级代码实现 [EB/OL]. https://www.cnblogs.com/ying-xue/p/17122409.html, 2023-9-10/2024-7-16 [3] 小蒟蒻yyb.Splay入门解析【保证让你看不懂（滑稽）】 [EB/OL] https://www.cnblogs.com/cjyyb/p/7499020.html, 2017-9-9/2024-7-16 [4] Brailliant11001.从零开始掌握线段树大法 [EB/OL]. https://www.luogu.com/article/4qwcw951, 2023-12-30/2024-7-17","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"平衡树 Treap","slug":"algorithm-treap","date":"2024-07-14T01:31:36.575Z","updated":"2024-07-15T19:16:57.820Z","comments":true,"path":"articles/73902/","link":"","permalink":"https://justpureh2o.cn/articles/73902/","excerpt":"","text":"书接上回：二叉搜索树 BST。二叉搜索树是本文所讲平衡树的必要前置知识。 平衡树简介Brief Introduction of Treap 平衡树是为了解决普通二叉搜索树（）时间复杂度退化现象而产生的一种复杂度更为稳定的数据结构（但它仍然属于 的一个子类，因此具备 的所有性质）。在极端的数据面前（具备单调性的数据）， 会退化成为一个 的算法。但是通过引入随机化参数，在数学期望的控制下就可以整体上维持二叉树的平衡（左右子树的高度相差不大），从而让复杂度基本稳定在 左右，是极为优秀的算法。一般情况下，我们都会选用平衡树而不是普通的二叉搜索树。 在平衡树中，同时存在着二叉搜索树的性质和堆的性质（Treap = Tree + Heap）。为了让树更加平衡，我们引入一个随机化的值，用来满足平衡树的堆性质。通过引入这么一个随机变量，把原先可能完全有序的序列打乱，让它从期望上尽量接近一棵满二叉树，进而实现稳定时间复杂度的效果。 平衡树的代码实现Treap Instance 如何生成更好的随机数How to Random Better in CPP 大部分人比较清楚的是我们的牢朋友 srand() 和 rand()，调用前者以设置随机数引擎的随机种子，后者用于生成一个随机数。然而，如果你忘记先使用 srand() 设置种子，程序会每一次默认一个固定的种子来生成随机数，这样一来生成出来的随机数就不“随机”了——它们会变成固定的一串序列。不过你也可以凭经验，记住某个种子来达到理想的效果…… 那么如何生成更“随机”的随机数呢？标准库里内置了 random_device随机设备，向系统索取一个随机数；C++同时也内置了一个整数随机数生成算法 mt19937（以及它的64位长整型版本 mt19937_64，仍然需要人工设置种子），它的全称是梅森旋转算法Mersenne Twister，用它们生成随机数的代码如下： 123456// Random devicerandom_device rd;unsigned r1 = rd();// Mersenne Twistermt19937 mt(seed);unsigned r2 = mt(); 使用无符号整型是为了防止溢出问题。 据说是无符号整型的溢出问题导致《文明6》中的“非暴力不合作运动发起人”甘地通常是第一个向整个世界扔核弹的领导人。 基本创建Deployment Methods 本质上仍然属于 ，基本的结构定义保持不变。平衡树里引入了一个新的随机化变量来让整棵树保持平衡： 1234567891011struct Treap {// Some macro definitions#define leftSubtree(idx) (tree[tree[idx].ls])#define rightSubtree(idx) (tree[tree[idx].rs])#define NEGAINF_NODE 2#define POSIINF_NODE 1 int ls, rs; // Left and right son int dat, rnd; // Real value and randomized data for zigzags int cnt; // Duplication count int size; // How many nodes are there inside its subtree} tree[N]; 全局变量和二叉搜索树基本相同，不同的是引入了一个随机设备 random_device 用来生成随机数。 12int idx = 0, root;random_device rd; 单点创建、建树的思路和二叉搜索树一模一样，只是在创建新点是要赋一个额外的随机化参数。 1234567891011121314int allocate(int dat, bool on_init = false) { idx++; tree[idx].dat = dat; tree[idx].rnd = rd(); // Randomized param tree[idx].cnt = (on_init) ? 0 : 1; tree[idx].size = 1;}void build() { allocate(INF, true); allocate(-INF, true); tree[1].ls = 2; root = 1;} 节点旋转Node Zigzaging 节点的左旋Zag和右旋Zig可谓是平衡树的看门好戏了葡萄糖：我也是，这两者都是用来维持平衡树平衡性的利器。接下来介绍两种节点旋转的法则： 左旋Zag/Left Rotate 看下图（图源 OI Wiki - 二叉搜索树 &amp; 平衡树），节点 经历了一轮左旋操作： 从图中我们可以直观地总结出左旋的规则：节点的右孩子向左上旋转成为原节点的父节点，原节点向左下旋转成为一个左孩子，让原先右孩子的左孩子变成原节点的右孩子。在本例中：节点 向左下旋转变成左孩子， 向左上旋转变成父节点， 的右孩子 成为 的右孩子。 右旋Zig/Right Rotate 看下图（图源 OI Wiki - 二叉搜索树 &amp; 平衡树），节点 经历了一轮右旋操作： 我们也可以总结出右旋的规则：节点的左孩子向右上方旋转变成父节点，原节点向右下转变为一个右孩子，让原先左孩子的右孩子变成原节点的左孩子。本例中：节点 向右下旋转变成右孩子， 向右上转变成父节点， 的右孩子 变成 的左孩子。 简记技巧Jingling 从实质角度来讲： 左旋拎右左挂右，右旋拎左右挂左。 —— 如果还不能理解比如我，可以看下面这个基于代码的顺口溜： 《右旋——输钱》 钱赔了Q P Lq = tree[p].ls 赔了前任P L Q Rtree[p].ls = tree[q].rs 穷人贫Q R Ptree[q].rs = p 贫穷P Qp = q 《左旋——还钱》 强迫人Q P Rq = tree[p].rs 派人抢了P R Q Ltree[p].rs = tree[q].ls 钱来赔Q L Ptree[q].ls = p 赔钱P Qp = q 事实上可以只背一段，对应的另一种旋转的代码就是在保持左右节点不变的情况下（不更改 ls 和 rs 的位置），把访问下标的 p 和 q 对调即可。当然 p = q 这一句是通用的、q 的定义也要稍作变通。 或者你还可以从中序遍历的角度来记忆，我们知道左旋和右旋不改变原树的中序遍历。而对于形如下图的二叉搜索树： 我们可以通过把树压成一条线来获取它的中序遍历序列（如图），因为旋转后父子节点会交换，因此把中序链条拉起来之后要保证原来的子节点（蓝色圆形）要在上边。可以对照例图自行模拟该过程加深记忆。 123456789101112131415161718192021222324void update(int idx) { tree[idx].size = (tree[idx].ls ? leftSubtree(idx).size : 0) + (tree[idx].rs ? rightSubtree(idx) : 0) + tree[idx].cnt;}void zig(int &amp;p) { // Reference used // Right rotate int q = tree[p].ls; tree[p].ls = tree[q].rs; tree[q].rs = p; p = q; // Switch nodes update(tree[q].rs); update(q);}void zag(int &amp;p) { // Left rotate int q = tree[p].rs; tree[p].rs = tree[q].ls; tree[q].ls = p; p = q; update(tree[q].ls); update(q);} 数据插入Data Insertion 基本思路与 相同，唯一不同的是我们需要在创建点的同时维护平衡树的堆性质。在旋转之后，可能变化的值有子树的大小，因此在每次旋转操作后要及时更新。 在这里，我着重实现小根堆平衡树，这意味着层数越小的节点所携带的随机数更小。如果当前插入一个值，需要被插入到左子树中，但是新节点的随机数更小一些，我们就需要把它提到上边去，对应起来就是右旋上去；反之就是左旋。简称：“左大右旋，右大左旋”。因为每次操作后都要更新根节点的数据，因此这里使用 else if。 123456789101112void insert(int &amp;idx, int dat) { if (!idx) idx = allocate(dat); else if (tree[idx].dat == dat) tree[idx].cnt++; else if (tree[idx].dat &gt; dat) { insert(tree[idx].ls, dat); if (leftSubtree(idx).rnd &gt; tree[idx].rnd) zig(idx); } else { insert(tree[idx].rs, dat); if (rightSubtree(idx).rnd &gt; tree[idx].rnd) zag(idx); } update(idx);} 节点删除Node Deletion 基本思路是把一个节点不断旋转成一个叶子节点，然后直接删去。有如下几种情况： 如果待删去点的重复次数大于 ，那么减去一。 如果不存在右子树，让左子树替代它，直接把它删除。 如果不存在左子树，让右子树替代它，直接把它删除。 如果出现“左大右小”，则右旋。 如果出现“左小右大”，则左旋。 如果不在以上所有情况中，代表已经到达叶子节点，直接删除。 可以发现前三点与一般的 是一模一样的，后三点就是平衡树的独特之处。 123456789101112131415161718192021void remove(int &amp;idx, int dat) { if (!idx) return; if (tree[idx].dat == dat) { if (tree[idx].cnt &gt; 1) tree[idx].cnt--; // CASE 1 else { if (!tree[idx].ls) idx = tree[idx].rs; // CASE 2 else if (!tree[idx].rs) idx = tree[idx].ls; // CASE 3 else if (tree[idx].ls &amp;&amp; tree[idx].rs) { if (leftSubtree(idx).dat &gt; rightSubtree(idx).dat) { // CASE 4 zig(idx); remove(tree[idx].rs, dat); } else if (rightSubtree(idx).rnd &gt; leftSubtree(idx).rnd) {// CASE 5 zag(idx); remove(tree[idx].ls, dat); } } else idx = 0; // CASE 6 } } if (tree[idx].dat &gt; dat) remove(tree[idx].ls, dat); else remove(tree[idx].rs, dat);} 前驱 &amp; 后继Precursor &amp; Successor 在模板题里，题面没有保证所查询前驱的点一定存在于树之中。原先基于查询目标点，再不断深入子树的方法就不再适用。这里介绍一种新的基于递归全树的方法。 以求前驱为例，需要满足以下几点要求： 如果下标无意义，返回负无穷 如果当前根节点大于等于所给值，证明目标点和它的前驱在左子树中，递归查找 否则，当前点就已经满足小于目标点的性质，作为前驱的潜力候选者，与在右子树查找的结果取最大值 这些要求都很简单明了，不再过多解释。 1234567891011int precursor(int idx, int dat) { if (!idx) return -INT_MAX; if (tree[idx].dat &gt;= dat) return precursor(tree[idx].ls, dat); return max(tree[idx].dat, precursor(tree[idx].rs, dat));}int successor(int idx, int dat) { if (!idx) return INT_MAX; if (tree[idx].dat &lt;= dat) return successor(tree[idx].rs, dat); return min(tree[idx].dat, successor(tree[idx].ls, dat));} 有关排名查询、数值查询的求解代码均与 模板相同，此处不再浪费篇幅。 典例演练Pratical Examples 洛谷 P3369 [模板] 普通平衡树 题目地址：P3369 题目难度：提高+/省选- 您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 插入一个数 。 删除一个数 （若有多个相同的数，应只删除一个）。 定义排名为比当前数小的数的个数 。查询 的排名。 查询数据结构中排名为 的数。 求 的前驱（前驱定义为小于 ，且最大的数）。 求 的后继（后继定义为大于 ，且最小的数）。 对于操作 3,5,6，不保证当前数据结构中存在数 。 输入格式： 第一行为 ，表示操作的个数,下面 行每行有两个数 和 ， 表示操作的序号（） 输出格式： 对于操作 每行输出一个数，表示对应答案。 数据范围： 对于 的数据，， 来源：Tyvj1728 原名：普通平衡树 在此鸣谢 同样是模板题，为了节省篇幅，代码在我的云剪切板。 你怎么知道我调了一整天才调出来的 后记 &amp; 鸣谢Epilogue &amp; Special Thanks 和我开始打 是一样的，各种奇奇妙妙的错误那是接二连三……最后发现是自己被 OI Wiki 上的一段“不合情势的代码”给误导了。或许那段代码在编写者那里就可以轻松通过，但是在我这就不一定行，显然是普通二叉树的数据太水，错误代码也可以通过。 在这里仍然需要致谢： 耗费一下午对拍造数据的—— DWHJHY 参考资料： [1] DWHJHY.树堆-TREAP [EB/OL] .https://www.luogu.com/article/ugcagegy, 2024-4-17/2024-7-15 [2] Brailliant11001.入门平衡树——Treap [EB/OL] .https://www.luogu.com/article/tyvidvb6, 2024-2-1/2024-7-15","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二叉搜索树 BST","slug":"algorithm-bst","date":"2024-07-14T01:12:05.236Z","updated":"2024-08-23T22:51:33.373Z","comments":true,"path":"articles/61585/","link":"","permalink":"https://justpureh2o.cn/articles/61585/","excerpt":"","text":"二叉搜索树简介A Brief Introduction 二叉搜索树Binary Search Tree是一种特殊的二叉树，它有如下的性质： 左儿子（如果存在）的节点值比当前节点的值要小 右儿子（如果存在）的节点值比当前节点的值更大 某个节点的左/右子树（如果存在）也为一个二叉搜索树 中序遍历得到的节点值序列是不下降的（属于是推论） 二叉搜索树是很多重要树形数据结构的理论基础，例如树堆Treap、红-黑树Red-Black Tree、伸展树Splay等等。 二叉搜索树的实现In-Code Practice 对于一个树形数据结构，我们首先需要明确它的建树操作，这相当于一栋大楼的基石；其次考虑它的节点操作，即单个点的增加、删除、求值等，相当于盖楼的承重柱，有骨梁的作用；最后是它的应用范围，好比给大楼装上玻璃。我们接下来从以上三个方面实现一个普通的二叉搜索树—— 宏定义目录Macro Index 把可能会用到的宏定义函数放在开头： 宏名称 定义 作用 leftSubtree(idx) tree[tree[idx].ls] 获取当前节点的左子树对象 rightSubtree(idx) tree[tree[idx].rs] 类似上边，获取右子树对象 NEGAINF_NODE 2 记录负无穷边界节点的下标 POSIINF_NODE 1 记录正无穷边界节点的下标 基本结构Basic Structure Definition 我们知道二叉树是可能会有左右子节点的，因此需要设计两个变量存储左右子节点 的下标；点的权值也是我们需要关心的；为了应对可能出现的权值重复，我们可以考虑加入一个权值计数，让相同权值的点不会被加入两次；最后为了应对一些题目的要求，维护一个记录子树总点数的变量。结构体看起来大概是这样的： 123456789101112struct BST {// Some macro definitions, see the table above#define leftSubtree(idx) (tree[tree[idx].ls])#define rightSubtree(idx) (tree[tree[idx].rs])#define NEGAINF_NODE 2#define POSIINF_NODE 1 int ls, rs; // Index for left/right sons int dat; // Data carried by the node or simply a node value int cnt; // Count in case there's a duplicated value int size; // Total child nodes} tree[N];int root; // Record the root node index, normally it's 1 建树&amp;单点创建Build &amp; Node Allocating 写 有一个不成文的规矩：在建树时加入两个边界节点正无穷和负无穷，其中一个作为树的根节点，选哪个都可以。我选择将正无穷作为根节点，根据定义，负无穷节点应是它的左儿子。特别地，我们称只包含正/负无穷节点的 为空。因此建树只需创建两个无穷节点即可，注意对于初始建立的无穷权节点，实际上是不会包含在 中的，因此设立一个特判，将它们的重复计数设为 ，否则在计算排名时会出错。 接下来就是单点的创建了。在 中，我们使用类似于链式前向星的方法创建某个点。关键代码如下： 12345678910111213141516int idx = 0, root;int allocate(int dat, bool on_init = false) { idx++; tree[idx].dat = dat; tree[idx].cnt = (on_init) ? 0 : 1; // Process duplication count with special judge tree[idx].size = 1; // Add to subnode count return idx;}void build() { allocate(INF); allocate(-INF); root = 1; // Take the first node as root. It's positive infinity tree[1].ls = 2; // According to the passage, negative infinity should be the left son} 为 allocate() 函数设返回值大概是它与链式前向星最大的区别点了，后文会讲到设返回值的妙用。 单点查询Index Query 根据开头介绍的 的性质，写这个就非常简单了。主要分以下几个情况考虑（假设目标值为 ，当前值为 ，不保证是否存在该权值）： 若 ，即查询到目标节点，返回下标 若 ，向左子树递归搜索 若 ，向右子树递归搜索 若下标无意义，返回不存在（表现在下标为 ） 123456int query(int idx, int dat) { if (!idx) return 0; // Nonsense index indicates failure if (dat == tree[idx].dat) return idx; // Found! if (dat &gt; tree[idx].dat) return query(tree[idx].rs, dat); // Target is greater than current, recurse to right son return query(tree[idx].ls, dat); // Recurse to left son} 插入数值Value Insertion 注意：这和前文所述的单点创建并不等价。在这一操作中，我们需要关注已有的其他点的权值情况。在 中，是不能出现两个不同的点（下标不同）共享同一份权值的。虽然很多题目会明确指出“本题数据保证不存在权值相同的两个点”，但有时也会出现例外。对于这类例外的题目，前面设立的变量就有用武之地了！ 理论上我们可以通过调用 query() 函数来快捷得知该权值的存在性，但是实践时一般不采用这种做法。考虑到先前所讲的几大函数都没有对节点之间的从属关系进行更新，又因为插入操作会涉及到节点之间的关系转换，故将更新左右儿子的操作放在此处。 首先还是需要获取该权值理应存放的位置，求解策略跟单点查询相同。只是我们将递归参数“下标”设为引用形式，这样在一层层向上返回时就可以顺便更新父节点的左右儿子下标了。此时单点创建函数的返回值将作为新建点的序号向上传递，一路更新至根节点。 12345678910111213void insert(int &amp;idx, int dat) { if (!idx) { idx = allocate(dat); // Does not exist, then allocate a new node return; } if (tree[idx].dat == dat) { tree[idx].cnt++; // Encounter a duplicated node, add to its count return; } if (tree[idx].dat &lt; dat) insert(tree[idx].rs, dat); if (tree[idx].dat &gt; dat) insert(tree[idx].ls, dat); tree[idx].size = (tree[idx].ls ? leftSubtree(idx).size : 0) + (tree[idx].rs ? rightSubtree(idx).size : 0) + tree[idx].cnt; // Recursivly update the tree size} 前驱&amp;后继Precursor &amp; Successor Node 前驱Precursor Node：在所有权值小于当前点权的点之中，权值最大的那一个。 后继Successor Node：在所有权值大于当前点权的点之中，权值最小的那一个。 以求前驱为例（如果权值是给定值的点不存在，我们默认它的前驱是负无穷）：首先我们需要从根节点开始，向下找到给定权值应该存放的位置。如果找到权值是给定值的点，要保证答案点的权值小于基准点，我们就要先向左子树走（树内权值均小于父节点），接着一直沿右子树（树内权值均大于父节点）走到底即可找到前驱。求后继类似，只是需要先找到基准点的右子树，然后一直沿左子树走到底。 因为查询排名和查询数值都有一步查找对应点的步骤，与查找前驱后继的过程相同，故而可以把二者合一以简化代码（见后文）。 12345678910111213141516171819202122232425262728293031int precursor(int idx, int dat) { int res = NEGAINF_NODE; // Negative infinity while (idx) { if (tree[idx].dat == dat) { if (tree[idx].ls) { // Ensure that its left subtree exists res = tree[idx].ls; while (tree[idx].rs) res = tree[res].rs; } break; } if (tree[idx].dat &lt; dat &amp;&amp; tree[res].dat &lt; tree[idx].dat) res = idx; idx = (dat &gt; tree[idx].dat) ? tree[idx].rs : tree[idx].ls; } return res;}int successor(int idx, int dat) { int res = POSIINF_NODE; // Positive infinity while (idx) { if (tree[idx].dat == dat) { if (tree[idx].rs) { res = tree[idx].rs; while (tree[idx].ls) res = tree[idx].ls; } break; } if (tree[idx].dat &gt; dat &amp;&amp; tree[res].dat &gt; tree[idx].dat) res = idx; idx = (dat &gt; tree[idx].dat) ? tree[idx].rs : tree[idx].ls; } return res;} 单点删除Node Deletion 在一棵合法的 中，任意节点的子树也都是一棵合法的 ，这启示我们不能鲁莽、暴力地删点，而是要好好理清楚节点之间的关系之后，进行一系列操作，最后删除掉这个节点。 对于某个节点，它可能有如下几种情况： 它是一个叶子节点，可以直接删除。 它在一条链上（只有一个子节点）：删除这个点，同时让它的子节点代替它。 它是一个二叉节点（两个子节点）：考虑提出一种方式把问题简化为以上两种特殊情况。首先找到前驱或者后继，因为前驱和后继均只有一个方向上的子树，简化成第二种情况。我们可以让前驱/后继替换要删除的节点，紧接着把替换过去的原节点删除即可！就好像剪贴覆盖的过程。 如果这个点的重复数量大于一，则减去一个重复数。 12345678910111213141516171819void remove(int &amp;idx, int dat) { if (!idx) return; // Does not exist if (tree[idx].dat == dat) { if (tree[idx].cnt &gt; 1) tree[idx].cnt--; // Dupliacted, then minus one to its count else { if (!tree[idx].ls) idx = tree[idx].rs; // No left subtree, replace it with its left subtree else if (!tree[idx].rs) idx = tree[idx].ls; // Vice versa else { int pre = precursor(idx, dat); // Find the precursor remove(pre, tree[pre].dat); // Remove precursor tree[pre] = tree[idx]; // Replace idx = pre; } return; } } if (tree[idx].dat &gt; dat) remove(tree[idx].ls, dat); else remove(tree[idx].rs, dat);} 排名查询Rank Query 所谓排名，就是看有多少元素比你当前的元素大/小，所得数目加一的结果。 天生的有序性可以帮助我们高效地解决这一点。与数值查询不同，排名查询时给出的权值可能并不存在于任何点之中。我们的基本求解策略如下： 如果需要向右子树扩展查找，则累加左子树大小和当前根节点的重复次数。 如果当前根节点的权值等于给定权值，则累加左子树大小，并额外加一。 如果需要向左子树扩展，递归返回向左子树查找的结果。 第一点很好理解：对于根节点，它的左子树所有点权都比根节点的小。此时我们需要查询的点权显然是大于当前根节点的（位于右子树），因而左子树、包括当前根节点在内的所有点都会排在目标点之前，需要累加起来。 第二点告诉我们这样一条消息：当前根节点就是目标节点，所以左子树的所有节点都排在它之前，需要累加。这个情况可以看作第一点的特殊形式，必须注意的是，这里无需再累加当前根节点的重复次数。 对于第三点：因为我们不确定左子树的情况（有大有小），因此无需多虑直接递归进去就好。 123456int getRankByData(int idx, int dat) { if (!idx) return 1; if (tree[idx].dat == dat) return (tree[idx].ls ? leftSubtree(idx).size : 0) + 1; if (tree[idx].dat &lt; dat) return (tree[idx].ls ? leftSubtree(idx).size : 0) + getRankByData(tree[idx].rs, dat); return (tree[idx].ls ? leftSubtree(idx).size : 0) + getRankByData(tree[idx].rs, dat);} 数值查询Data Query 题目会给定一个排名，让你获取对应排名的节点权值。与上边排名查询不同的是，这里给出的排名必须有一个对应的点，因为排名是离散的、权值不离散，所以这里需要判断无解的情况。基本分五类讨论： 如果左子树的大小（节点的重复数也计入）大于等于所查询的排名参数 ，向左子树递归。 如果左子树的大小在如下范围内（当前根节点重复数为 ）：，返回当前根节点的权值。 不在以上三类情况中，向右子树递归，参数减去左子树的大小以及当前根节点的重复数。 当前下标无意义，判无解并返回。 首先，左子树是一定小于当前根节点的。如果左子树的大小都超过了排名参数，就代表目标点在左子树内，继续向左子树递归找排名为 的点即可。 对于第二点，当前根节点的重复数为 ，那么对于根节点这个大集合（相同权值记作不同排名），排名的范围就是 。因此一旦满足该关系直接返回。 最后是第三点，因为左子树的大小与根节点重复数的和小于当前排名，代表我们要找的点在右子树。在右子树中它的排名又是多少呢？显然，因为左子树和根节点占去了一部分排名，在右子树中，它的排名就需要减去这二者的和。 第四点属于无解判断，不再赘述。 123456int getDataByRank(int idx, int rank) { if (!idx) return -1; if (leftSubtree(idx).size &gt;= rank) return getDataByRank(tree[idx].ls, rank); if (leftSubtree(idx).size + tree[idx].cnt &gt;= rank) return tree[idx].dat; return getDataByRank(tree[idx].rs, rank - (tree[idx].ls ? leftSubtree(idx).size : 0) - tree[idx].cnt);} 典例演练Pratical Examples 洛谷 P5076 [深基16.例7] 普通二叉树（简化版） 题目地址：P5076 题目难度：普及+/提高 您需要写一种数据结构，来维护一些数（都是绝对值 以内的数）的集合，最开始时集合是空的。其中需要提供以下操作，操作次数 不超过 ： 定义数 的排名为集合中小于 的数的个数 。查询数 的排名。注意 不一定在集合里。 查询排名为 的数。保证集合里至少有 个数。 求 的前驱（前驱定义为小于 ，且最大的数）。若不存在则输出 。 求 的后继（后继定义为大于 ，且最小的数）。若不存在则输出 。 插入一个数 ，本题的数据保证插入前 不在集合中。 保证执行 操作时，集合中有至少一个元素。 输入格式： 第一行是一个整数 ，表示操作次数。 接下来 行，每行两个整数 ，分别表示操作序号以及操作的参数 。 输出格式： 输出有若干行。对于操作 ，输出一个整数，表示该操作的结果。 这是一道模板题，套用上边的模板即可（甚至不涉及节点删除）。为了压缩篇幅，代码放在此处。 你怎么知道我花了三节晚自习+一个上午过样例、大半个下午调代码？（因为查询数值时没判断是否是边界节点） 常见问题Q &amp; A Q：为什么初始的两个边界节点需要设置它们的重复计数为 ？ 从实际意义上说，这两个点其实并不参与我们的一系列树上操作。它们只是起到一个防止溢出的作用——好比人体的阑尾，对消化吸收并没有什么帮助，但是它就是长在那个地方就是用来发炎的，你也不好说什么（doge）。 Q： 的时间复杂度？为什么我用 会超时？ 的时间复杂度最好情况下是 ；最坏可能退化成 。 由于 的形态与节点的插入顺序相关，如果插入的数据高度有序，最坏情况下整棵树是一条链状结构，会退化成 的复杂度（相当于开一维数组跑暴力）。为了应对这种左右子树不平衡的问题，人们提出了诸如平衡树Treap的数据结构，采用随机化数据来保持左右子树的平衡性，这样一来整体时间复杂度是稳定在 左右的。人们为了让 不被极端数据卡死，提出了平衡树（或树堆），见下一篇博客 后记&amp;致谢Epilogue &amp; Special Thanks 在写这篇文章的时候，经历了许多挫折……先是电脑意外关机，写了一千多字的草稿没保存直接没了；然后是注销电脑前望保存草稿，写了那么多，又一下子没了……为了保证代码的正确性，在做P5076的时候硬是顶着莫名的RE和WA把代码调出来了…… 当然，调我又臭又长的数据结构代码是需要很大耐心和毅力的（以及心理承受能力）。这期间需要感谢： 花半小时用控制变量法拯救我的RE代码的—— Brailliant11001 花半小时理解我的代码，提出Hack数据来警示我的—— DWHJHY 花重金买来一大包（450g装）薯片为我们疲惫的大脑补充营养的—— Aventurine_Stone 参考资料： [1] DWHJHY.二叉搜索树（BST）-BINARY SEARCH TREE [EB/OL] .https://www.luogu.com/article/vqr2u9g2 ,2024-4-12/2024-7-14 [2] Brailliant11001.二叉搜索树（BST）[EB/OL] .https://www.luogu.com/article/zqha49ef ,2024-1-31/2024-7-14","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[奇技淫巧] 如何优雅地秒圆锥曲线大题","slug":"tricks-in-conic-section","date":"2024-06-28T23:21:12.135Z","updated":"2024-06-28T23:21:29.139Z","comments":true,"path":"articles/8116/","link":"","permalink":"https://justpureh2o.cn/articles/8116/","excerpt":"","text":"前言 他只需略微现身，考生瞬间变圆神；只需给他一个不定参，他能把数学题做成英语题；给他一个定值证明，他能逼出考生使用伪证大法。不是含参韦达算不起，而是伪证算法更有性价比。有人说椭圆双曲线简单，新高考I卷丝带线表示不服。对此，五星上将麦克阿瑟评价道：“如果当年美军的考试卷没有圆锥曲线压轴题，美军战士一定能在圣诞节之前回家”。那么，圆锥曲线到底有何魔力？大型纪录片《圆锥曲线传奇》持续为您播出…… 向量叉乘 2024 新高考 I 卷 T16 已知 和 为椭圆 上两点。 求 的离心率 若过 的直线 交 于另一点 ，且 的面积为 ，求 的方程 首先根据题目数据联立方程解得圆锥曲线方程：，因此椭圆的离心率就是 。 第二题一般都是设出直线方程并联立求解。考虑到这里给出了三角形上两点和一个面积，毅然使用向量叉乘试水！ 向量叉乘的定义为 。可以理解为平面直角坐标系上两个向量围成的平行四边形面积，是一个只有大小的标量。这篇文章提到了有关向量叉乘的一些内容。简而言之，叉乘的简记方法是：将两个向量平铺在两行，变成 的形式，然后“斜线相乘再相减”，即 的绝对值就是叉乘运算的结果。 因为三角形的面积等于向量围成的平行四边形面积的一半，也就是说 。设出 点坐标为 ，得到： 把 用 表示出来（或反之）马上就可以解得 或 。因此两个直线方程就是 或 。 把叉乘写上去之前需要先证明其正确性（毕竟高中课本里面没教过），证明方法很简单： 假设 ，。就有：","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"差分约束","slug":"algorithm-diff-constraints","date":"2024-06-26T01:26:10.318Z","updated":"2024-06-26T01:45:43.367Z","comments":true,"path":"articles/8856/","link":"","permalink":"https://justpureh2o.cn/articles/8856/","excerpt":"","text":"差分约束系统 理论基础 我们称形如下面给出的多元一次不等式组为一个差分约束系统： 它包含 个未知数，以及 个约束条件，每个约束条件是由两个未知数作差构成的不等式。 求解这个不等式组，我们首先考虑移项，例如第一个不等式变成：。联想到最短路的三角不等式，即 ，这个方程组可以转化为一个最短路问题。具体到第一个不等式，就是创建边 ，边权为 。在读入所有不等关系后在建出的图上做最短路即可。 最短路的源点首先要能遍历到所有的边，若某个点遍历不到所有的边，部分点的最短路值显然不能正确更新，导致整体错误。一般来说考虑建立虚拟源点代替。 如果原图存在负环，假设是下图的形式： 那么就有：， 可以进一步放缩，因为 ，所以 ，而 又可以接着放缩，依此类推……当放缩到 时，原式已然变成了： 最后放缩得 显然有矛盾。因此当出现负环时就判断无解。 否则，每个点的最短路径长就是原不等式组的一组可行解。特殊地，给定一个实数 ，让所有未知数同时加/减去这个常数得到的新答案组也是成立的。 以 P5960 差分约束模板为例，给出求解代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define N 5010#define M 5010using namespace std;struct Edge { int to, ne, w;} edges[M];int h[N], idx = 0;int n, m;int dist[N], cnt[N];bool st[N];void add(int u, int v, int w) { idx++; edges[idx].to = v; edges[idx].ne = h[u]; edges[idx].w = w; h[u] = idx;}bool spfa() { memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) { q.push(i); st[i] = true; dist[i] = 0; } while (!q.empty()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; ~i; i = edges[i].ne) { int j = edges[i].to; if (dist[j] &gt; dist[t] + edges[i].w) { dist[j] = dist[t] + edges[i].w; cnt[j] = cnt[t] + 1; if (cnt[j] &gt;= n) return false; if (!st[j]) { st[j] = true; q.push(j); } } } } return true;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; while (m--) { int u, v, w; cin &gt;&gt; v &gt;&gt; u &gt;&gt; w; add(u, v, w); } if (!spfa()) cout &lt;&lt; \"NO\" &lt;&lt; endl; else { for (int i = 1; i &lt;= n; i++) cout &lt;&lt; dist[i] &lt;&lt; ' '; } return 0;} 那么如何求出未知数的最值呢？当所求为未知数的最大值时，最短路径长度就是最小解；反之最长路径长度为最大解。 首先该不等式组必须有解，因此所有不等式可以排列成一串 。此时 显然最小值是 ，但最大值就不是正无穷了，可以发现它的最大值是不等号连接的每一项的最小值。也就是到达这个点的最短路径长度；反之就是最长路径长度，此时图中若存在正环则无解。 差分约束典例 洛谷 P3275 [SCOI2011] 糖果 四川OI有很多典中典的题目，不只是这一道，包括繁忙的都市、k短路、方伯伯运椰子、序列操作等都是四川OI的杰作 题目地址：P3275 题目难度：提高+/省选- 题目来源：各省省选 四川 2011 幼儿园里有 个小朋友， 老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候， 需要满足小朋友们的 个要求。幼儿园的糖果总是有限的， 想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。 输入格式 输入的第一行是两个整数 ，。接下来 行，表示这些点需要满足的关系，每行 个数字，，，。 如果 ， 表示第 个小朋友分到的糖果必须和第 个小朋友分到的糖果一样多； 如果 ， 表示第 个小朋友分到的糖果必须少于第 个小朋友分到的糖果； 如果 ， 表示第 个小朋友分到的糖果必须不少于第 个小朋友分到的糖果； 如果 ， 表示第 个小朋友分到的糖果必须多于第 个小朋友分到的糖果； 如果 ， 表示第 个小朋友分到的糖果必须不多于第 个小朋友分到的糖果； 输出格式： 输出一行，表示 老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 。 数据范围： 对于 的数据，保证 对于 的数据，保证 对于所有的数据，保证 根据题目中给出的五种大小关系，可以列出如下不等式组： 可以直接按照上一节所说的方式建图，注意第一种情况相当于建边权为 的双向边。 题目中还有一个要求——“每个小朋友都要分到糖果”，转换一下就是 。那么像这种要求解必须大于一个常数的情况该怎么样操作呢？ 考虑到建立虚拟源点 ，并令 ，则原式化为 。因此建立边权为 的边 即可。因为要求出所有未知数的最小值，因此要跑最长路，同时无解的判断就是存在正环。在 里，做最长路就是把松弛操作的不等号换向，同时初始化距离为正无穷。 1","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"差分约束","slug":"差分约束","permalink":"https://justpureh2o.cn/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"}]},{"title":"分数规划算法","slug":"algorithm-fractional-programming","date":"2024-06-19T04:02:07.457Z","updated":"2024-06-25T22:50:08.387Z","comments":true,"path":"articles/57241/","link":"","permalink":"https://justpureh2o.cn/articles/57241/","excerpt":"","text":"前言 在写 SPFA 判负环 的时候发现很多题目需要联系到高贵的0/1分数规划，但是截至当时我还没有学这样优雅的算法，故先将 咕一咕，把关于分数规划的东西弄清楚再回去填坑。正好刚考完高一下的合格考，觉得正是适合学新东西的时候，在此归纳一些简单的分数规划知识……这都什么跟什么啊 分数规划基本模型如下： 给出有 个元素的两个数列 和 ，求对整数 ，使得下式最大化： 通俗一点地说，给出 件商品。每件商品都有一个价格 和价值 ，你需要做的就是求出买哪些商品能够让所有物品总的性价比最高——即最优购买问题。 一般分数规划问题还会有一些奇怪的限制，比如『分母至少为 』。 ——OI WIKI 分数规划求解 我们假设当前有一个值 ，假定当前的 并非最优解，那么一定会有如下特殊情况： 也就是说存在组合使最后一个不等式成立时， 就不是最大值，也就是比答案小；反之，将大于号反向， 就比答案大。我们就可以二分 值，不断检测上面的不等式情况，收缩二分区间。 代码： 123456789101112131415161718192021222324const double EPS = 1e-6;bool check(double d) { double res = 0; for (int i = 1; i &lt;= n; i++) { if (a[i] - d * b[i] &gt; 0) res += a[i] - d * b[i]; } return res &gt;= 0;}int main() { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; double L = 0, R = INFINITY; while (R - L &gt; EPS) { double mid = (L + R) / 2; if (check(mid)) L = mid; else R = mid; } cout &lt;&lt; L &lt;&lt; endl; return 0;} 很多时候分数规划的题目都会直接间接地把物品的权值变为 ，因此二分 即可求解。 分数规划例题 洛谷 P10505 Dropping Test 题目地址：P10505 题目难度：普及/提高- 在某个课程中，你需要进行 次测试。 如果你在共计 道题的测试 上的答对题目数量为 ，你的累积平均成绩就被定义为 给定您的考试成绩和一个正整数 ，如果您被允许放弃任何 门考试成绩，您的累积平均成绩的可能最大值是多少。 假设您进行了 次测试，成绩分别为 和 。 在不放弃任何测试成绩的情况下，您的累积平均成绩是 。 然而，如果你放弃第三门成绩，则您的累积平均成绩就变成了 。 输入格式： 输入包含多组测试用例，每个测试用例包含三行。 对于每组测试用例，第一行包含两个整数 和 。 第二行包含 个整数，表示所有的 。 第三行包含 个整数，表示所有的 。 当输入用例 时，表示输入终止，且该用例无需处理。 输出格式： 对于每个测试用例，输出一行结果，表示在放弃 门成绩的情况下，可能的累积平均成绩最大值。 结果应四舍五入到最接近的整数。 数据范围： 数据范围 , , 。 这道题结合了分数规划和贪心。我们的目标是让 的 值最大。先预处理所有的 ，并对它排序，每次取最大的 个累加。判断得到的结果是否大于等于 即可。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define N 1010using namespace std;double a[N], b[N];double arr[N];const double EPS = 1e-6;int n, k;bool check(double d) { double res = 0; for (int i = 1; i &lt;= n; i++) arr[i] = a[i] - d * b[i]; sort(arr + 1, arr + 1 + n); for (int i = n; i &gt; k; i--) { res += arr[i]; } return res &gt;= 0;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); while (cin &gt;&gt; n &gt;&gt; k, n || k) { for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; double L = 0, R = 1; while (R - L &gt; EPS) { double mid = (L + R) / 2; if (check(mid)) L = mid; else R = mid; } cout &lt;&lt; round(100 * L) &lt;&lt; endl; } return 0;} 由于涉及到浮点数二分，我们需要定义一个浮点数精确度来近似处理，一般来说不会大于 。 洛谷 P4377 [USACO18OPEN] Talent Show G 题目地址：P4377 题目难度：提高+/省选- 题目来源：USACO 2018 Farmer John 要带着他的 头奶牛，方便起见编号为 ，到农业展览会上去，参加每年的达牛秀！他的第 头奶牛重量为 ，才艺水平为 ，两者都是整数。 在到达时，Farmer John 就被今年达牛秀的新规则吓到了： （一）参加比赛的一组奶牛必须总重量至少为 （这是为了确保是强大的队伍在比赛，而不仅是强大的某头奶牛），并且。 （二）总才艺值与总重量的比值最大的一组获得胜利。 FJ 注意到他的所有奶牛的总重量不小于 ，所以他能够派出符合规则（一）的队伍。帮助他确定这样的队伍中能够达到的最佳的才艺与重量的比值。 输入格式： 第一行是两个整数，分别表示牛的个数 和总重量限制 。 第 到 行，每行两个整数，第 行的整数表示第 头奶牛的重量 和才艺水平 。 输出格式： 请求出 Farmer 用一组总重量最少为 的奶牛最大可能达到的总才艺值与总重量的比值。 如果你的答案是 ，输出 向下取整的值，以使得输出是整数（当问题中的数不是一个整数的时候，向下取整操作在向下舍入到整数的时候去除所有小数部分）。 请注意当问题的答案恰好是整数 时，你的程序可能会由于浮点数精度误差问题最后得到一个 的答案，向下取整后变为 导致答案错误。这种情况下你可以在输出答案前给答案加上一个极小的值 来避免该问题。 数据范围： 对于全部的测试点，保证 ，，，。 这道题结合了01背包和01分数规划。这里的 限制提醒我们需要用背包解决，根据分数规划的二分判别式 ，我们把每头牛的价值重新赋为 ， 在每次二分过程中都会改变。对于当前二分到的每个值，都做一次01背包。dp[i] 的含义是“总重量为 的牛的最大规划价值（判别式的最大值）”，对于每头牛，就有两种情况： 选择这头牛：数据更新为“不选这头牛的最大价值加上当前牛的价值”，即 。 不选这头牛：数据不更新，即 。 若 ，直接结算到总重量为 的情况。 也就是说每次二分得到一个中值，然后对每个中值跑背包算法即可。为了避免一些奇奇妙妙的浮点数误差，输入时统一将才艺水平乘 ，对应下来二分的上下界也要乘 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define N 300#define M 1010using namespace std;typedef long long ll;struct Cow { int talent, weight; ll w;} cow[N];int n, W;ll dp[M];bool check(ll d) { for (int i = 1; i &lt;= n; i++) { cow[i].w = cow[i].talent - d * cow[i].weight; } dp[0] = 0; for (int i = 1; i &lt;= W; i++) { dp[i] = -1e10; } for (int i = 1; i &lt;= n; i++) { for (int j = W; j &gt;= 0; j--) { dp[min(W, j + cow[i].weight)] = max(dp[min(W, j + cow[i].weight)], dp[j] + cow[i].w); } } return dp[W] &gt;= 0;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; W; ll sum = 0; for (int i = 1; i &lt;= n; i++) { int w, t; cin &gt;&gt; w &gt;&gt; t; sum += t * 1000; cow[i].talent = t * 1000; cow[i].weight = w; } ll L = 0, R = sum; while (R &gt;= L) { ll mid = (L + R) &gt;&gt; 1; if (check(mid)) L = mid + 1; else R = mid - 1; } cout &lt;&lt; L - 1 &lt;&lt; endl; return 0;} 当然还有一种 的做法，由 DengDuck 提出。其中提到了“糖水不等式”： 我们都知道，向水中放糖会让水变甜。如果放糖前水的总体积为 ，溶质（糖）的体积为 ，放入糖的体积为 。根据生活经验有 ，即糖水变甜。推论：。 博客地址 洛谷 P3199 [HNOI2009] 最小圈 题目地址：P3199 题目难度：省选/NOI- 题目来源：各省省选 湖南 2009 考虑带权有向图 以及 ，每条边 （，）的权值定义为 。设 。 （）是 中的一个圈当且仅当 （）和 都在 中。称 为圈 的长度，同时记 ，并定义圈 的平均值为 即 上所有边的权值的平均值。设 为 中所有圈 的平均值的最小值。 给定图 以及 ，求出 中所有圈 的平均值的最小值 。 输入格式： 第一行两个正整数，分别为 和 ，并用一个空格隔开。其中 ， 分别表示图中有 个点 和 条边。 接下来 行，每行三个数 ，表示有一条边 且该边的权值为 ，注意边权可以是实数。输入数据保证图 连通，存在圈且有一个点能到达其他所有点。 输出格式： 一个实数 ，要求精确到小数点后 位。 数据范围： 对于 的数据，，，， 且 。 提示：本题存在 的做法，但是 的做法也可以通过。 本题的 做法来源于 在1977年发布的一篇题为《有向图最优环比率的特征》的论文。其中他描述的算法被称作 算法，能够在 的复杂度内求解该问题，而且是正解。但是我不会这个算法，这里仅介绍 的做法，也就是分数规划的解法。 根据题意，我们要求分式 的最小值。也就是找到一个环，使得环上边权之和与环中点数之商最大。接续分数规划的思路，我们先来化简这个式子：假设当前二分到 ，且它不是最小值，因此存在数据满足 。接下来去分母得 。考虑到当前环中有 个点，严格来说上式应为 。移项展开得 ，即 。 这下非常明朗了：对于每次二分，假设我们把边权重新设为 。根据化简的式子可得，我们需要求出一个环，环上所有边的边权均重设为 ，并满足重设后的边权之和小于等于 。就可以转化为 求负环的问题了。如果存在负环，代表最初假设成立，最终答案应小于 ，收缩右区间；否则收缩左区间。注意到边权为实数，可正可负，极端情况下，环的均值可以达到 ，二分的左右区间就是 和 。要求答案保留八位小数，浮点数精度的设置不宜大于 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define N 3010#define M 100010using namespace std;struct Edge { int to, ne; double w;} edges[M];const double EPS = 1e-9;int h[N], cnt[N], idx = 0;double dist[N];bool st[N];int n;void add(int u, int v, double w) { idx++; edges[idx].to = v; edges[idx].ne = h[u]; edges[idx].w = w; h[u] = idx;}bool check(double d) { memset(cnt, 0, sizeof cnt); memset(st, false, sizeof st); for (int i = 1; i &lt;= n; i++) dist[i] = INT_MAX; queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) { q.push(i); st[i] = true; dist[i] = 0; } while (!q.empty()) { int id = q.front(); q.pop(); st[id] = false; for (int i = h[id]; ~i; i = edges[i].ne) { int j = edges[i].to; double wfp = edges[i].w - d; if (dist[j] &gt; dist[id] + wfp) { dist[j] = dist[id] + wfp; cnt[j] = cnt[id] + 1; if (cnt[j] == n) return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { int a, b; double c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } double L = -1e7, R = 1e7; while (R - L &gt; EPS) { double mid = (L + R) / 2; if (check(mid)) R = mid; else L = mid; } cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; L &lt;&lt; endl; return 0;} POJ 2728 Desert King 题目地址：POJ 2728 伟大的呆娃 David 刚刚成为沙漠王国的国王。为了巩固他的统治，他准备在王国内修建很多连通每座城市的灌溉水渠。作为王国的统治者兼吉祥物，他需要用一种最优的方式修建这些水渠…… 经过几天的实地调研，他想到了一个修建方案：他想要最小化单位长度内的修建成本。换句话说，修建的总成本与总长度的比值需要最小。他只需修建必要的水渠，因此连接到某个城市的水渠只有唯一一条到达王宫的可行路径。 他的御用工程师们测量了每个城市的位置与海拔高度。每条水渠必须笔直地连通两个城市，且没有坡度。但是两座城市之间又可能存在高度差，因此他们决定在某两座城市之间修建一个垂直运水机，它可以垂直地运送水资源。水渠的长度定义为两座城市之间的水平距离、其修建成本定义为垂直运水机的竖直高度。需要注意的是：任意两座城市的高度都是不同的，且不同的水渠不能共用一个垂直运水机。水渠之间允许交叉，且任意三座城市不共线。 作为呆娃 David 的御用科学家和 OIer，你被要求求出符合要求的最小比值。 输入格式： 多组测试数据，每组数据的第一行有一个整数 ，代表城市总数。 接下来 行，每行三个数 ，代表每座城市的三维坐标。第一座城市是王宫所在地 。 时结束读入 输出格式： 对于每组数据，输出一行代表最优比率，保留三位小数 数据范围： ，， 题目翻译 By 我 这是一道最优比率生成树的题目。题目要求最小化 ，熟练地推出如下式子： ，当该式子成立时代表还可以收缩左区间。 接下来，我们预处理规划权值 ，然后对于邻接矩阵的稠密图，跑一遍我个人蛮不想用的Prim算法（甚至Prim没有加高贵的 和首尾空格，可见作者的不情愿使用之情），返回最小比率生成树的权值是否非负即可。注意到保留三位小数，精度理论上不应大于 数量级。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define N 1010using namespace std;struct Village { double x, y, z;} villages[N];const double EPS = 1e-6;double dist[N][N], budget[N][N];double prim[N];bool st[N];int n;double sum = 0;double dis(Village i, Village j) { return sqrt(pow(i.x - j.x, 2) + pow(i.y - j.y, 2));}void init() { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt; i; j++) { dist[i][j] = dist[j][i] = dis(villages[i], villages[j]); budget[i][j] = budget[j][i] = fabs(villages[i].z - villages[j].z); sum += budget[i][j]; } }}bool check(double d) { memset(st, false, sizeof st); double tmp = 0; for (int i = 1; i &lt;= n; i++) prim[i] = budget[1][i] - d * dist[1][i]; st[1] = true; for (int i = 1; i &lt;= n; i++) { int t = -1; double minx = INT_MAX; for (int j = 1; j &lt;= n; j++) { if (!st[j] &amp;&amp; minx &gt; prim[j]) { t = j; minx = prim[j]; } } if (t == -1 || minx &gt;= INT_MAX) break; st[t] = true; tmp += minx; for (int j = 1; j &lt;= n; j++) { double wfp = budget[t][j] - d * dist[t][j]; if (!st[j] &amp;&amp; prim[j] &gt; wfp) { prim[j] = wfp; } } } return tmp &gt;= 0;}int main() { while (cin &gt;&gt; n, n) { sum = 0; for (int i = 1; i &lt;= n; i++) { double x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; villages[i].x = x; villages[i].y = y; villages[i].z = z; } init(); double L = 0, R = sum; while (R - L &gt; EPS) { double mid = (L + R) / 2; if (check(mid)) L = mid; else R = mid; } cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; L &lt;&lt; endl; } return 0;} 由于 POJ 的评测机编译不了万能头和转型式结构体赋值，甚至没有 nullptr，因而把一些最具有本人特色的代码给删除/修改了。望周知。","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"分数规划","slug":"分数规划","permalink":"https://justpureh2o.cn/tags/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"}]},{"title":"SPFA 和负环","slug":"algorithm-spfa-and-negaweight-circuit","date":"2024-06-14T23:56:20.655Z","updated":"2024-06-22T06:10:43.125Z","comments":true,"path":"articles/18405/","link":"","permalink":"https://justpureh2o.cn/articles/18405/","excerpt":"","text":"关于 SPFA，以及…… ……以及它死了，现在有意无意卡 似乎已经成为 OI 出题界的常规操作了…… 算法的流程如下： 遍历 个点 对于当前的点 ，遍历它的所有出边，并获取出边相连的点 进行松弛操作，将 设为 若终点的最短路长度不为正无穷，则找到最短路；否则整张图不连通 但是在第三步中，每个点的最短距离不一定能够被更新——只有上一次松弛成功的点连接的边，才有可能引起下一次更新。做一个优化，减少不必要的出队。 引入了一个队列（类似于宽搜的队列），用来记录点的入队，避免不必要的松弛，具体如下： 12345678910111213141516171819202122232425void spfa(int s) { memset(dist, 0x3f, sizeof dist); queue&lt;int&gt; q; q.push(s); st[s] = true; dist[s] = 0; while (!q.empty()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; ~i; i = edges[i].ne) { int j = edges[i].to; if (dist[j] &gt; dist[t] + edges[i].w) { dist[j] = dist[t] + edges[i].w; if (!st[j]) { q.push(j); st[j] = true; } } } }} 长得和 真的很像。 负环 负环，顾名思义，就是边权之和为负数的环。在 中，有两种判负环的方式。 对每个点出队的次数进行计数，若某个点出队次数大于等于 （点数），则存在负环 求出到达当前点的最短路所经过的边数，若边数大于等于 则存在负环 实际情况我们更喜欢用第二种，考虑极端情况—— 个点构成一个大负环，那么程序在这个环上跑一圈，每个点均只出队一次；要想使某个点出队 次，就要经过 条边，会造成严重的性能浪费。相较之下，第二种方案只需要在这个环上绕一圈即可判断负环，效率是极高的。 以 P3385 负环模板题为例，给出修改后的 核心代码： 12345678910111213141516171819202122232425262728bool spfa(int n) { memset(cnt, 0, sizeof cnt); memset(dist, 0x3f, sizeof dist); memset(st, false, sizeof st); queue&lt;int&gt; q; q.push(1); st[1] = true; dist[1] = 0; while (!q.empty()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; ~i; i = edges[i].ne) { int j = edges[i].to; if (dist[j] &gt; dist[t] + edges[i].w) { dist[j] = dist[t] + edges[i].w; cnt[j] = cnt[t] + 1; if (cnt[j] == n) return false; if (!st[j]) { q.push(j); st[j] = true; } } } } return true;} 洛谷 P2850 [USACO06DEC] Wormhole G 题目地址：P2850 题目难度：普及+/提高 题目来源：USACO 2006 John 在他的农场中闲逛时发现了许多虫洞。虫洞可以看作一条十分奇特的有向边，并可以使你返回到过去的一个时刻（相对你进入虫洞之前）。 John 的每个农场有 条小路（无向边）连接着 块地（从 标号），并有 个虫洞。 现在 John 希望能够从某块地出发，走过一条路径回到出发点，且同时也回到了出发时刻以前的某一时刻。请你告诉他能否做到。 输入格式： 输入的第一行是一个整数 ，代表测试数据的组数。 每组测试数据的格式如下： 每组数据的第一行是三个用空格隔开的整数，分别代表农田的个数 ，小路的条数 ，以及虫洞的个数 。 每组数据的第 到第 行，每行有三个用空格隔开的整数 ，代表有一条连接 与 的小路，经过这条路需要花费 的时间。 每组数据的第 到第 行，每行三个用空格隔开的整数 ，代表点 存在一个虫洞，经过这个虫洞会到达点 ，并回到 秒之前。 输出格式： 对于每组测试数据，输出一行一个字符串，如果能回到出发时刻之前，则输出 YES，否则输出 NO。 数据范围： 对于 的数据，，，，，。 经典题。在题目中，我们不确定图的起点编号，图论中的经典技巧“虚拟源点”就派上用场了。虚拟源点是指新建一个原图中不存在的点，并把这个点向所有其他点连一条权值为 的双向边，以实现多源汇最短路的求解。但实际操作中不一定需要真正的创建一个新点，可以从最短路初始的入队点入手——初始时先将 号点全部入队。因为虚拟源点在初次松弛时，一定会遍历到所有相连点，即 号点，然后松弛入队。因此开始将所有点加入队列和建立虚拟点并入队是等价的。 考虑把所有虫洞通道看作边权为 的有向边，这道题就转化成了判断是否存在负环的题目。也就是说我们直接敲一遍求负环的模板，就可以通过此题 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#define N 510#define M 3010using namespace std;struct Edge { int to, ne, w;} edges[M &lt;&lt; 1];int h[N], idx = 0;int dist[N], cnt[N];bool st[N];void add(int u, int v, int w) { idx++; edges[idx].to = v; edges[idx].ne = h[u]; edges[idx].w = w; h[u] = idx;}bool spfa(int n) { memset(dist, 0x3f, sizeof dist); memset(st, false, sizeof st); memset(cnt, 0, sizeof cnt); queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) { q.push(i); st[i] = true; dist[i] = 0; } while (!q.empty()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; ~i; i = edges[i].ne) { int j = edges[i].to; if (dist[j] &gt; dist[t] + edges[i].w) { dist[j] = dist[t] + edges[i].w; cnt[j] = cnt[t] + 1; if (cnt[j] == n) return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { memset(h, -1, sizeof h); idx = 0; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int u, v, w; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); add(v, u, w); } for (int i = 1; i &lt;= k; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, -w); } cout &lt;&lt; (spfa(n) ? \"YES\" : \"NO\") &lt;&lt; endl; } return 0;} 洛谷 P2868 [USACO07DEC] Sightseeing Cows G 题目地址：P2868 题目难度：省选/NOI- 题目来源：USACO 2007 给你一张 点 边的有向图，第 个点点权为 ，第 条边边权为 。 找一个环，设环上的点组成的集合为 ，环的边组成的集合为 ，最大化 。 输入格式： 第一行是两个整数 和 接下来 行，每行一个整数代表 接下来 行，每行三个整数 ，代表 和 之间有一条长为 的边 输出格式： 一行一个数表示结果，保留两位小数 数据范围： 这道题需要用到分数规划相关知识，主要在对题目中算式的处理。根据题意可知，要求出一个环使得环中点权之和与边权之和比值最大。我们把环中的点权看作“性价比模型”里的“性能”，即 ；把边权看作“价格”，即 。在分数规划中，当 时，证明当前二分到的 值小于正确答案；反之大于正确答案。根据这两条收缩二分区间，即可达到求解的效果。 在这道题里。考虑将上式变号，同乘 ，变为 。如果我们把边 的边权重定义为 ，就简化成“判断图上是否存在权值和为负的环”——负环的判断了。若形成负环，返回真，左区间收缩；反之收缩右区间。注意到负环的起始点并不确定，因此应用上面的超级源点思想来求解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;#define N 1010#define M 5010using namespace std;struct Edge { int to, ne, w;} edges[M &lt;&lt; 1];int h[N], idx = 0;int p[N];int cnt[N];double dist[N];bool st[N];int L, P;const double EPS = 1e-6;void add(int u, int v, int w) { idx++; edges[idx].to = v; edges[idx].ne = h[u]; edges[idx].w = w; h[u] = idx;}bool check(double mid) { memset(st, false, sizeof st); memset(cnt, 0, sizeof cnt); memset(dist, 127, sizeof dist); queue&lt;int&gt; q; for (int i = 1; i &lt;= L; i++) q.push(i), st[i] = true, dist[i] = 0; while (!q.empty()) { int id = q.front(); q.pop(); st[id] = false; for (int i = h[id]; ~i; i = edges[i].ne) { int j = edges[i].to; double wfp = mid * edges[i].w - p[id]; if (dist[j] &gt; wfp + dist[id]) { dist[j] = wfp + dist[id]; cnt[j] = cnt[id] + 1; if (cnt[j] == L) return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); cin &gt;&gt; L &gt;&gt; P; for (int i = 1; i &lt;= L; i++) cin &gt;&gt; p[i]; for (int j = 1; j &lt;= P; j++) { int a, b, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; add(a, b, w); } double LEFT = 0, RIGHT = 1000; while (RIGHT - LEFT &gt; EPS) { double mid = (LEFT + RIGHT) / 2; if (check(mid)) LEFT = mid; else RIGHT = mid; } cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; LEFT &lt;&lt; endl; return 0;} SPOJ 2885 WORDRING - Word Rings 题目地址：SPOJ 2885 题目难度：省选/NOI- 如果字符串A的结尾两个字符与字符串B的开头两个字符相匹配，我们称A与B能 “ 相连 ” ( 注意：A与B能相连，不代表B与A能相连 ) 当若干个串首尾 “ 相连 ” 成一个环时，我们称之为一个环串（一个串首尾相连也算） 我们希望从给定的全小写字符串中找出一个环串，使这个环串的平均长度最长 123intercommunicational alkylbenzenesulfonate tetraiodophenolphthalein 如上例：第一个串能与第二个串相连，第二个串能与第三个串相连，第三个串又能与第一个串相连。按此顺序连接，便形成了一个环串。 长度为 20+21+24=65 ( 首尾重复部分需计算两次 ) ，总共使用了3个串，所以平均长度是 65/3≈21.6666 输入格式： 多组数据 每组数据第一行一个整数n，表示字符串数量 接下来n行每行一个长度小于等于1000的字符串 读入以n=0结束 输出格式： 若不存在环串，输出\"No solution.\"。否则输出最长的环串平均长度。 Translated by @远藤沙椰 数据范围： 这道题让我们最大化一个比值，再次把目光放到分数规划上来。如同上一道题，这道题也可以转化为分数规划+判负环的算法求解。难点在于如何把一个一个的字符串建成图。 首先考虑把每个字符串当成一个点，如果两个字符串能首尾相接（直接判断首位两个字符），就连边，边权为两字符串长度之和。这样建图有没有什么不妥之处？ 观察到数据范围， 的极端情况是十万，假设我们有十万个完全相同的字符串，那么点数将是 ，两两连边，边数是 。完全失败！ 换一种思路，把首位两个字符当作点，把一个字符串拆成两点和一边（化学键），边权是该字符串的长度。此时的最大点数将是 ，最大边数是 （字符串总数）。然后就可以用分数规划求解了。 从基本模型出发，得到 。不难发现此时 代表字符串的长度， 代表所用字符串的数量（经过的边数）。求和是从 的，每项展开得 ，新边权就是 。像上一道题那样不等号两边同乘以 ，得到 ，就可以转化为一个判负环问题。 判负环使用 会稍慢（会TLE），这里改用 来实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define N 700#define M 100010#define distinct(a, b) ((a - 'a') * 26 + b - 'a')#define recover(x) (string(1, char(x / 26 + 'a')) += char(x % 26 + 'a'))using namespace std;struct Edge { int to, ne, w;} edges[M &lt;&lt; 1];int h[N], idx = 0;const double EPS = 1e-6;int n;double dist[N];bool st[N];void add(int u, int v, int w) { idx++; edges[idx].to = v; edges[idx].ne = h[u]; edges[idx].w = w; h[u] = idx;}bool spfa_dfs(int u, double d) { if (st[u]) return true; st[u] = true; for (int i = h[u]; ~i; i = edges[i].ne) { int j = edges[i].to; double wfp = d - edges[i].w; if (dist[j] &gt; dist[u] + wfp) { dist[j] = dist[u] + wfp; if (spfa_dfs(j, d)) return true; } } st[u] = false; return false;}bool check(double d) { memset(dist, 0, sizeof dist); memset(st, false, sizeof st); for (int i = 0; i &lt; 676; i++) { if (spfa_dfs(i, d)) return true; } return false;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); while (cin &gt;&gt; n &amp;&amp; n) { memset(h, -1, sizeof h); idx = 0; for (int i = 1; i &lt;= n; i++) { string s; cin &gt;&gt; s; if (s.length() &lt; 2) continue; add(distinct(s[0], s[1]), distinct(s[s.length() - 2], s[s.length() - 1]), s.length()); } double L = 0, R = 1e5; while (R - L &gt; EPS) { double mid = (L + R) / 2; if (check(mid)) L = mid; else R = mid; } if (L &gt; EPS) cout &lt;&lt; L &lt;&lt; endl; else cout &lt;&lt; \"No solution.\" &lt;&lt; endl; } return 0;} 相似题目：UVA 11090、P3199、P3288","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"最短路算法","slug":"最短路算法","permalink":"https://justpureh2o.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/"}]},{"title":"[奇技淫巧] C++ 编程小寄巧","slug":"cpp-programming-tricks","date":"2024-06-14T22:25:49.881Z","updated":"2024-06-14T23:49:43.078Z","comments":true,"path":"articles/40484/","link":"","permalink":"https://justpureh2o.cn/articles/40484/","excerpt":"","text":"前言 我非常喜欢一些奇技淫巧，每次有机会时就想用点小技巧，既方便了自己、有时还能博来他人的赞叹，实属一举两得的行为。在这篇文章之前，我的奇技淫巧仅局限于高中数学题。接下来我把进入 C++ 编程以来收集的实用小技巧全部放在这里，并不定时更新新的小技巧。希望能帮到后人。 引用伟大的毛主席的一句话： 幸亏古人和外国人替我们造好了这许多符号，使我们开起中药铺来毫不费力。 毛泽东 ——《反对党八股》 当然这句话在这里已经失去了原先的讽刺意味，我们会着重探讨使用这些小技巧的好处而非坏处。毕竟它的正确性就摆在那里，自己写还可能出现错误，为什么不保险一些呢？ GCC 内建函数的巧用 在位运算中，很多人为了加快运行效率图方便，会使用以双下划线+“builtin”开头的 GCC 内建函数。其中最为常见的是 __builtin_popcount() 函数。接下来介绍几种实用的内建函数。 注意：赛时的机器可能并不支持使用下划线开头的库函数，如果不想吃 CE 的话就还是老老实实的写一遍。 popcount 系列函数 一般来说，这种内建函数针对于不同类型的参数会设计不同的函数签名。一般来说，在 __builtin_popcount 后直接加上数据类型的简写就可以得到针对这种数据类型的函数。目前仅支持 int、long 和 long long 类型，除 int 类型外，函数签名分别追加 l 和 ll。对于这个函数就是 __builtin_popcountl() 和 __builtin_popcountll()。后文不再对这点进行赘述。 用来计算该数在二进制表示下 的总个数。一般我们会写的 做法如下： 12345678int popcount(int x) { int res = 0; while (x) { if (x &amp; 1) res++; x &gt;&gt;= 1; } return res;} GCC 在实现这些函数时自动将函数设为内联 inline，因此通常情况下会效率更高。主要还是不用自己写 例子： 123__builtin_popcount(5) // 返回2，因为十进制的5等于二进制的101__builtin_popcountll(INT_MAX + 1) // 返回33__builtin_popcountll(LLONG_MAX - 1) // 返回62 值得注意的是，GCC 并没有计算二进制下 个数的函数。不过实现起来也很简单，把上文代码里的 b &amp; 1 的判断条件取反即可。 clz、ctz 系列函数 __builtin_clz() 用来获取二进制表示下前导 的个数；__builtin_ctz() 则是二进制末尾 的个数。日常使用中前导 的个数不常使用，较常使用的是 ctz 函数。 做法如下： 1234567891011121314151617int clz(int x) { int res = 0; if (x == 0) return 0; for (int i = 32; i &gt;= 0; i--) { if ((x &gt;&gt; i) &amp; 1) return res; else res++; } return 0;}int ctz(int x) { if (x == 0) return 0; for (int i = 0; i &lt;= 32; i++) { if ((x &lt;&lt; i) &amp; 1) return i; } return 0;} 例子： 12__builtin_clz(7) // 29__builtin_ctz(20071126) // 1 ffs 系列函数 __builtin_ffs() 函数用来求得二进制位下第一个非零位的下标（从低位到高位，下标从 开始），除开特殊数字 外，都有 。因此： 123456789101112int ffs(int x) { if (x == 0) return 0; return ctz(x) + 1;}// 或者...int ffs(int x) { if (x == 0) return 0; for (int i = 0; i &lt;= 32; i++) { if ((x &gt;&gt; i) &amp; 1) return i + 1; } return 0;} 例子： 12__builtin_ffs(14) // 2__builtin_ffs(INT_MAX - 1) // 2 parity 系列函数 __builtin_parity() 函数用来求解二进制下 的个数的奇偶性（二进制下 的个数对 取模）。在某些游戏的二进制文件校验里可能会用到（具体是检测二进制文件下 或 的个数来判断文件是否损坏或被篡改）。 123456789101112int parity(int x) { return popcount(x) % 2;}// 或者...int parity(int x) { int res = 0; while (x) { if (x &amp; 1) res++; x &gt;&gt;= 1; } return res % 2;} 例子： 12__builtin_parity(26) // 1__builtin_parity(INT_MAX / 2) // 0 系统宏定义的巧用 INFINITY 宏 考虑这样一个情境：你在赛时写出了一个最短路代码，由于害怕数据爆 int，你选择改用 long long，并把最短路的 数组初始化成了 。但临近结束时，经过一通推算，你发现数据不会爆 int，反而发现开一个过大的 long long 数组可能会爆空间。你又将它改成了 int 类型。比赛结束后，你在场外忽然想起初始化还是一个爆 int 的值，果不其然喜提零分评测…… 如何避免像上边那样写出一个爆类型的极大值，我的建议是使用 宏定义。编译时将会替换为 __builtin_inff() 函数（其实本来应该放到上边那一栏的）。它的具体值会随数据类型的改变而改变，例如： 1234567891011int a = INFINITY;long b = INFINITY;long long c = INFINITY;double d = INFINITY;float e = INFINITY;short f = INFINITY;bool g = INFINITY;char h = INFINITY;cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' ' &lt;&lt; c &lt;&lt; ' ' &lt;&lt; d &lt;&lt; ' ' &lt;&lt; e &lt;&lt; ' ' &lt;&lt; f &lt;&lt; ' ' &lt;&lt; g &lt;&lt; ' ' &lt;&lt; h &lt;&lt; endl;// 输出 2147483647 2147483647 9223372036854775807 inf inf 32767 1 〼 （char 值为 127，对应字符 '\\177'） 可见使用这种方法可以优雅地避开上述情景中的窘境，助力 。对于特定数据类型（一般是 int 和 long long）， 和 也能帮到你。 库函数的巧用 __gcd 函数 在数学题中经常需要我们去求两个数的最大公约数，一般来说我们会写欧几里得算法（辗转相除法）： 123int gcd(int a, int b) { return b ? gcd(b, a % b) : a;} 库函数中 __gcd() 也可以实现这一功能，它要求传入的两个参数是同一数据类型。这一点与 min()、max() 函数是相同的。 如果想要求解最小公倍数，则只需用两个数的乘积除以它们的最大公约数即可。","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"生成树算法","slug":"algorithm-spanning-trees","date":"2024-06-14T01:14:23.786Z","updated":"2024-06-14T23:42:55.254Z","comments":true,"path":"articles/28422/","link":"","permalink":"https://justpureh2o.cn/articles/28422/","excerpt":"","text":"生成树基础 生成树，在 OI 中最多的考法有两种——最小生成树和次小生成树。最小生成树（Minimum Spanning Tree，MST）是最常见的问题，它是原图边权之和最小的生成树（不一定唯一）；而次小生成树，分为严格次小生成树和非严格次小生成树，前者要求次小生成树的权值和严格小于最小生成树的权值和，后者则无此要求，即允许“大于等于”情况的出现。实际考察严格次小生成树较多。 生成树基础算法 Prim （稠密图） 算法的思想类似于 算法，都是使用一个点去松弛并更新新的相连的节点。对于当前到达的节点，遍历它的相邻边，如果选中当前边后的权值小于数组中存储的 值时，就更新并将连接到的点加入队列。与 相同， 也可以使用堆优化来提升效率。 这个算法（加入堆优化）的时间复杂度是 的。不过我一般不用这个算法，原因是 的局限性较高，并且尽管是稠密图，它的运行效率也不一定比 算法高、后者的理解和实现门槛更低，所以在最小生成树问题中 算法永远都是首选。 Kruskal （墙裂推荐） 算法基于贪心思想，它的想法非常直白——把已有的边从小到大排序，按边权升序挑出边，如果边两头的节点已在生成树中，则跳过；反之若两点不都在生成树中，就添加上这条边。从而保证了最终生成树的边权之和最小。 当然，要想维护节点的从属关系。最适合最高效的数据结构当然就是并查集了，它能够在几近于常数的时间复杂度内快速求出两个节点的从属关系。我们依次取出边，判断这个边相连的两个点是否已经全部位于生成树内，若不都在生成树内，那么加入这个边，累加权值和边的数量。当选中的边数到达 时即可退出循环了。 具体实现如下（对应题目P3366）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define N 200010using namespace std;int p[N], n, m;struct Edge { int a, b, w; bool operator&lt; (const Edge &amp;r) { return w &lt; r.w; }} edges[N];int find(int x) { if (p[x] != x) return find(p[x]); return p[x];} bool query(int a, int b) { return find(a) == find(b);}void merge(int x, int y) { p[find(x)] = y;}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin&gt;&gt;n&gt;&gt;m; for (int i = 1; i &lt;= m; i++) { cin&gt;&gt;edges[i].a&gt;&gt;edges[i].b&gt;&gt;edges[i].w; } sort(edges, edges + m); for (int i = 1; i &lt;= n; i++) p[i] = i; int res = 0, cnt = 0; for (int i = 1; i &lt;= m; i++) { int a = edges[i].a; int b = edges[i].b; int w = edges[i].w; if (!query(a, b)) { merge(a, b); res += w; cnt++; } } if (cnt &lt; n - 1) cout&lt;&lt;\"orz\"&lt;&lt;endl; else cout&lt;&lt;res&lt;&lt;endl; return 0; } 最小生成树最长边权求解 洛谷 P2330 繁忙的都市 题目地址：P2330 题目难度：普及/提高- 题目来源：四川 2005 城市 C 是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市 C 的道路是这样分布的：城市中有 个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求： 改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 在满足要求 1 的情况下，改造的道路尽量少。 在满足要求 1、2 的情况下，改造的那些道路中分值最大的道路分值尽量小。 任务：作为市规划局的你，应当作出最佳的决策，选择哪些道路应当被修建。 输入格式： 第一行有两个整数 表示城市有 个交叉路口， 条道路。 接下来 行是对每条道路的描述， 表示交叉路口 和 之间有道路相连，分值为 。 输出格式： 两个整数 ，表示你选出了几条道路，分值最大的那条道路的分值是多少。 数据范围： 对于全部数据，满足 ，，。 这道题相当于让我们求出最小生成树的边数和选择的最大边权。考虑到最小生成树求解的顺序是边权升序，那么当最小生成树的最后一条边被选定时，此时的边权一定是答案所求的最大边权。在 选边时更新即可。 12345678910111213141516// 部分省略int main() { // 部分省略... int ans = INFINITY; for (int i = 1; i &lt;= m; i++) { int u = edges[i].u; int v = edges[i].v; int w = edges[i].w; if (!related(u, v)) { merge(u, v); ans = w; } } cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; return 0;} 双倍经验：P1547 最小生成树综合 AcWing 1146 新的开始 题目地址：AcWing 1146 题目难度：中等 发展采矿业当然首先得有矿井，小 FF 花了上次探险获得的千分之一的财富请人在岛上挖了 口矿井，但他似乎忘记了考虑矿井供电问题。 为了保证电力的供应，小 FF 想到了两种办法： 在矿井 上建立一个发电站，费用为 （发电站的输出功率可以供给任意多个矿井）。 将这口矿井 与另外的已经有电力供应的矿井 之间建立电网，费用为 。 小 FF 希望你帮他想出一个保证所有矿井电力供应的最小花费方案。 输入格式： 第一行包含一个整数 ，表示矿井总数。 接下来 行，每行一个整数，第 个数 表示在第 口矿井上建立发电站的费用。 接下来为一个 的矩阵 ，其中 表示在第 口矿井和第 口矿井之间建立电网的费用。 数据保证 ，且 。 输出格式： 输出一个整数，表示让所有矿井获得充足电能的最小花费。 数据范围 这道题是最小生成树与虚拟源点的综合，所谓虚拟源点，就是假想一个不存在的点，当作统一的起点，从而避免了对起点进行无意义枚举、重复计算的困境。 考虑创建一个“零号点”，当作一个发电站，那么这个点向其他点连边的意义就是“在当前点建立一个发电站”，显而易见的，边权应是 。对于操作2，就是单纯的生成树两点连边。因此我们预先处理输入的邻接矩阵，然后枚举并创建无向边 ，将边权设为 。值得注意的是， 算法读入的是无向边，但是它并不需要向前向星那样建两次边，只需要建一次，所以读入邻接矩阵的一半就好。 123456789101112131415161718192021222324252627282930for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { // 读入一半的邻接矩阵 int x; cin &gt;&gt; x; if (i &gt;= j) continue; edges[++cnt].u = i; edges[cnt].v = j; edges[cnt].w = x; }}for (int i = 1; i &lt;= n; i++) { // 超级源点的建边 edges[++cnt].u = 0; edges[cnt].v = i; edges[cnt].w = vi[i];}sort(edges + 1, edges + 1 + cnt, cmp);int ans = 0, ed = 0;for (int i = 1; i &lt;= cnt; i++) { int u = edges[i].u; int v = edges[i].v; int w = edges[i].w; if (!related(u, v)) { merge(u, v); ans += w; ed++; if (ed == n) break; }} 变量 ans 的值是最终答案。 洛谷 P4047 [JSOI2010] 部落划分 题目地址：P4047 题目难度：普及+/提高 题目来源：江苏 2010 聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。 不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法： 对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。 例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。 输入格式： 输入文件第一行包含两个整数 和 ，分别代表了野人居住点的数量和部落的数量。 接下来 行，每行包含两个整数 ，，描述了一个居住点的坐标。 输出格式： 输出一行一个实数，为最优划分时，最近的两个部落的距离，精确到小数点后两位。 数据范围： 对于 的数据，保证 ，。 这道题关联到并查集维护连通块个数的功能。在初始时，每个点都单独地作为一个连通块，整张图上就有 个连通块。那么每次建边就相当于将两个不同的连通块合并到一起，此时将存储连通块个数的变量减去一，当变量的值第一次小于等于 时，便可将下一个边的值输出。这个操作的原理依旧是最小生成树边权的升序排序，因此输出连通块总数小于等于 后取出的第一个边权即可。这里的边权就是两个村庄的欧几里得距离。 1234567891011121314151617double ans = 0;int c = n; // 连通块的个数，初始时为nfor (int i = 1; i &lt;= cnt; i++) { int u = edges[i].u; int v = edges[i].v; double w = edges[i].w; bool flag = false; if (c &lt;= k) flag = true; // 第一次小于等于k，记录一下 if (!related(u, v)) { merge(u, v); c--; // 成功连边，合并了两个连通块，总数减一 if (flag) { ans = w; // 连通块总数小于等于k后第一个边权即为答案 break; } }} 双倍经验：P1991 AcWing 346 走廊泼水节 题目地址：AcWing 346 题目难度：中等 给定一棵 个节点的树，要求增加若干条边，把这棵树扩充为完全图，并满足图的唯一最小生成树仍然是这棵树。 求增加的边的权值总和最小是多少。 注意： 树中的所有边权均为整数，且新加的所有边权也必须为整数。 输入格式： 第一行包含整数 ，表示共有 组测试数据。 对于每组测试数据，第一行包含整数 。 接下来 行，每行三个整数 ，表示 节点与 节点之间存在一条边，长度为 。 输出格式： 每组数据输出一个整数，表示权值总和最小值。 每个结果占一行。 数据范围： 完全图就是图中任意两个点之间都有边相连的图，不难计算出图中的边数为 。 还是先升序排序，对于取出的每个边——若该边可以被加入生成树中，它的两端节点一定分属于两个不同的连通块中。那么就在这两个连通块中互相连边（边的个数是 ），注意到原图是唯一的最小生成树，那么所连的边的边权就一定需要严格大于当前边的边权，即 。我们只需要开一个数组维护连通块大小即可。 注意到连通块大小的值仅在根节点有意义（根节点代表了整个连通块），就需要注意执行顺序的问题，并查集的合并函数一定在更新连通块大小之后。 12345678910for (int i = 1; i &lt; n; i++) { int u = edges[i].u; int v = edges[i].v; int w = edges[i].w; if (!related(u, v)) { res += (s[find(u)] * s[find(v)] - 1) * (w + 1); // 维护的数值仅在根节点编号上有意义，因此以find()函数包裹下标获得根节点的编号 s[find(v)] += s[find(u)]; // 合并连通块，大小相加，其中一个连通块的实际大小为0，恰好也解释了为什么一定需要传入根节点的下标 merge(u, v); // 注意执行顺序！连通块大小更新之后才进行合并 }} 次小生成树 AcWing 1148 秘密的牛奶运输 题目地址：AcWing 1148 题目难度：中等 农夫约翰要把他的牛奶运输到各个销售点。 运输过程中，可以先把牛奶运输到一些销售点，再由这些销售点分别运输到其他销售点。 运输的总距离越小，运输的成本也就越低。 低成本的运输是农夫约翰所希望的。 不过，他并不想让他的竞争对手知道他具体的运输方案，所以他希望采用费用第二小的运输方案而不是最小的。 现在请你帮忙找到该运输方案。 注意： 如果两个方案至少有一条边不同，则我们认为是不同方案； 费用第二小的方案在数值上一定要严格大于费用最小的方案； 答案保证一定有解； 输入格式： 第一行是两个整数 ，表示销售点数和交通线路数； 接下来 行每行 个整数 ，表示销售点 和销售点 之间存在线路，长度为 。 输出格式： 输出费用第二小的运输方案的运输总距离。 数据范围： 可能包含重边 对于非严格次小生成树，我们的求解策略如下： 正常跑一遍 算法得到最小生成树的边权和 。 遍历每个未选进生成树中的边，假设这个边的端节点是 和 ，边权为 ，那么求出生成树中 与 相连的权值最大的边（假设边权为 ）。用这条未选边去替换已有边，新生成树的权值就是 。 重复如上操作，不断对 取最小值。最终得到的最小值就是答案。 当用于替换的边权等于原边权时，最终得到的答案应该是等于 的，因此这个方法只能求解非严格次小生成树。那么对于严格次小生成树，我们的求解策略如下： 得到最小生成树的权值 遍历每一个不在最小生成树内的边，若边的权值 严格大于原图中该两点最大边权 ，则直接替换；否则，若 且新取边的边权严格大于原图中该两点的严格次大边权 ，就用 进行计算。两种情况得到的生成树权值分别为 和 。 重复如上操作，不断取最小值，得到答案。 当数据范围较小时，用 即可求出两点间的最长边权和次长边权。注意到前向星建双向边， 过程中应额外传入父节点编号以免反向搜索导致死循环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;#define N 100010#define M 300010using namespace std;typedef long long ll;struct Graph { int to, ne, w;} graph[M &lt;&lt; 1];struct Edge { int u, v, w; bool inTree;} edges[M];int p[N];int h[N], idx = 0;int dist1[N][N], dist2[N][N];void add(int u, int v, int w) { idx++; graph[idx].to = v; graph[idx].ne = h[u]; graph[idx].w = w; h[u] = idx;}int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x];}void merge(int a, int b) { p[find(a)] = find(b);}bool related(int a, int b) { return find(a) == find(b);}bool cmp(const Edge &amp;l, const Edge &amp;r) { return l.w &lt; r.w;}void dfs(int u, int fa, int max1, int max2, int arr1[], int arr2[]) { arr1[u] = max1; arr2[u] = max2; for (int i = h[u]; ~i; i = graph[i].ne) { int j = graph[i].to; if (j != fa) { int tmp1 = max1, tmp2 = max2; if (graph[i].w &gt; tmp1) tmp1 = graph[i].w, tmp2 = max1; else if (graph[i].w &lt; tmp1 &amp;&amp; graph[i].w &gt; tmp2) tmp2 = graph[i].w; dfs(j, u, tmp1, tmp2, arr1, arr2); } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) p[i] = i; for (int i = 1; i &lt;= m; i++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; edges[i].u = a; edges[i].v = b; edges[i].w = c; edges[i].inTree = false; } sort(edges + 1, edges + 1 + m, cmp); ll st = 0; for (int i = 1; i &lt;= m; i++) { int u = edges[i].u; int v = edges[i].v; int w = edges[i].w; if (!related(u, v)) { merge(u, v); edges[i].inTree = true; st += w; add(u, v, w); add(v, u, w); } } for (int i = 1; i &lt;= n; i++) dfs(i, 0, -INT_MAX, -INT_MAX, dist1[i], dist2[i]); ll ans = INFINITY; for (int i = 1; i &lt;= m; i++) { if (edges[i].inTree) continue; int u = edges[i].u; int v = edges[i].v; int w = edges[i].w; if (w &gt; dist1[u][v]) ans = min(ans, st + w - dist1[u][v]); else if (w &gt; dist2[u][v]) ans = min(ans, st + w - dist2[u][v]); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 对于较大的数据，正确的做法应是 倍增和 。在求解上述 和 的过程中效率更高，会优于 的指数级复杂度。","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"生成树","slug":"生成树","permalink":"https://justpureh2o.cn/tags/%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"端午游记","slug":"dragon-boat-festival-journal","date":"2024-06-09T19:22:52.697Z","updated":"2024-06-09T19:24:01.794Z","comments":true,"path":"articles/39230/","link":"","permalink":"https://justpureh2o.cn/articles/39230/","excerpt":"","text":"又名：端午游寄——三傻大闹写字楼归还充电宝传奇 六月九日，端午假期的第二天。我们班的几名同学聚集到一起，纷纷拿出高三不要的麦当劳高三助力免费兑换券，准备对凤凰大街的麦当劳进行一次蓄谋已久的劫掠。六个人，每个人平分得到了两张券，朵颐了两个汉堡。便是午后，按原定计划，应该是找个台球厅混一下午。然而计划临时有变，有两名新同学约在天府红商场。于是送别三名同学，我、gz和猴子便前往地铁站准备乘地铁前往天府广场。 地铁站里，猴子和gz因为手机电量告急而急需充电。一人借了一个街电，殊不知这将在接下来的游玩途中造成巨大的精神内耗…… 不时便抵达了商场，门口有人在送印了蔡徐坤的小扇子，瞬间吸引了gz的注意。不知世事的三人欣然接受了陌生人的好意，谁知对方画风一转，把我们三人拉到一旁，要求我们拿出手机去关注某个东西。在我们一再追问下，他愣是没说出一个有关关注内容的句子来，只是低着头在微信的各个大群翻找。离谱的大群，群名是清一色溢出屏幕的爱心符号（别在这理发店），我们深感不对……他终于开口了：“你们待会扫一下二维码，是一个邓紫棋的粉丝群，你们进去打个卡……”。“绝对是个脑残，居然要靠拉人进群赚钱。”我如此想到，身体不自觉的想要离开眼前这个怪人。可惜被发现，初次逃离失败。 漫长的五分钟，他仍然没找到二维码。店门口的保安趁着路口红灯，前来提醒我们不要扫码。那人也是经验丰富，拉着猴子往一旁走，趁此机会，和gz交换了个眼神。旋即用干饭般的速度飞进了店门，空留猴子在原地继续周旋 进门后，我和gz便商量营救对策，我给猴子拨打了电话。然而他未接听，幸运的是，他可以从窗纸的空隙处看到我们疯狂地给他暗示。可惜的是，猴子完全陷入了愧疚性消费的心理，被那个粉丝硬控了半天。没有办法，我和gz准备先在一楼溜达一圈。 走到一半，一个矮我一头的、20岁出头的女性叫住我。问我有没有上大学，我骗她我刚考完高考出来玩。她接着套近乎，问我估分多少，我直接自信报数 680。立马把对方吓呆了，直呼“学霸”。很快，她便切入正题，图穷匕见——她说她在完成某个课程的任务，想要挣到学分，请我帮个小忙。我先问问是什么忙，她说是一个子弹头签字笔的推广推销，死活要让我买一盒。gz才发现她是个推销员，在微信上私信我赶紧走。我知道我肯定不会买这么不划算的东西，但是我不知道具体该怎么拒绝，同样深陷愧疚性消费的陷阱之中。好在猴哥此时挣脱束缚，看到我被围住，就是一句话：“对不起”。把我跟gz推走了。 从侧门出来，我们深感世事的险杂。我们沉浸在方才发生的事件的讨论之中，忘了一个重要的事情——充电宝还没还，距离借出已过了一个小时。急急忙忙在地图上寻找充电宝桩，可是近处只有怪兽充电、丝毫不见街电的充电宝桩。此时大家才意识到事情的严峻性。先是跑遍了附近所有的便利店，又下到地铁站里，发现只剩一个全满的桩，又在地下胡乱找店。最终大家冷静了下来，定位到距离不远的某栋写字楼的29楼还有一个带空位的充电宝桩，我们火速前往，急切地要赶在计时两小时之前归还充电宝。 昏暗写字楼里坐了一个保安，他问我们来这里干什么。猴子回答：“还充电宝”，甚至长了个心眼，问了一下29楼是否就是那某某公司。得到肯定答复后，猴子在登记表上写下自己的名字，三人乘电梯前往最终boss场地……经过约五分钟的搜寻，在员工的提醒下，我们绕进办公室一隅，终于发现了朝思暮想的充电宝桩——桩上还有三个孔，够还（还每人白嫖了一杯水喝）。至此，三人才成功在两小时内完成归还充电宝的任务。 劫后余生的三人回到了天府红，这次从一楼开始，陆续转到六楼。gz第一轮买了一个霜星的挂件，猴子和我因为嫌贵没买。很快便粗略转完了商场，大家都很渴，下楼边喝饮料边等另外两名同学的到来。 说来也气，鬼哥半天不来，我们去找他。结果半天找不到人，没有办法，最后还得是他来找我们。gz和猴子放狠话说等看到了他一定冲上去给他一拳…… 接到了人，游览才算是真正开始。我们重新上楼，在三楼路过一家店，眼尖的鬼哥立马发现店里摆着本子的周边，钻进店里。我们跟着进去，店里充斥着雪女等人气角色的周边，鬼哥甚至在这家店里发现了他久寻未果的东方周边。鬼哥瞬间冲动了起来，意欲买雪女的周边，我们的gz同学则是巧舌如簧，三言两语居然把鬼哥劝动了。紧接着在隔壁的店里，gz花30软妹币入手了一件藿藿的小挂件，我在跟他一起排队之余还不忘嘲讽他买亏了，并放出豪言：“超过30的东西我不买” 鬼哥发现一旁有BA的周边，招呼我赶紧去看。他自己挑了一件Cherino的亚克力立牌，比手掌稍长一些，兴冲冲地跑去柜台相应斯大林的召唤。我还在原地，找半天找不到小梓的……鬼哥回来后直接崩溃了，那一个小立牌居然花了他整整五十大洋。“还好我没买，真的太贵了”我如此想到。 时间太晚了，我、gz与猴子分开了：我们准备去负一楼逛、他们上六楼去。负一楼的店东西确实多，而且全。可惜没看到芙宁娜的周边，时间临近下午五点半，我们收拾收拾准备离开。正好，我发现一侧摆放着BA的立牌。而且比三楼那家还全，角色还不一样。顺利地，我找到了小梓的周边。 gz又开始施法，疯狂劝我买下。我向上层货架看去，每层都有、而且一层比一层更戳。最上层的立牌是我最喜欢的，gz极力想要说服我花钱。我简单翻看一下，没看着价格，天真的以为不会超过40块。拿到收银台一扫，65的天价数字摆在面前，gz瞬间露出小人得志的笑容。一狠心还是买了，出店门时手都是抖的……不得不说二次元的钱是真的好赚。接着坐地铁原路返回，可算是结束了一天的行程。","categories":[],"tags":[{"name":"游记","slug":"游记","permalink":"https://justpureh2o.cn/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"闲话杂谈","slug":"闲话杂谈","permalink":"https://justpureh2o.cn/tags/%E9%97%B2%E8%AF%9D%E6%9D%82%E8%B0%88/"}]},{"title":"Floyd 算法——脚踏图论、数学两条船的算法","slug":"algorithm-floyd","date":"2024-06-05T03:05:52.940Z","updated":"2024-06-05T03:05:52.945Z","comments":true,"path":"articles/32645/","link":"","permalink":"https://justpureh2o.cn/articles/32645/","excerpt":"","text":"Floyd 算法简介 Floyd 算法是一种能在 时间复杂度内求出任意两点间最短路长度的多源最短路算法，又称 算法或插点法，以它的发明者命名。Floyd 算法基于动态规划，通过穷举 节点和 节点的所有中继节点 进行松弛操作得到最短路径。对于稠密图，它的执行效率会快于 Dijkstra 和 Bellman-Ford 算法。 在初始建图时。对于邻接矩阵 ， 代表 和 点间的直连最短路径长度，也就是读入时数据告诉你的两点间的边长；剩下没有直接连接的两点间距离设为正无穷。特别地， 需要初始化为 ，因为从自己出发回到自己的边权为零。 在算法运行过程中，假设当前枚举到点 和 ，算法需要枚举中继点 。那么路径 成为最短距离的必要条件是存在边 和 。若当前 ，则将 更新，这一点和 Dijkstra 是类似的。 Floyd 算法的基本模板如下： 1234567for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } }} 只有四层，非常简单。 对于 Floyd 算法，还需注意的一点是它的循环次序问题。如果想一次跑出正确结果，那就需要将中继点枚举放在最外层，也就是最外层是 循环，剩余的循环只需保证在 层内即可，顺序无所谓。而如果是类似于 ikj 次序的循环，那么至多需要两次才能求出正确答案；如果是 ijk 次序，则至多需要求三次。具体参见这篇博客。 Floyd 图论 Floyd 在图论方面有几大重要作用——求无向图最小环、传递闭包。 P6175 无向图最小环问题 题目地址：P6175 题目难度：普及/提高- 给定一张无向图，求图中一个至少包含 个点的环，环上的节点不重复，并且环上的边的长度之和最小。该问题称为无向图的最小环问题。在本题中，你需要输出最小的环的边权和。若无解，输出 No solution.。 输入格式： 第一行两个正整数 表示点数和边数。 接下来 行，每行三个正整数 ，表示节点 之间有一条长度为 的边。 输出格式： 输出边权和最小的环的边权和。若无解，输出 No solution.。 假设有一张图： 当 Floyd 算法枚举到中继节点 时，且存在边 和 。那么环 是有机会成为当前图上的最小环的（注意到图是无向图，若 能到 ，则 一定能到达 ）。若当前环的权值（，注意是边权 ）小于全局最小值，则更新全局最小值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define N 110#define INF 0x3f3f3f3fusing namespace std;typedef long long ll;int n, m;ll g[N][N], dist[N][N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(g, 0x2a, sizeof g); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) g[i][i] = 0; while (m--) { int u, v; ll d; cin &gt;&gt; u &gt;&gt; v &gt;&gt; d; g[u][v] = g[v][u] = min(g[u][v], d); } memcpy(dist, g, sizeof dist); ll ans = LLONG_MAX; for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt; k; i++) { for (int j = i + 1; j &lt; k; j++) { ans = min(ans, dist[i][j] + g[i][k] + g[k][j]); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { dist[i][j] = dist[j][i] = min(dist[i][j], dist[i][k] + dist[k][j]); } } } if (ans &gt;= INF) cout &lt;&lt; \"No solution.\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; return 0;} B3611 [模板] 传递闭包 题目地址：B3611 题目难度：普及/提高- 给定一张点数为 的有向图的邻接矩阵，图中不包含自环，求该有向图的传递闭包。 一张图的邻接矩阵定义为一个 的矩阵 ，其中 到存在直接连边到没有直接连边 一张图的传递闭包定义为一个 的矩阵 ，其中 可以直接或间接到达无法直接或间接到达 输入格式： 输入数据共 行。 第一行一个正整数 。 第 到 行每行 个整数，第 行第 列的整数为 。 输出格式： 输出数据共 行。 第 到 行每行 个整数，第 行第 列的整数为 。 说句闲话，感觉这个传递闭包和并查集路径压缩好像…… 我们在用 Floyd 求最短路时，以 为中继节点进行的松弛操作其实就指明了一个间接到达的关系：“点 可以经过点 间接到达点 ”。因此只需要在 Floyd 内部加入“若存在边 和 ，则将传递闭包 置为 ”。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define N 110using namespace std;int g[N][N];void floyd(int n) { for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (g[i][k] &amp;&amp; g[k][j]) g[i][j] = 1; } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; g[i][j]; } } floyd(n); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cout &lt;&lt; g[i][j] &lt;&lt; ' '; } cout &lt;&lt; endl; } return 0;} P1347 排序 题目地址：P1347 题目难度：普及+/提高 一个不同的值的升序排序数列指的是一个从左到右元素依次增大的序列，例如，一个有序的数列 表示 。在这道题中，我们将给你一系列形如 的关系，并要求你判断是否能够根据这些关系确定这个数列的顺序。 输入格式： 第一行有两个正整数 ， 表示需要排序的元素数量，，第 到 个元素将用大写的 表示。 表示将给出的形如 的关系的数量。 接下来有 行，每行有 个字符，分别为一个大写字母，一个 &lt; 符号，一个大写字母，表示两个元素之间的关系。 输出格式： 若根据前 个关系即可确定这 个元素的顺序 yyy..y（如 ABC），输出 Sorted sequence determined after xxx relations: yyy...y. 若根据前 个关系即发现存在矛盾（如 ），输出 Inconsistency found after x relations. 若根据这 个关系无法确定这 个元素的顺序，输出 Sorted sequence cannot be determined. （提示：确定 个元素的顺序后即可结束程序，可以不用考虑确定顺序之后出现矛盾的情况） 矛盾情况是诸如： 的情况。 我们把所有的小于关系存在一张邻接矩阵里， 所承载的含义就变成了：存在严格小于关系 。那么想要求出所有的大小关系，就需要对每个字母能直接或间接导出的所有字母进行比较判断。这道题就可以用传递闭包来处理每个字母间的推导关系。 由于题目的特殊要求，我们选择每次只读入一个大小关系，然后跑一次传递闭包，再对结果进行判断输出。若传递闭包的对角线元素不全为零，代表存在矛盾，直接跳出；若存在点对 ，使得 ，那么就是一个亚定的关系，需要进一步增加条件，特殊地，若此时已读入所有关系，则输出无解；若对于所有点对 都有 且不存在矛盾，那么就可以输出序列了。 对于序列的升序输出，首先枚举 。 是最小值的充要条件是不存在任何点对 使得 ，即不存在更小的值。在找到最小值后标记一下，重复查找即可得到整个序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;#define N 30using namespace std;int g[N][N], cpy[N][N];bool st[N];int n, m;void floyd() { memcpy(cpy, g, sizeof g); for (int k = 1; k &lt;= n; k++) { for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (cpy[i][k] &amp;&amp; cpy[k][j]) cpy[i][j] = 1; } } }}int check() { for (int i = 1; i &lt;= n; i++) { if (cpy[i][i]) return 1; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt; i; j++) { if (!cpy[i][j] &amp;&amp; !cpy[j][i]) return 0; } } return 2;}char getC() { for (int i = 1; i &lt;= n; i++) { if (!st[i]) { bool flag = true; for (int j = 1; j &lt;= n; j++) { if (!st[j] &amp;&amp; cpy[j][i]) { flag = false; break; } } if (flag) { st[i] = true; return static_cast&lt;char&gt;(i + 'A' - 1); } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); while (cin &gt;&gt; n &gt;&gt; m, n || m) { memset(g, 0, sizeof g); memset(st, false, sizeof st); int t = 0, tmp = 0; for (int i = 1; i &lt;= m; i++) { char s[5]; cin &gt;&gt; s; int a = s[0] - 'A' + 1, b = s[2] - 'A' + 1; g[a][b] = 1; floyd(); t = check(); if (t) { tmp = i; break; } } if (t == 1) cout &lt;&lt; \"Inconsistency found after \" &lt;&lt; tmp &lt;&lt; \" relations.\" &lt;&lt; endl; else if (t == 0) cout &lt;&lt; \"Sorted sequence cannot be determined.\" &lt;&lt; endl; else { cout &lt;&lt; \"Sorted sequence determined after \" &lt;&lt; tmp &lt;&lt; \" relations: \"; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; getC(); cout &lt;&lt; \".\" &lt;&lt; endl; } } return 0;} Floyd 数学 因为 Floyd 算法基于邻接矩阵存图，所以它可以通过矩阵运算来实现一些图上的计数问题。 P2886 [USACO07NOV] Cow Relays G 题目地址：P2886 题目难度：提高+/省选- 给定一张 条边的无向连通图，求从 到 经过 条边的最短路长度。 输入格式 第一行四个正整数 ，意义如题面所示。 接下来 行每行三个正整数 ，分别表示路径的长度，起点和终点。 输出格式： 一行一个整数表示图中从 到 经过 条边的最短路长度。 类比矩阵乘法的定义式：。是不是很像松弛操作时的下标？其实将邻接矩阵乘幂就可以看作枚举可达的两点路径。相应的，在无权图中求诸如“从起点到终点经过 条边的路径总数”就可以将邻接矩阵乘 次幂。但如果是像这道题，是带边权的形式，又该如何操作？ 我们把矩阵乘法重新变成如下的形式： 就可以做了，有点像在矩阵乘幂的同时跑最短路。将上文所说的无权图情况和带权 Floyd 有机结合了起来。加入快速幂可以进一步优化。需要注意的是矩阵的初始化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define N 210using namespace std;typedef long long ll;struct Matrix { ll mat[N][N]; Matrix() { memset(mat, 0, sizeof mat); } void init() { for (int i = 1; i &lt;= N - 1; i++) mat[i][i] = 1; } void zero() { for (int i = 1; i &lt;= N - 1; i++) mat[i][i] = 0; } void inf() { memset(mat, 0x2a, sizeof mat); }};int n, t, S, E;int cnt = 0;Matrix g;Matrix operator*(const Matrix &amp;A, const Matrix &amp;B) { Matrix C; C.inf(); for (int k = 1; k &lt;= t; k++) { for (int i = 1; i &lt;= t; i++) { for (int j = 1; j &lt;= t; j++) { C.mat[i][j] = min(C.mat[i][j], A.mat[i][k] + B.mat[k][j]); } } } return C;}Matrix qpow(Matrix a, int b) { Matrix res; res.inf(); res.zero(); while (b) { if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; } return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; t &gt;&gt; S &gt;&gt; E; g.inf(); map&lt;int, int&gt; mp; mp[S] = ++cnt; mp[E] = ++cnt; S = mp[S], E = mp[E]; for (int i = 1; i &lt;= t; i++) { ll w; int u, v; cin &gt;&gt; w &gt;&gt; u &gt;&gt; v; if (!mp.count(u)) mp[u] = ++cnt; if (!mp.count(v)) mp[v] = ++cnt; u = mp[u], v = mp[v]; g.mat[u][v] = g.mat[v][u] = min(g.mat[u][v], w); } g = qpow(g, n); cout &lt;&lt; g.mat[S][E] &lt;&lt; endl; return 0;} 小结 Floyd 作为一个最短路算法具备了图论和数学计算的双重功能，只是在实际运用中需要留意它 的时间复杂度。对于较大的点数/稀疏图，建议使用 Dijkstra 或 Bellman-Ford；但若是一个稠密图，或者是点数较少，且需要求出一些奇奇妙妙的数据，那么就可以考虑一下 Floyd。","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"图论建模——分层图","slug":"algorithm-layered-graph","date":"2024-05-31T16:56:35.340Z","updated":"2024-05-31T16:56:35.656Z","comments":true,"path":"articles/9131/","link":"","permalink":"https://justpureh2o.cn/articles/9131/","excerpt":"","text":"分层图简介 分层图，顾名思义。是将原图按不同状态分为若干与原图连接方式相同的图层，图层之间以特定方式连接的一类建图方式。如果画成立体图，大概是这样的： 根据如上思路，可以发现分层图有以下的几个性质： 假设原图位于 层，总共有 层图。那么对于任意 ，层 内的节点之间的连接方式与 层是完全相同的（与原图连接方式相同）；但是层与层之间的连接方式不一定相同，具体取决于题意 假设不考虑节点所在层，仅考虑它在原图上对应的编号。假设有一条无向边 ，那么这条边会有大于等于一个权值（图层之间以特定方式连接） 根据性质二，我们大致可以明白分层图的使用范围——当题目中允许对某一条边做有限次的边权更改时即可考虑使用分层图做。在建图方面，根据数据范围的大小大致可以分为两种——离散建边和直观建边。接下来对两种建图方式作简要介绍。 分层图建图 离散建图 优点：细节较少、代码量短 缺点：对于大部分图论的数据范围容易爆空间、离散化有时不够直观 空间（最劣情况）：数组均为一维。对于前向星，无向存边数组为 （ 层与原图相同的边，各层每个点间互相连了一条双向边，有向边则折半）；对于前向星的头数组，需要 的空间（ 层，每层 个点），最短路长度的记录数组和节点判重数组同上。 这种建图方法相当于将所有的图存在同一维数组上。假设原图共 个节点，且原图为第 层，那么对于原图上编号为 的点，它在第 层上的对应点的编号就应是 。至此我们就得到了分层图节点之间的映射关系。 在建图时，我们只需要在读入时处理连边即可。前向星存图和最短路算法都是模板，直接写就好。 123456789101112while (m--) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; for (int i = 0; i &lt;= k; i++) { add(a + i * n, b + i * n, c); // 在当前层之内连正常边权的双向边 add(b + i * n, a + i * n, c); if (i &lt; k) { add(a + i * n, b + (i + 1) * n, c / 2); // 当前层和下一层直接互相连一条特定边权的双向边（此处为边权折半的情况） add(b + i * n, a + (i + 1) * n, c / 2); } }} 直观建图（推荐） 优点：一般不会爆空间、当前节点的信息明确、直观易懂 缺点：数组是二维的，代码量较长、需要注意部分细节 空间（最劣情况）：一维无向图前向星数组，大小为 ，头数组如上；最短路记录数组、判重数组为二维，第一维 、第二维 。 这种建图方式是最保险的，空间超限的概率相比上边那个要小，而且层数信息的传递也较直观。建议使用这个方法存图。 读入时只需建立层内边即可，若需要实现层与层之间的转化，只需要在最短路算法里判断即可。因而空间是大幅度节省的。我们只需对最短路进行一番修改即可： 12345678910111213for (int i = h[id]; ~i; i = edges[i].ne) { int j = edges[i].to; if (dis + edges[i].w &lt; dist[j][layer]) { // 当前层内，正常的最短路 dist[j][layer] = dis + edges[i].w; q.push((PIII) {dist[j][layer], (PII) {j, layer}}); } if (layer &lt; k &amp;&amp; dis + edges[i].w / 2 &lt; dist[j][layer + 1]) { // 如果下一层的点可更新，那么转移到下一层 dist[j][layer + 1] = dis; q.push((PIII) {dist[j][layer + 1], (PII) {j, layer + 1}}); }} 分层图典例 洛谷 P4822 [BJWC 2012] 冻结 题目地址：P4822 题目难度：提高+/省选- 题目来源：北京 2012 题目背景： “我要成为魔法少女！” “那么，以灵魂为代价，你希望得到什么？” “我要将有关魔法和奇迹的一切，封印于卡片之中„„” 在这个愿望被实现以后的世界里，人们享受着魔法卡片（SpellCard，又名符卡）带来的便捷。 现在，不需要立下契约也可以使用魔法了！你还不来试一试？ 比如，我们在魔法百科全书（Encyclopedia of Spells）里用“freeze”作为关键字来查询，会有很多有趣的结果。 例如，我们熟知的 Cirno，她的冰冻魔法当然会有对应的 SpellCard 了。当然，更加令人惊讶的是，居然有冻结时间的魔法，Cirno 的冻青蛙比起这些来真是小巫见大巫了。 这说明之前的世界中有很多魔法少女曾许下控制时间的愿望，比如 Akemi Homura、Sakuya Izayoi、…… 当然，在本题中我们并不是要来研究历史的，而是研究魔法的应用。 题目描述： 我们考虑最简单的旅行问题吧： 现在这个大陆上有 个城市， 条双向的道路。城市编号为 ~ ，我们在 号城市，需要到 号城市，怎样才能最快地到达呢？ 这不就是最短路问题吗？我们都知道可以用 Dijkstra、Bellman-Ford、Floyd-Warshall等算法来解决。 现在，我们一共有 张可以使时间变慢 50%的 SpellCard，也就是说，在通过某条路径时，我们可以选择使用一张卡片，这样，我们通过这一条道路的时间 就可以减少到原先的一半。需要注意的是： 在一条道路上最多只能使用一张 SpellCard。 使用一张SpellCard 只在一条道路上起作用。 你不必使用完所有的 SpellCard。 给定以上的信息，你的任务是：求出在可以使用这不超过 张时间减速的 SpellCard 之情形下，从城市 到城市 最少需要多长时间。 输入格式： 第一行包含三个整数：、、。 接下来 行，每行包含三个整数：、、，表示存在一条 与 之间的双向道路，在不使用 SpellCard 之前提下，通过它需要 的时间。 输出格式： 输出一个整数，表示从 号城市到 号城市的最小用时。 数据范围： 对于 的数据，保证： ，。 ，。 为保证答案为整数，保证所有的 均为偶数。 所有数据中的无向图保证无自环、重边，且是连通的。 这道题的数据范围较小，可以考虑使用离散建图。根据先前分析的空间，存边数组大概在 左右，其他的数组大概在 左右。具体可以自行代值计算。 答案的结果就是对第 层的终点的长度值取最小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#define N 55#define M 1010#define K 51using namespace std;typedef pair&lt;int, int&gt; PII;struct Edge { int to, ne, w;} edges[((K + 1) * M + K * N * N) &lt;&lt; 1];int n, m, k;int h[N * M], idx = 0;int dist[N * M];bool st[N * M];void add(int u, int v, int w) { idx++; edges[idx].to = v; edges[idx].ne = h[u]; edges[idx].w = w; h[u] = idx;}void dijkstra() { priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt; &gt; q; q.push((PII){0, 1}); dist[1] = 0; while (!q.empty()) { PII p = q.top(); q.pop(); int id = p.second; int dis = p.first; if (st[id]) continue; st[id] = true; for (int i = h[id]; ~i; i = edges[i].ne) { int j = edges[i].to; if (dis + edges[i].w &lt; dist[j]) { dist[j] = dis + edges[i].w; q.push((PII){dist[j], j}); } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); memset(dist, 0x3f, sizeof dist); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; while (m--) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; for (int i = 0; i &lt;= k; i++) { add(a + i * n, b + i * n, c); // 在当前层之内连正常边权的双向边 add(b + i * n, a + i * n, c); if (i &lt; k) { add(a + i * n, b + (i + 1) * n, c / 2); // 当前层和下一层直接互相连一条边权减半的双向边 add(b + i * n, a + (i + 1) * n, c / 2); } } } dijkstra(); int ans = 0x3f3f3f3f; for (int i = 0; i &lt;= k; i++) { ans = min(ans, dist[n + i * n]); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 洛谷 P4568 [JLOI 2011] 飞行路线 题目地址：P4568 题目难度：提高+/省选- 题目来源：各省省选 吉林 2011 Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 个城市设有业务，设这些城市分别标记为 到 ，一共有 种航线，每种航线连接两个城市，并且航线有一定的价格。 Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？ 输入格式： 第一行三个整数 ，分别表示城市数，航线数和免费乘坐次数。 接下来一行两个整数 ，分别表示他们出行的起点城市编号和终点城市编号。 接下来 行，每行三个整数 ，表示存在一种航线，能从城市 到达城市 ，或从城市 到达城市 ，价格为 。 输出格式： 输出一行一个整数，为最少花费。 数据范围： 对于 的数据，，，。 对于 的数据，，，。 对于 的数据，，，，，，。 另外存在一组 hack 数据。 如果继续用离散建图的话…… （危） 交上去绝对会吃一发 RE…… 因此改用直观建图，改之后的存边数组在 左右，其他的数组基本上都是小于十万的。可以放心食用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define N 10010#define M 50010#define K 11using namespace std;typedef pair&lt;int, int&gt; PII;typedef pair&lt;int, PII&gt; PIII;struct Edge { int to, ne, w;} edges[M * K &lt;&lt; 1];int h[N * K], idx = 0;int n, m, k, S, T;int dist[N][K];bool st[N][K];void add(int u, int v, int w) { idx++; edges[idx].to = v; edges[idx].ne = h[u]; edges[idx].w = w; h[u] = idx;}void dijkstra() { priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;&gt; &gt; q; q.push((PIII){0, (PII){S, 0}}); dist[S][0] = 0; while (!q.empty()) { PIII t = q.top(); q.pop(); int id = t.second.first; int dis = t.first; int layer = t.second.second; if (st[id][layer]) continue; st[id][layer] = true; for (int i = h[id]; ~i; i = edges[i].ne) { int j = edges[i].to; if (dis + edges[i].w &lt; dist[j][layer]) { // 当前层内，即不使用免费机会 dist[j][layer] = dis + edges[i].w; q.push((PIII) {dist[j][layer], (PII) {j, layer}}); } if (layer &lt; k &amp;&amp; dis &lt; dist[j][layer + 1]) { // 使用免费特权，转移到下一层 dist[j][layer + 1] = dis; q.push((PIII) {dist[j][layer + 1], (PII) {j, layer + 1}}); } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); memset(dist, 0x3f, sizeof dist); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; S &gt;&gt; T; while (m--) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; for (int i = 0; i &lt;= k; i++) { add(a, b, c); add(b, a, c); } } dijkstra(); int ans = 0x3f3f3f3f; for (int i = 0; i &lt;= k; i++) { ans = min(ans, dist[T][i]); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 双倍经验：P2939","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/tags/oi%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路算法","slug":"最短路算法","permalink":"https://justpureh2o.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/"}]},{"title":"[奇技淫巧] 矩阵行列式瞬秒立体图形体积计算","slug":"determinant-and-volume","date":"2024-05-18T05:12:22.604Z","updated":"2024-05-24T05:33:35.757Z","comments":true,"path":"articles/42897/","link":"","permalink":"https://justpureh2o.cn/articles/42897/","excerpt":"","text":"行列式概念&amp;几何意义 行列式最初作为判断某个方程组是否有解的依据被人们使用，记作 ，有时也用形如 的式子来表示这个矩阵的行列式的值。类比一元二次方程的 判别式——我们定义，当矩阵 的行列式的值为零时，该矩阵方程组无解，即 时方程组无解。 对于一个矩阵，它的行列式计算方式为按行/按列余子式递归展开。何为余子式？来看一个例子： 例如矩阵 ，其余子式 定义为删去元素 所在行和列的所有元素后原矩阵余下部分组合成的新矩阵。在本例中，我们删去第一行和第二列（ 所在行与列），得到 ；类似地，。 方阵的行列式的计算公式在下面给出： 当矩阵通过余子式的递归化为二阶时，行列式可以直接用主对角线元素的乘积减去副对角线元素的乘积得到。即对于 方阵 ，。根据公式，行列式可能出现负数，但只要行列式非零，方程组就是有解的。 而在几何方面，行列式用来描述一个线性变换对体积造成的影响。空说无凭，我们先找一个简单的 方阵来演练一下： 假设两个不共线、共起点的二维向量分别是 和 ，它们围成的平行四边形如下图： 假设 ，那么 用向量代入，得： 当我们把两个向量以如下的形式放入一个矩阵中，奇迹发生了： 此时 。平行四边形的面积就是这个矩阵的行列式的绝对值！ 平面图形的面积 事实上，上面介绍的行列式实际上计算的是给定向量围成的图形的面积。对于两个不共线、共起点向量，它们会围成一个平行四边形，而它的面积可以直接由 （行列式的绝对值）计算得来。 那如果是一个三角形呢？ 发现三角形恰好占据平行四边形的一半空间，面积就刚好是整个平行四边形的一半，因此 。 的面积同理，。 如果是一个正六边形： 可以发现一个正六边形是由三个这样的平行四边形组合得到的，因此 。对于平面图形的面积计算，重点在于找到组成这个图形的单位平行四边形，找到后直接用行列式乘以响应倍数即可。 立体图形 我们首先从三棱锥开始。不难想象，三个不共线、共起点的三维向量会围成一个平行六面体。那么这个三棱锥放在这个平行六面体中，它会占据平行六面体恰好 的体积，如下图： 三个相同的三棱锥恰好占掉这个平行六面体一半的体积，那么三棱锥的体积就是整个平行六面体的六分之一。根据前文所述，我们把围成这个平行六面体的三个三维向量排成一个 方阵 。三棱锥的体积就是 。 例题演练 例 4.1（《步步高一轮复习83练 2024人教A版》P355 T6） 在正四棱锥 中，， 分别为 的中点，直线 与 所成角的余弦值为 ，则三棱锥 的体积为？ 这道题来自于我一轮复习学案里的某道题目，当时用常规方法算半天就是有一个小三棱锥体积算不出来，导致这道题做（蒙）错了。现在用线性代数来解就非常轻松快速了。 给出题图： 总结一下，我们只需要知道某个几何体的一组共起点、不共线的边向量，就可以算出这个几何图形的面积/体积，所需向量的数量和图形的维度是一致的。","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"高中数学","slug":"高中数学","permalink":"https://justpureh2o.cn/tags/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6/"}]},{"title":"IDA* ——启发式迭代加深搜索算法","slug":"IDA-star-algorithm","date":"2024-05-17T05:00:04.284Z","updated":"2024-05-29T00:40:56.966Z","comments":true,"path":"articles/30383/","link":"","permalink":"https://justpureh2o.cn/articles/30383/","excerpt":"","text":"A-star，迭代加深搜索以及 IDA-star 我们先前在 这篇文章 中探讨了 A* 算法以及其实现思路。回顾一下，A* 算法为普通的搜索算法加上了一个名为估价函数的设置，使得 A* 能够在搜索时不会那么偏离正确答案（最短路径）。从而大幅改善了普通 BFS 的近似穷举的低效策略。 而迭代加深就有些“取巧”了。万一某一天，你碰到了一位出生很有底子的出题人。他出了一道搜索题，但是他故意设置了很多很深很深的子树用来卡你的 BFS 和 A，这时你发现答案往往都在浅层，那么先前你的算法在深子树上做的一切工夫不就全白费了吗？于是迭代加深搜索应运而生，它限制每次搜索的最大深度，每次只从根节点开始向下搜索对应层数，若没找到答案，则继续加大最大深度；若找到了位于浅层的答案，直接返回，效率就会比普通的 BFS 与 A 快不少。 而 IDA* 则是它的改进版，其中 ID 指 Iterative Deepening，即迭代加深。因此 IDA* 又叫做“迭代加深的 A* 算法”（启发式迭代加深搜索）。顾名思义，它将二者有机结合起来。每次限定一个最大深度向下搜索，配合来自 A* 的估价函数进行最优性剪枝，进一步提效。简直不要太爽。 迭代加深的执行效率 有些人会问，每次加大迭代层数，程序都会从根节点重新开始扫描，那岂不是浪费了很多效率？ 我们先从一个简单的完全二叉树开始分析： 根据完全二叉树的性质，搜素第一层需要扫描 个节点（根节点）；第二层则需要扫描 个节点；第三层是 个……以此类推，第 层就是 个。根据等比数列的求和公式，搜索 次，总共搜索了 个节点（包含重复搜索）——其中前 次的节点数共 个，约为总数的一半。然而，实际题目中可能出现三叉树、四叉树等等多叉的树形结构。假设利用迭代加深思想搜索一颗满 叉树，并令最大层数由 迭代到 一共需要搜索的节点数为 个（重复搜索也计入），那么随着 的增大， 的值将越来越小，也就是说前面 层搜索的复杂度在第 次搜索的复杂度面前就相形见绌了，即 。迭代加深搜索的复杂度基本和搜索 层的复杂度相差无几，因此以上的担心是没必要的。 典型例题 洛谷 P10488 Booksort 题目传送门：这里 题目难度：普及/提高+ 给定 本书，编号为 。 在初始状态下，书是任意排列的。 在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。 我们的目标状态是把书按照 的顺序依次排列。 求最少需要多少次操作。 输入： 第一行包含整数 ，表示共有 组测试数据。 每组数据包含两行，第一行为整数 ，表示书的数量。 第二行为 个整数，表示 的一种任意排列。 同行数之间用空格隔开。 输出： 每组数据输出一个最少操作次数。 如果最少操作次数大于或等于 次，则输出 5 or more。 每个结果占一行。 数据范围 我们从什么地方看出需要使用 IDA*？首先，搜索空间较大：根据数据范围，书本最多有 本，每次可以选择 本任意插入其他位置，运用插空法，最大可能的状态总数就是 ，严重超限；第二就是答案的位置浅：根据题目，当移动次数大于等于 时就可以直接特判退出了，因此我们只需要在前 层寻找答案即可。 既然是 IDA*，我们就需要设计估价函数。因为最终需要排成上升序列，每次操作最多更改一个地方的单调性。因此遍历给定的序列，当某个元素的后继节点不在本来的位置（表现为 ）时累加估价，返回即可。 对于状态搜索，考虑枚举每次移动的段的长度，然后在该段末尾至整个序列末尾的可插入位置中枚举段插入的位置，通过模拟得到插入后的序列即可。注意要及时恢复现场！ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 20using namespace std;typedef long long ll;int n;int a[N], cpy[5][N];int f() { int res = 0; for (int i = 1; i &lt; n; i++) { if (a[i] + 1 != a[i + 1]) res++; } return (int) ((res + 2) / 3);}void out() { for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; endl;}bool ida(int now, int max_d) { if (now + f() &gt; max_d) return false; if (!f()) return true; for (int len = 1; len &lt;= n; len++) { // 段长度 for (int j = 1; j &lt;= n - len + 1; j++) { // 段起始下标 int seg_end = len + j - 1; // 段终止下标 for (int k = seg_end + 1; k &lt;= n; k++) { // 插入到下标k的元素后面 memcpy(cpy[now], a, sizeof a); int y = j; for (int x = seg_end + 1; x &lt;= k; x++, y++) a[y] = cpy[now][x]; for (int x = j; x &lt;= seg_end; x++, y++) a[y] = cpy[now][x]; if (ida(now + 1, max_d)) return true; memcpy(a, cpy[now], sizeof cpy[now]); } } } return false;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int dep = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; while (!ida(0, dep) &amp;&amp; dep &lt; 5) dep++; if (dep == 5) cout &lt;&lt; \"5 or more\" &lt;&lt; endl; else cout &lt;&lt; dep &lt;&lt; endl; } return 0;} UVA 1343 The Rotation Game (旋转游戏) 题目传送门：这里 题目难度：提高+/省选- 如图 所示，有一个 “#” 形的棋盘，上面有 三种数字各 个。给定 种操作，分别为图中的 。这些操作会按照图中字母与箭头所指明的方向，把一条长度为 的序列循环移动 个单位。例如下图最左边的 “#” 形棋盘执行操作 时，会变为图中间的 “#” 形棋盘，再执行操作 后会变为图中最右边的 “#” 形棋盘。 现给定一个初始状态，请使用最少的操作次数，使 “#” 形棋盘最中间的 个格子里的数字相同。 图1 输入格式： 输入包括不超过 组测试数据。每个测试数据只包括一行，包含 个整数，每相邻两个整数之间用 个空格隔开，表示这个 “#” 形棋盘的初始状态。（这些整数的排列顺序是从上至下，同一行的从左至右。例如 表示图 最左边的状态。）每两组测试数据之间没有换行符。输入文件以一行 结束。 输出格式： 对于每组测试数据，输出两行。第一行用字符 输出操作的方法，每两个操作字符之间没有空格分开，如果不需要任何步数，输出 No moves needed。第二行输出最终状态中最中间的 个格子里的数字。如果有多组解，输出操作次数最少的一组解；如果仍有多组解，输出字典序最小的一组。任意相邻两组测试数据的输出之间不需输出换行符。 这道题同样具有巨大的搜索空间，它的合法操作都有整整八种；但是答案可能位于较浅的层，具体表现在——每种操作若进行 次，那么就相当于执行它的反操作一次，显然没有必要以小换大，应用到八种操作里，就是答案层数不会超过 。因此可以以这点为硬限制进行迭代加深搜索。 观察到题目要求我们输出字典序最小的合法方案，只需要在搜索时按字典顺序循环搜索就好。对于剪枝，若上一次操作是将第三行整体向左滚动，那么当前层就显然不能将这一层向右滚动（滚了个寂寞）因此在函数签名里加上一个记录上一次操作的变量即可。 读入时为了直观（切合图中的结构），我选择使用二维数组存储 个数字，但这也带来了不小的代码量（逆天条件判断，我一开始用 switch 语句代码更长）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;#define N 10using namespace std;int a[N][N], cpy[55][N][N];char seq[55];int f() { int cnt[4]; memset(cnt, 0, sizeof cnt); for (int i = 3; i &lt;= 5; i++) cnt[a[3][i]]++, cnt[a[5][i]]++; cnt[a[4][3]]++, cnt[a[4][5]]++; return 8 - max(max(cnt[1], cnt[2]), cnt[3]);}bool check() { int piv = a[3][3]; return (a[3][4] == piv &amp;&amp; a[3][5] == piv &amp;&amp; a[4][3] == piv &amp;&amp; a[4][5] == piv &amp;&amp; a[5][3] == piv &amp;&amp; a[5][4] == piv &amp;&amp; a[5][5] == piv);}void vertical_scroll(bool lCol, bool up) { if (lCol) { if (up) for (int i = 1; i &lt; 7; i++) swap(a[i][3], a[i + 1][3]); else for (int i = 7; i &gt; 1; i--) swap(a[i][3], a[i - 1][3]); } else { if (up) for (int i = 1; i &lt; 7; i++) swap(a[i][5], a[i + 1][5]); else for (int i = 7; i &gt; 1; i--) swap(a[i][5], a[i - 1][5]); }}void horizontal_scroll(bool uRow, bool left) { if (uRow) { if (left) for (int i = 1; i &lt; 7; i++) swap(a[3][i], a[3][i + 1]); else for (int i = 7; i &gt; 1; i--) swap(a[3][i], a[3][i - 1]); } else { if (left) for (int i = 1; i &lt; 7; i++) swap(a[5][i], a[5][i + 1]); else for (int i = 7; i &gt; 1; i--) swap(a[5][i], a[5][i - 1]); }}void operate(char op) { switch (op) { case 'A': case 'B': case 'E': case 'F': vertical_scroll((op == 'A' || op == 'F'), (op == 'A' || op == 'B')); break; default: horizontal_scroll((op == 'C' || op == 'H'), (op == 'H' || op == 'G')); break; }}bool ida(int now, int max_dep, char last) { if (now + f() &gt; max_dep) return false; if (check()) return true; for (int i = 0; i &lt;= 7; i++) { if (now &amp;&amp; last != '\\0') { if (last == 'A' &amp;&amp; i == 5) continue; if (last == 'F' &amp;&amp; i == 0) continue; if (last == 'B' &amp;&amp; i == 4) continue; if (last == 'E' &amp;&amp; i == 1) continue; if (last == 'C' &amp;&amp; i == 7) continue; if (last == 'H' &amp;&amp; i == 2) continue; if (last == 'D' &amp;&amp; i == 6) continue; if (last == 'G' &amp;&amp; i == 3) continue; } memcpy(cpy[now], a, sizeof a); operate((char) (i + 'A')); seq[now] = (char) (i + 'A'); if (ida(now + 1, max_dep, (char) (i + 'A'))) return true; memcpy(a, cpy[now], sizeof cpy[now]); } return false;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int x = 0, cnt = 0; while (cin &gt;&gt; x &amp;&amp; x) { cnt++; if (cnt == 25) { cnt = 1; memset(seq, 0, sizeof seq); } if (cnt == 1) a[1][3] = x; else if (cnt == 2) a[1][5] = x; else if (cnt == 3) a[2][3] = x; else if (cnt == 4) a[2][5] = x; else if (cnt == 12) a[4][3] = x; else if (cnt == 13) a[4][5] = x; else if (cnt == 21) a[6][3] = x; else if (cnt == 22) a[6][5] = x; else if (cnt == 23) a[7][3] = x; else if (cnt == 24) a[7][5] = x; else if (cnt &gt;= 5 &amp;&amp; cnt &lt;= 11) a[3][cnt - 4] = x; else if (cnt &gt;= 14 &amp;&amp; cnt &lt;= 20) a[5][cnt - 13] = x; if (cnt == 24) { if (check()) cout &lt;&lt; \"No moves needed\" &lt;&lt; endl; else { int dep = 1; while (!ida(0, dep, '\\0') &amp;&amp; dep &lt; 50) dep++; cout &lt;&lt; seq &lt;&lt; endl; } cout &lt;&lt; a[3][3] &lt;&lt; endl; } } return 0;}","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"搜索算法","slug":"搜索算法","permalink":"https://justpureh2o.cn/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"[奇技淫巧] 路径组合计数问题的线性递推解法","slug":"dp-in-math-combination","date":"2024-05-15T02:53:50.744Z","updated":"2024-05-17T04:59:32.464Z","comments":true,"path":"articles/12687/","link":"","permalink":"https://justpureh2o.cn/articles/12687/","excerpt":"","text":"Prev 0. 引入 试看如下例题： 假设某小区的道路组成了一个 的网格结构（每条路就是一条横向或纵向排列的线段），小明住在网格左下角的 处，他想到达网格右上角的 处拜访好友。若小明采取最短路径移动，那么请问总共有多少条可能的路径？ 非常明显，这是一道组合数的题目。根据题目条件，很容易知道最短路径的长度是 ，即只向右或向上走到终点。那么总共的路径条数就是“从总共的 步中选出 步向右（或选出 步向上）的总组合数”，答案就是 条（或 条）。 但是，如果我们将方格稍作改动，变成如下的形式： 就很欢愉了~ 接下来讨论用线性 DP 的思想（线性递推）来解决包括以上两道经典例题以内的路径计数问题。 Div 1. 线性递推 开始之前先对“最佳路径”进行一个简单的定义：从给定终点到给定终点的最短路径；并定义“ 最佳路径”为从给定起点开始，经过点 ，到达给定终点的最佳路径。 这里的线性递推指的是由先前已知的状态，通过特定的计算方式得出当前状态的过程。在此类问题中表现为“用只走一步就可转移到当前格点的前驱格点的路径总数进行加法运算得到从起点开始并以当前格点为终点的路径总条数（满足路径为最佳路径）”。 空说比较晦涩，我们以上一节的第一个题为例实操一下： 例 1.1 问从 点到 点的最佳路径总数是多少？ 刚刚我们已经从组合数角度探讨了本题的解法。接下来从线性递推的角度思考这道题。 考虑到“最佳路径”的定义，小明每次只能从某个格点移动到它上边或者是右边的点，换句话说：对于某个点（起点除外），小明只能从它左侧（最左一列除外）或者是下边（最下一行除外）相邻的点走过来。那么以当前点为终点的最佳路径条数就是左侧点的最佳路径条数与下边点的最佳路径条数之和。如此递推到 点，就可以求出答案。 考虑到有一些特殊点（最左边一列、最下边一行），由于这一列/行的点只能由起点沿一条直线走过来，所以这些点的最佳路径总数都是 。有了初始值，我们就可以依次递推了。特殊地，我们把起点的最佳路径总数设为 。递推结果如下图： 右上角的 就是答案，不难发现，除开上述特殊位置外，每个点的最佳路径总数就是它左边点和下边点的最佳路径之和。相比于普通的组合数法，这个方法在网格规模较大时计算次数较多（因为必须要枚举网格上 个点，除去特殊位置也有 个普通点）；但优点是计算量小（仅使用了加法）、无需重复计算。大家可以根据考题数据来选用合适的方法。 接下来探讨求有限制的最佳路径问题。 例 1.2 求由 到 经过点 的最佳路径条数 这个问题可以分割为两个部分——从 到 、以及从 到 。对于前一个子问题，我们只需要将递推进行到点 即可， 的最佳路径条数共 条；接下来，把 作为新起点， 作为新终点，此时 的最佳路径条数是 条，根据分布乘法原理， 的总最佳路径条数为 我还能说什么呢，曼巴出去。 如果用组合数原理求解，也是需要分解成上述两个子问题，计算起来就是 。 Div 2. 缺刻网格 缺刻简直是学生物学的（确信） 我们接着来解决刚才提到的另一个网格路径计数问题： 例 2.1 求出从 点到 点的最佳路径总数 这个网格不再是一个完整的网格，而是缺了一角。放在生活中也很常见，道路维修之类的……接下来先探讨组合数解法（考纲内解法）。 首先，最短路径肯定是 步（），但是这里绝对不是简简单单的 或者 了。当小明从 点出发向右移动一格后，留给他的选择就只有朝上了。那么正难则反，用反向法求解。 如果这个网格是一个完整的网格，那么就是 条最佳路径。如图，有两个点不能走，减去经过这两个点的最佳路径总数，也就是 。接下来，由于去除了两个方格，空缺处上边的两个点显然是不能直接从下边走上去的，需要减掉 。除此之外，还有一条从 点出发，向右走两格（到达被删去的点之一），向上走一格，再向右走一格到达右下角点的路径，显然也是不合法的，再减去。因此答案是 条。 大家可以发现，当网格被删去了某些点时，整个问题从组合数的角度考虑，就会增添巨大的思维量。在我看来，线性递推法能够在保证做到基本不出错的情况下，将这种题的推算时间压缩到一分钟内。在考场上就表现为有更多的时间死扣一道圆锥曲线的多选/填空/大题，并且线性递推的思维含量不高，能学会还是很赚的。 线性递推过程如下： 为什么缺刻部分的点的初始值是 呢？其实在我们推出红色的 后，才能推出后面黑色的 ，缺刻可以看做最佳路径总数为 的点（没有路径可以经过），根据我们上一节讲过的“左+下”原则，黑色的 就可以求出了。 本人亲测做题时间为 ，我甚至还没从四楼教室跑到食堂。 例 2.2 求出最佳路径条数 如果你学会了线性递推法，那么像这种中心缺刻网格你也能轻松切掉。递推过程如下图：","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"高中数学","slug":"高中数学","permalink":"https://justpureh2o.cn/tags/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6/"}]},{"title":"JetBrains CLion IDE 调教指南","slug":"clion-configuration","date":"2024-05-04T19:12:51.390Z","updated":"2024-05-04T22:41:13.142Z","comments":true,"path":"articles/58581/","link":"","permalink":"https://justpureh2o.cn/articles/58581/","excerpt":"","text":"CLion CLion 是一款在 IntelliJ 基础上开发的面向 C/C++ 的跨平台 IDE，它内置的许多智能模块和工具能够提升开发者 的开发效率、同时还使用智能编辑器提高代码质量、重构效率，其深度整合的 CMake 编译系统也能够帮助开发者高效的进行开发工作。 官方 下载地址 官方版有30天的试用期，如果用 edu 教育邮箱注册账号是可以获得免费下载的资格的。因为我基本都在学校里刷题，学校的机器又设置了自动还原，因此不需要担心30天试用期的问题。如果是普通用户，可以考虑下载 Eval Reset 插件实现试用期重置的功能，这里就不介绍了。 因为 CLion 是专门为项目开发设计的 IDE，与 VS Code、Dev C++ 相比，CLion最大的优势就在于对于长且复杂代码的快速分析、文件/函数/变量的依赖关系、实时查错/代码补全、以及友好的调试系统严厉批评 DEV 的垃圾调试系统。但这样也会带来一些不便，例如整个项目中只能出现一个主函数。接下来就介绍如何把 CLion 从项目开发工具调教成为广大 OIer 高效刷题的利器。 截至当前（2024.5.5），CLion 的最新版本为 2024.1.1，请注意文章时效性。 单文件编译 首先转到设置“Settings - Build, Execution, Deployment - CMake”，并勾选“Reload CMake project...”选项。这个设置允许 IDE 在 CMakeList.txt 修改后自动重新加载整个项目。 然后在新建的项目里找到 CMakeLists.txt 文件，把文件末尾的 add_executable(...) 全部删除，替换为如下的代码段： 123456file (GLOB files *.cpp)foreach (file ${files}) string(REGEX REPLACE \".+/(.+)\\\\..*\" \"\\\\1\" exe ${file}) add_executable (${exe} ${file}) message (\\ \\ \\ \\ --\\ src/${exe}.cpp\\ will\\ be\\ compiled\\ to\\ bin/${exe})endforeach () 这是官方提供的解决一个项目内只能同时存在一个主函数的方案，加入这段代码后，CMake 会遍历源工作目录（包括多级子目录）下的所有 C++ 源文件，并单独编译生成对应的可执行文件。 如果你没有勾选开头所说的选项，那么就需要在文件结构浏览器里右键项目文件夹，并选择“Reload CMake Project”，稍等片刻即可重新加载完毕。 新建文件时，在弹出的新建提示框中取消勾选“Add to targets”一项，此后新建的所有 C++ 源文件都不需要进行此操作。即可完全实现像 DEV 那样文件独立编译运行的功能。 键位设置 转到设置“Settings - Keymap”。在“MainMenu - Run - Run/Debug”下找到 Run，双击并选择“Add Keyboard Shorcut”，直接在弹出的提示框里按下你想要设置的按键，点击“OK”保存设置即可更改运行文件的快捷键。 调试键位：在 Keymap 的“MainMenu - Run - Run/Debug”下 注意：若当前源文件从未编译，则需要手动转到该文件的主函数，点击一旁的绿色箭头运行；在此之后如果想运行其他的文件，则需要在顶部的选项卡里选择对应的源文件名 IDE 背景图 在设置“Settings - Appearance &amp; Behavior - Appearance”里下滑找到“UI Options”里的“Background Image...”按钮，点击“Image”文本框旁边的浏览图片按钮就可以自选背景图了。支持调节背景图的透明度、以及一些其他的功能。 代码/文件模板 如果在敲代码时输入 for，你会发现有一个这样的选项： 点击回车，CLion 会自动置入一段标准的 for 循环代码： 可以发现编辑器在一些地方放上了可供更改的快捷区块，按 tab 可以快速切换这些块，并且可以在所有块更改完毕后跳进大括号内方便书写循环体内部的代码。 如要设置自定义内容（例如I/O重定向），可以转到设置“Settings - Editor - Live Templates”，点击加号添加一个模板： 在“Abbreviation”里填入触发缩写；“Description”是描述；“Expand with”里的值是可编辑区域相互跳转的快捷键。在设置时需要点击下边的“Change”，在弹出的选项卡里选择 C++，此处是定义了一个语句模板，因此选择“Statement”选项；点击“Edit Variables”还可以对标为紫色的变量进行进一步设置。完成后点OK保存即可在代码里快捷使用了。 在 DEV C++ 的设置里可以编辑缺省源文件，在每次新建源文件时就会自动填入，省去了打头文件的不便。接下来介绍在 CLion 中设置缺省源的方式。 转到设置“Settings - Editor - File and Code Templates”，同样是点击加号新建模板，“Name”中填入源名称，“Extension”保持 .cpp 不变，然后在输入框里填入如下文本： 12345678#[[#include]]# &lt;bits/stdc++.h&gt;using namespace std;int main() { // TODO return 0;} 点击OK保持，在新建文件时，找到和你刚刚设置的“Name”相同的项，即可新建你的自定义代码模板： 插件推荐 Rainbow Brackets：半付费，中国用户有打折优惠（若安装了 Eval Reset 则部分试用功能无法使用）；能够将代码里的不同层级的括号用不同颜色高亮 Chinese (Simplified) Language Pack/中文语言包：官方免费，将界面换成中文（但是有不少地方汉化没做好，而且中文字体显示也不是很好看，建议能看得懂就尽量用英文原版）","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"https://justpureh2o.cn/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"[闲话杂谈] 梗集合","slug":"memes","date":"2024-05-02T21:49:36.567Z","updated":"2024-08-30T03:48:27.859Z","comments":true,"path":"articles/19117/","link":"","permalink":"https://justpureh2o.cn/articles/19117/","excerpt":"","text":"成都东辰信竞生现状 多峰函数，模拟退火 增广搜索，网络图流 线性代数，矩阵加速 颜色均摊，珂朵莉树 状态枚举，循环动规 信竞算法学习呈现多点开花局势","categories":[{"name":"闲话杂谈","slug":"闲话杂谈","permalink":"https://justpureh2o.cn/categories/%E9%97%B2%E8%AF%9D%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"闲话杂谈","slug":"闲话杂谈","permalink":"https://justpureh2o.cn/tags/%E9%97%B2%E8%AF%9D%E6%9D%82%E8%B0%88/"}]},{"title":"[奇技淫巧] 面向高中生の洛必达法则简述","slug":"l-hopital-rule-introduction","date":"2024-04-30T23:57:52.301Z","updated":"2024-05-01T05:27:56.826Z","comments":true,"path":"articles/16596/","link":"","permalink":"https://justpureh2o.cn/articles/16596/","excerpt":"","text":"作为一名在导数领域摸爬滚打多年的高中牲，又怎能不知道高贵的洛必达法则呢？今天从高考角度出发，简要介绍洛必达法则作为解选填题的奇技淫巧的策略。 引入 先用一个典例来引入洛必达法则： 定义函数 ，且 在 上恒成立，求 的取值范围。 解法一（正解）：端点效应 问题转化为：“ 在 时恒成立，求 的范围”。 不难发现，新函数 满足 。我们的目标就是让这个新函数恒在 轴上方，考虑 在 时的导数大于等于零——即函数在 上单调递增，即可满足题目要求。这个方法叫做端点效应法，可以用来导出满足题目要求的一个必要条件（充分性需另外证明）、或者是收缩答案的可能范围，减少复杂的分类讨论。 因此列出式子： 解得 。 证明充分性，当 时，。由于 恒成立，原不等式恒大于等于零，即 在 上恒成立， 在 上单调递增。又因为 ，所以 恒成立，原不等式得证。 当 时 ，不能保证结果恒大于等于零，原不等式不成立。综上，。 解法二：洛必达法则 考虑分离参数，得 ，令 。由题意知，需满足 。 对 求导，得 ，此时不容易看出正负，因为分母恒大于等于零，设函数 ，对其求导得 。因此 在 上单调递增。 于是 。由洛必达法则得 ，则取值范围是 。 洛必达法则 讲个笑话：洛必达法则不是洛必达提出的，而是伯努利最先发现的 首先我们要搞清楚洛必达法则的适用条件（非常非常重要，必须要知道葛军究竟是怎么出题卡掉洛必达做法的）： 不定式 to do sth. 分为两种类型，分别对应数字的两个极端。 0/0 不定式：即 ，零除以零。 /不定式：即 ，无穷大除以无穷大。 要想使用洛必达，式子必须是以上两种不定式的其中一种（正负均可）。如果你发现原始函数并不满足如上的不定式形式，则可以选择求一次导，化成如上的不定式形式。 对于两个函数 和 ，若 是一个不定式，那么不定式的值等于 ，即分子分母求导相除。 后话 无不良引导 其实，洛必达法则就这么些内容。很少，用来秒选择填空题还是可以的。大题如果实在证不出来可以考虑用这个伪证（前提是一个字都证不出来、且所在省份会给部分分数），当然这里还是建议使用正解端点效应法。我的忠告是：平时周考月考在班内秀一下就好了，市里全省大考千万不要用！","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"JPEG vs PNG——胜者为谁","slug":"jpeg-vs-png","date":"2024-04-26T03:46:09.549Z","updated":"2024-05-01T06:08:26.978Z","comments":true,"path":"articles/52926/","link":"","permalink":"https://justpureh2o.cn/articles/52926/","excerpt":"","text":"前言 为什么会有这篇文章 事情是这样的：一天傍晚，我正在为博客寻找新的头图老婆，于是便找到了这张图片： （该图片经过压缩，非原始图片） 由于原图是 3072×2280 的，体积高达 4.59M，对于网站来说，显然是太过巨大了，因此我便着手开始寻找网页图片压缩的网站/API。 一开始，我选择以 PNG 格式进行压缩，因为据称 PNG 格式的损失率更小、且支持 Alpha 通道颜色存储（即支持带透明度的颜色）。我得到了下面大小为 900K 的输出图像： 乍一看，好像都差不多。可是根据图像压缩网站的分析，我的原图有 44w+ 种不同的 RGB 颜色，但 PNG 模式最多仅能保留 256 种颜色（最低保留 8 种颜色，效果不忍直视，就不放了，但体积只有 240M 左右）。这意味着我的原图的很多渐变的颜色被压缩算法统一抹成了同种颜色，具体可以看到白洲梓脸颊的红晕部分： 我就是要看红晕的结果你给我压缩成这幅鬼样子…… 可以很明显地看出差别——压缩后的图片中，脸颊的红晕原本是由大量渐变颜色画成的，然而压缩为 256 色后明显的失去了渐变效果，取而代之的是明显的锯齿感、以及扎眼的色彩偏差（具体见蝴蝶结部分）。尽管压缩保持了原图片的尺寸，但是 PNG 模式压缩对细节的保留是极简的，计算不难发现，色彩数变成了原先的 ，效果可想而知……8 RGB颜色的图片看上去和遗照已经没两样了…… 因此这篇文章用来探讨 JPEG 和 PNG 图像格式的压缩效果差异，并给出我个人关于网页图片压缩处理的一些经验建议。 第一节——PNG 是什么，以及它是如何压缩的 PNG 全称 Portable Network Graphics，即可移植网络图形格式，由 W3C 在 1994 年开发，最初设计来为当时的 GIF 图像提供一种现代的、免费的替代方案。与 GIF 格式相比，二者虽然都内置了一个 Alpha 颜色通道用来记录透明颜色，但是 GIF 仅允许一种全透明颜色、而 PNG 支持任意百分比透明度的 RGB-Alpha（后简称 RGBA） 颜色。由于 PNG 格式压缩的无损性，在此后的数十年里，它被广泛用作网络的图像传输；当然它也有劣势，就是图像体积远大于 JPG 格式的图像。 既然 PNG 是无损压缩，那为什么压缩出图的质量还这么拉胯呢？ 问题出在压缩的颜色数量上，正如上文所述，PNG 模式压缩最高支持到 256 色。在压缩算法进行时，算法会对图片文件进行逐行扫描，并分别采用最优压缩方案。当然，这种处理模式的上限是仅保留 256 种不同的颜色，对于相邻且差距不大的颜色块，算法作统一化处理，将这块区域涂成同样的颜色。自然就会出现颜色间出现明显断层、偏差的现象。 如果你也有这样一张颜色丰富的图像急需压缩的话，推荐使用 JPEG 格式压缩，见下文： 第二节——JPEG是什么，以及它是如何压缩的 JPEG 全称 Joint Picture Expert Group，即联合图像专家组。它和我们更常见到的 JPG 格式其实是同一个东西，在早期的 Windows 系统里，文件后缀名最多仅支持三个字符，于是就取 JPEG 的再简称 JPG 作为文件格式。当然最正式的后缀名是 JPEG，在后缀名上限放开之后，因为大家都已经习惯了 JPG 格式，自然也就很少人用其正式后缀名 JPEG 了。与此类似的例子还有安卓（Android，原官方中文名为安致）。 JPEG 采用有损压缩，但是压缩后文件体积远小于 PNG，并且在压缩的情况下，原图的视觉效果能很好地再现出来。对于颜色较多的图像，JPEG 对原图视效的保留是大幅优于 PNG 的。 有个不恰当的比喻——PNG 压缩是在文件二进制码处理上下功夫；而 JPEG 压缩则是在眼皮下耍把戏。专家组发现，人眼对亮度的敏感度要高于对颜色的敏感度： （如图， 块和 块其实是同一种颜色） 因此 JPEG 在压缩上首先就抛除了 RGB 颜色表示法，转而使用以亮度、蓝色偏移、红色偏移三个参数表示色彩的 YCbCr 编码。既然人类对亮度的敏感程度高于色差，这就意味着我们可以将分量 Y 尽数保留，而在 Cb 和 Cr 分量上下功夫。 考虑一个 的颜色矩阵 。JPEG 压缩采取 滑动取样的技术，即生成一个 的滑动窗口，从矩阵的左上角每次处理四个值，每次将滑动窗口左上角的元素抽离出来并放入一个结果矩阵中。因此矩阵 将经历 轮处理，输出矩阵 。就实现了原图的体积压缩。注意到该过程仅在 Cb 和 Cr 通道上进行，分别压缩至原先的 ，总共压缩率就是 ，出图体积大概在原图的 左右。不难发现，我们的处理过程将部分元素略去了，故 JPEG 压缩为有损压缩。 别急，这只是第一轮压缩。JPEG 在某些时候能够做到 的压缩率，这主要得益于 DCT 算法的加持。 DCT 全称 Discrete Cosine Transform 离散余弦变换（莫名想起傅大佬的变换来了），其精髓在于：一切信号均可用若干不同频率的标准余弦函数组合表出。这就好像把一个图像拆分成很多个初等函数的和。JPEG 的压缩用到八个标准余弦函数，分别是 ，频率顺次由低到高。 JPEG 会先将图像分成一个个 的区块（尺寸为经验值，效率普遍最优），在每个区块里按行按列分别进行 DCT，最后合并得到一个整个处理过的信号图谱。此时专家组又玩了一个把戏——他们发现人眼对高频的图像信号不敏感，因此在处理后的图像里，舍弃掉高频区块。既能保证视效的大致相同、也能达到大幅压缩体积的效果。 （随着频率采样总数的增加，DCT 的输出图像愈来愈接近原图，高频的添加并不会对图像产生多大影响） 此时对图像进行量化。这个过程的自定义程度是非常高的，这个过程需要量化表的参与，具体表现为用 DCT 处理后的图像矩阵的元素分别除以量化表矩阵相同位置的元素，并对商取整，得到量化后图像。一般地，量化表矩阵的元素越大，量化后图像的质量就越低。因为做整除法实质上是将对应通道的值控制在某个较小的值以内，当量化表的元素均趋近于正无穷时，量化后的结果将会是一个零矩阵 ，自然就是全损画质了。Photoshop 为 JPEG 格式的导出功能做了十二张量化表，分别对应不同的压缩质量。图像解码时，只需遍历乘以量化表矩阵的对应元素即可（注意并非矩阵乘法），由于除法取整的关系，量化也是一个有损压缩过程。 得到量化结果矩阵后，专家组用游程扫描法、兼以霍夫曼编码对矩阵进一步压缩，就可得到最终的压缩版 JPEG 图像了！ 霍夫曼编码是一种根据关键字出现频率大小进行编码的算法，在压缩文件中极为常用，本质是将一个较长但是经常出现的串用一个短编码进行对应映射，可以省去大量空间；而游程扫描则是一种对矩阵元素进行遍历扫描、并将二维矩阵转为一维数组的方式，一般来说量化结果矩阵的右侧和下侧会出现多个 ，用游程扫描会将多次重复出现的零元素聚集到一块，方便霍夫曼算法的计算。 （游程扫描法遍历顺序） 至此便是整个 JPEG 格式的压缩过程。 总结 推荐一个免费不带广告且强大的在线图像压缩网站：Recompressor。该网站支持 PNG 和 JPEG 两种压缩方式。 随着图像解码技术的不断发展，以往那些用电脑看图，图片一行一行蜗速加载的时代已经一去不复返了。即便如此，网站搭建者仍会使用图片压缩技术来提升网站访问速度，以减少服务器性能的不必要消耗、并带给访客最佳的浏览体验。 在图像压缩方面，如果你的图像不包含透明像素点，且需保留的颜色、细节较多时，那么 JPEG 格式将是不二之选；如果你需要存放透明背景的图像，并且图像颜色较均匀，推荐 PNG 格式。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"A-star 算法——启发式搜索算法","slug":"A-star-algorithm","date":"2024-04-25T23:42:58.472Z","updated":"2024-08-23T01:26:19.583Z","comments":true,"path":"articles/685/","link":"","permalink":"https://justpureh2o.cn/articles/685/","excerpt":"","text":"种子相声大师 JustPureH₂O 在他的新作里如此写道： （上台） 今个咱们不说dijkstra，咱来聊一聊 A星 算法。 诶，这个我知道。A星就是矩阵 A 的伴随矩阵，它有可多性质啦！考研娃们万别错过，咱们说这个伴随…… 哎打住打住，A星算法怎么能是矩阵呢？再说了，你一个高中生不好好搞圆锥曲线和导数，反而来学线性代数干什么？ 挨个列举矩阵 A 的代数余子式并把它放到一个新矩阵。 停停停！咱们这个 A星算法是用来求最优路径哒，你手机里的高德都用的就是 A星算法啦。A星是启发式搜索算法的其中一种，它还有一个迭代加深的版本 IDA…… 这有啥的，我一通暴力 BFS 也能求最短路。 跟你那个不一样，人家 A星都是在 数量级往上跑的，你一个 BFS 早超时啦——欸，所以你在认真听没有？我来考考你，A星是什么算法？ 是矩阵 A 的伴随矩阵。 去你的吧 （鞠躬退场） A-star 算法介绍 如果你认真听了课，你就会知道 A星算法是伴随矩阵启发式搜索算法的一类，至于为什么是字母 A 加上一个星号——那得去问起这个名字的人，我也不清楚。 A星算法很像资本家的思维模式。对于有着庞大节点数量的图，要从起点开始搜寻到一条到终点的路径。此时的 BFS 就像一个不会做加法的完美主义者（BFS 跑最短路的要求是边权只出现一个或两个非负数），非得把所有通路都遍历一遍、才找出一条严格的最短路径；而 Dijkstra 算法又像只会做加法的完美主义者（只要边权非负即可，若要跑负权边请移步至已死的算法），和 BFS 相似，也要遍历大量的节点才找出一条路径。可是 A星思路却格外清奇——它设计了一个对当前节点进行估价的函数 ，根据价值大小选择是否经过该节点，因此 A星算法得到的路径一定是耗材最少的路径，并且由于省去了大量无用遍历，它的执行效率也会快很多。 要实现 A星算法，我们首先就要对堆优化的 Dijkstra 进行一个小变动： 将 Dijkstra 所使用的记录距离的优先队列改为估价函数的优先队列。 其余的和 Dijkstra 也比较相似，我们需要遍历与该节点伸展出去的边，并入队这些边。当终点第一次出队时，跳出计算并返回最短值。 那么如何给点估价？我们首先要计算当前点 到起点的真实距离并记作 ；再将当前点到终点的估计距离（注意是估计出来的距离）记作 ，那么估价函数 。注意到 Dijkstra 算法并不关心当前点到终点的估计距离，因此它是 恒成立的特殊情况。 A-star 注意事项 点的入队：在入队新点时，优先队列的排序关键字应该设为 ，也就是 dist[now] + f(now) 的形式；特殊地，入队起点时应该将排序关键字设为 f(now)（此时显然 dist[now] 的值为 ）。 估价函数的写法：估价函数不存在一个固定的模板。在P1379 八数码难题中，它是当前状态到目标状态的曼哈顿距离之和；在P2901 Cow Jogging G中，它又是当前点到终点的最短距离。因而对于不同的题目，估价函数都需要重新设定。 STL 使用的细节：优先队列 priority_queue 中若存储的是二元组 pair，那么将自动按照 pair 的第一关键字排序，且优先队列默认为大根堆（队头永远是最大的），而在实际算法中，我们更常使用小根堆，此时将优先队列定义为 priority_queue&lt;PAIR, vector&lt;PAIR&gt;, greater&lt;PAIR&gt;&gt; 即可。 A-star 典例 洛谷 P1379 八数码难题 题目传送门：这里 题目难度：普及+/提高 题目来源：福建省历届夏令营 在 的棋盘上，摆有八个棋子，每个棋子上标有 至 的某一数字。棋盘中留有一个空格，空格用 来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为 ），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。 输入 输入初始状态，一行九个数字，空格用 表示。 输出 只有一行，该行只有一个数字，表示从初始状态到目标状态需要的最少移动次数。保证测试数据中无特殊无法到达目标状态数据。 样例输入 #1 1283104765 样例输出 #1 14 样例 #1 解释 图中标有 的是空格。绿色格子是空格所在位置，橙色格子是下一步可以移动到空格的位置。如图所示，用四步可以达到目标状态。 并且可以证明，不存在更优的策略。 先用朴素 BFS 的思路思考一遍，我们肯定是要枚举可能到达的状态，若当前状态和目标状态相同，则返回步数。由于 BFS 的最短路性质，在目标状态第一次弹出时即可返回步数。 考虑使用 A* 算法，我们就需要思考如何对状态估价，即计算当前状态与目标状态的差异度。不妨计算同一元素在当前状态和目标状态的曼哈顿距离（横坐标距离加上纵坐标距离），并对除开空格外的八个元素均使用此操作，并累加结果，就能得到描述两个状态的差异度的量了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, string&gt; STATE;unordered_map&lt;string, int&gt; dist;priority_queue&lt;STATE, vector&lt;STATE&gt;, greater&lt;&gt;&gt; q;string st, ed = \"123804765\";int f(const string &amp;now) { int res = 0; for (int i = 0; i &lt; 9; i++) { if (now[i] == '0') continue; switch (now[i] - '0') { case 1: case 2: case 3: res += abs(i / 3) + abs(i % 3 - (now[i] - '1') % 3); break; case 4: res += abs(i / 3 - 1) + abs(i % 3 - 2); break; case 5: res += abs(i / 3 - 2) + abs(i % 3 - 2); break; case 6: res += abs(i / 3 - 2) + abs(i % 3 - 1); break; case 7: res += abs(i / 3 - 2) + abs(i % 3); break; case 8: res += abs(i / 3 - 1) + abs(i % 3); break; } } return res;}int bfs() { int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; q.push((STATE) {f(st), st}); dist[st] = 0; while (!q.empty()) { STATE s = q.top(); q.pop(); if (s.second == ed) return dist[s.second]; int idxx = 0, idxy = 0; for (int i = 0; i &lt; 9; i++) { if (s.second[i] == '0') { idxx = i / 3, idxy = i % 3; break; } } string src = s.second; string tmp = s.second; for (int i = 0; i &lt; 4; i++) { int nx = idxx + dx[i], ny = idxy + dy[i]; if (nx &lt; 0 || nx &gt; 2 || ny &lt; 0 || ny &gt; 2) continue; tmp = src; swap(tmp[idxx * 3 + idxy], tmp[nx * 3 + ny]); if (!dist.count(tmp) || dist[tmp] &gt; dist[src] + 1) { dist[tmp] = dist[src] + 1; q.push((STATE) {f(tmp) + dist[tmp], tmp}); } } } return -1;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; st; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;} 总用时： 记录 洛谷 P2901 [USACO08MAR] Cow Jogging G 题目传送门：这里 题目难度：提高+/省选- 题目来源：USACO 2008 贝西终于尝到了懒惰的后果，决定每周从谷仓到池塘慢跑几次来健身。当然，她不想跑得太累，所以她只打算从谷仓慢跑下山到池塘，然后悠闲地散步回谷仓。 同时，贝西不想跑得太远，所以她只想沿着通向池塘的最短路径跑步。一共有 条道路，其中每一条都连接了两个牧场。这些牧场从 到 编号，如果 ，则说明牧场 的地势高于牧场 ，即下坡的道路是从 通向 的， 为贝西所在的牛棚（最高点）， 为池塘（最低点）。 然而，一周之后，贝西开始对单调的路线感到厌烦，她希望可以跑不同的路线。比如说，她希望能有 种不同的路线。同时，为了避免跑得太累，她希望这 条路线是从牛棚到池塘的路线中最短的 条。如果两条路线包含的道路组成的序列不同，则这两条路线被认为是不同的。 请帮助贝西算算她的训练强度，即将牧场网络里最短的 条路径的长度分别算出来。你将会被提供一份牧场间路线的列表，每条道路用 表示，意为从 到 有一条长度为 的下坡道路。 输入 第一行三个用空格分开的整数 ，其中 。 第二行到第 行每行有三个用空格分开的整数 ，描述一条下坡的道路。 输出 共 行，在第 行输出第 短的路线长度，如果不存在则输出 。如果出现多种有相同长度的路线，务必将其全部输出。 数据范围 对于全部的测试点，保证 ，，，，， 题意简化：给定一张图，分别求从点 到点 的第 短路的长度。 要想求这个问题，需要先明确下边的一条性质： 在 A* 算法中，当终点出队 次时，此时经过的总距离就是第 短路的距离。 因而我们设置一个 的循环，分别求出对应情况的 短路。需要注意的是，当此时的循环变量已经大于从起点到终点的总路径数时，自然就无需重复计算后面的情况，直接输出 就好。对于估价函数，我们在反图上跑一遍最短路即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;typedef long long ll;typedef pair&lt;ll, int&gt; Point;typedef pair&lt;ll, Point&gt; Star;struct Edge { int ne, to; ll w;} edges[N &lt;&lt; 2];int h[N], rh[N];bool st[N];priority_queue&lt;Point, vector&lt;Point&gt;, greater&lt;&gt;&gt; q;priority_queue&lt;Star, vector&lt;Star&gt;, greater&lt;&gt;&gt; heap;int astar_cnt = 0;ll dist[N];int idx = 0;int n, m;void add(int he[], int u, int v, ll w) { idx++; edges[idx].to = v; edges[idx].ne = he[u]; edges[idx].w = w; he[u] = idx;}void dijkstra() { q.push((Point) {0, 1}); dist[1] = 0; while (!q.empty()) { Point p = q.top(); q.pop(); int id = p.second; if (st[id]) continue; st[id] = true; for (int i = rh[id]; ~i; i = edges[i].ne) { int j = edges[i].to; if (dist[j] &gt; dist[id] + edges[i].w) { dist[j] = dist[id] + edges[i].w; q.push((Point) {dist[j], j}); } } }}ll a_star(int k) { heap.push((Star) {dist[n], (Point) {0, n}}); while (!heap.empty()) { Star p = heap.top(); heap.pop(); if (p.second.second == 1) astar_cnt++; if (astar_cnt == k) return p.second.first; for (int i = h[p.second.second]; ~i; i = edges[i].ne) { int j = edges[i].to; heap.push((Star) {dist[j] + edges[i].w + p.second.first, (Point) {p.second.first + edges[i].w, j}}); } } return -1;}void restore() { astar_cnt = 0; heap = priority_queue&lt;Star, vector&lt;Star&gt;, greater&lt;&gt;&gt;();}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); memset(rh, -1, sizeof rh); memset(dist, 0x3f, sizeof dist); int k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= m; i++) { int x, y; ll d; cin &gt;&gt; x &gt;&gt; y &gt;&gt; d; add(h, x, y, d); add(rh, y, x, d); } dijkstra(); bool flag = false; for (int i = 1; i &lt;= k; i++) { if (flag) cout &lt;&lt; -1 &lt;&lt; endl; else { restore(); ll res = a_star(i); cout &lt;&lt; res &lt;&lt; endl; flag = (res == -1); } } return 0;}","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/tags/oi%E7%AE%97%E6%B3%95/"},{"name":"搜索算法","slug":"搜索算法","permalink":"https://justpureh2o.cn/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"}]},{"title":"（转）F444 の 光荣历史 · 其二","slug":"f444-history-ii","date":"2024-04-20T16:28:11.916Z","updated":"2024-04-30T23:48:32.015Z","comments":true,"path":"articles/16985/","link":"","permalink":"https://justpureh2o.cn/articles/16985/","excerpt":"","text":"首次编辑：2023/07/31 二次编辑：2024/04/20 转载者注：2024.4.21 更改了部分错别字、适配文字样式……；2024.4.24 将原文的“（划掉）”改为删除线 零 关于二次编辑 自从上次GGapa的网站爆炸后，我一直没时间把我写的东西重新排版（主要是图片） 今天一时兴起，于是就出现了这篇重新发布的文章 一 简介 曾就读于东辰「教学8班·行政11班」与我同班（两个都是哦），是我初中阶段最好的朋友。现就读于七林9班，在高中数学竞赛的道路上越走越远。喜好有Minecraft、原和一些神奇的卡牌游戏。有批判性思维，不从众，但是对自己的观点有强烈的自信，不拿出证据证明他是错的的话他绝对不会善罢甘休（但是在学校里证据真的很难找awa）。特别喜欢讲故事，经常编一些东西以假乱真，甚至到了剩下的5个人异口同声的问他“真的吗？”这种地步。 二 外号来源 FRC又知名为天皇陛下，冯进村等等（反正都是从“日本天皇”衍生出来的）。那么这个外号是从哪里来的呢？据传说(主要大家基本都快忘了，经过讨论认定了这个最终版本)，一次中午回寝，大家在激烈的讨论历史课上刚刚讲的日本明治维新相关的内容，FRC为了让大家认真的听他的观点，就说“我是天皇陛下…”，于是这个外号就传开了。四舍五入这个外号是他自己取的 三 关于学习 相信不用我多说了，能进七林九班的都不是什么善茬。但是我还是附上一次8年级（大概）的月考成绩图： ∆天皇稳居第一，高第二名十多分 除了学习，其实我更想说的是他的批判性思维。这一点可能和其他寝室不同，我们寝室常常谈论一些时政内容或者类似的需要表达自己的观点并证明的内容。在这样的环境下，小蝴蝶、我、天皇和其他公民（ffy经常偷听我们聊天但是不说话，sbffy）都能有一套自己的论证思路并相互交融，我不认为这对逻辑思维能力的发展没有帮助。 四 关于游戏 分成两个部分吧，原和Minecraft。 原神 应该是初三下学期才入的坑，算比较晚的。他入坑在我看来应该是被逼无奈，实在和他的好朋友们没有共同话题才入的坑。但是他入坑后特别肝，现在应该55级了吧（思考 由于他B我官（他B服，我官服，我们两个之间已经隔了一道厚障壁力（悲），所以基本没怎么联过机，但是后来他朋友送了他一个官服号，就和我玩过一两次（主要O是养成类游戏，那个号上什么也没有）。 他狂热的厨纳西妲，所以就在这里放两张纳西妲的游戏截图吧（太随性了awa）： ∆这个应该是他草神的面板（翻了10分钟聊天记录才找到qwq Minecraft 自从我认识他（在军训的时候）他就玩mc，还记得当时我们因为2个木板合成几个木棍而吵架（他说“两个木板合成两个木棍”，我说是4个，事后他便获得了“cloud player”这个称号，不过现在已经没什么人喊了）。 和他在信息技术课上（常规课和社团课）玩过1.12匠魂，1.18原版和空岛，1.18.2匠魂等等（甚至为了这个去学了C++并考了校队，走上一条OI不归路 他记忆力很好，所有模组相关的合成表我都直接问他，像什么《匠魂宝典》都是他读，读完了就把有用的属性提炼出来给我说。 当然，我主要负责生电和指令嘛（撅嘴 下面是一些游戏截图： ∆这些都是匠魂的存档，空岛的没怎么截图 五 自述 由于天皇现在在七林扫荡，找不到他人，所以这个部分先咕掉(*≧ω≦) 当然，天皇是不会被放过的（早柚音 转载者注：可是钴了快一年了，连点音讯都没有…… 六 他人刻画 这个部分应该是最精彩的部分（确信 谦谦： 天皇为什么叫天皇我也不知道，开始他看起来比较可爱但后面就越来越猥琐，有着非常智慧的大脑，比较喜欢理性分析问题，然后感性处理问题（指看心情），好玩做事比较冲动喜欢玄学，求知欲旺，又不的问题，一定会细心请教不是不擅长运动比较懒惰，口才很好喜欢讲故事，有点贪睡眠质量良好呼噜声特别大特别情况下被刺激会暴怒。 小蝴蝶： 冯氏、本名瑞辰。传闻天地初开之时，天下五分，雷占其四而天皇独占其一，是为一人之下，万人之上矣。遂有天皇之名（语出《sl经典语录》）数学之王（官方限定）在数学方面卓有天赋。为人和善。初极狭，才通人口才极佳，善于讲故事。京中有善口技者为寝室建设作出卓越贡献，但会在晚上使用声波武器，对寝室成员们进行精神攻击0.o 这是个对话awa yhy: 我注意到他就只是邓老板 yhy: 在让他当课代表 我: 正确的，客观的 yhy: 在此之前一点印象都没 yhy: 然后感觉写小说的那段时间神经兮兮的？ 这个事件后面会讲（应该 转载者注：至今还在钴…… yhy: 就这个秘密那个不让看的 我: 正确 我: 他写小说的时候是我和他关系最差的时候 yhy: 主要是把我的op蝴蝶抢了 我: OP yhy: 我们寝室又没有op yhy: 就挺空虚的 yhy: 不正经的时候 yhy: 真不知道下限 yhy: 正经的时候有点吓人？ 我: 不 我: 也有可能有一点 yhy: 特别是天天给我吵wyx yhy: 特别烦 yhy: 顺便 yhy: 我真的只是找个人说话 yhy: zyh才对他有意思 yhy: cm也有可能？ 不可避免的偏题了qwq yhy: 总之感觉就是比我nb但是心术大不正（离谱 的那种学神 yhy: 但是可能以后会黑化的那种 话题莫名其妙的回来了awa JustPureH₂O（Cl）: 天皇陛下，不知道为什么，每次看到他抱着自己家的柴犬的照片时，总有一种兄弟情深的感觉。 感觉他严肃正经起来很有学霸的气息，但是一旦下了课，我总能在校围栏旁的草丛附近发现他的身影。 尤其喜爱捉某些昆虫（指蝴蝶），采摘水果（指东辰的桃子和杏），能夹，银叫起来比大部分人（除开胡睿杰）更像女的。 自从他脸上受伤留下一道光荣印记以来，他的笑容比之前猥琐了指数倍。 但是对于他的智力，无可置疑的是他确实实力无限，他和那些闷头整天坐在教室里学习的娃的最大区别就是：他深谙劳逸结合的重要性，平时也会和同学打成一片，尤其喜欢叫外号，据个人无数据的不完全统计——他最钟爱的外号包括guozhen、sb飞飞鱼、小蝴蝶、草绿等。 ZXX: 不知道怎么请到的神奇人物 就看起来傻不拉叽，但十分聪明的一个人。奇奇怪怪，但很喜欢作为上课的气氛担当。就是说至于用书签削学校的转基因农作物，抓些小虫养在教室这种行为，我的评价是“可以的”。讲真的，聪明人还是聪明人，还是有亿点离谱的。 字数：2214字 EOF","categories":[{"name":"转载","slug":"转载","permalink":"https://justpureh2o.cn/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"整活","slug":"整活","permalink":"https://justpureh2o.cn/tags/%E6%95%B4%E6%B4%BB/"},{"name":"转载","slug":"转载","permalink":"https://justpureh2o.cn/tags/%E8%BD%AC%E8%BD%BD/"}],"author":"Lucas2011"},{"title":"（转）F444 の 光荣历史 · 其三","slug":"f444-history-iii","date":"2024-04-20T16:28:11.916Z","updated":"2024-04-30T23:48:58.376Z","comments":true,"path":"articles/8600/","link":"","permalink":"https://justpureh2o.cn/articles/8600/","excerpt":"","text":"首次编辑：2023/07/31 二次编辑：2024/04/20 转载者注：2024.4.21 更正部分格式、适配文字样式 零 关于二次编辑 自从上次GGapa的网站爆炸后，我一直没时间把我写的东西重新排版（主要是图片） 今天一时兴起，于是就出现了这篇重新发布的文章 一 简介 本人是一名普通的中学生，兴趣爱好广泛，在学校时社牛，回到家社恐(在假期就别想把我叫出来)。学习还算不差，擅长说冷笑话（都怪你Techno），热衷于瞎折腾，喜欢把电脑折腾来折腾去（GGapa应该和我差不多）。总之，往下看吧。（语文概括能力不够orz 二 关于学习 额，不是很好描述。英语、数学应该还行，语文特别烂。我就直接放两张最近考试的成绩图吧： ∆ 没有电子档，将就着看吧orz ∆ 不要问我为什么在 C++ Primer Plus 上写，小mi念成绩念的太猝不及防了qwq 其实在这里我更想写的是我关于学习的一些观点，但是限于篇幅，我以后单独出一期来写 又开始画饼了awa 三 爱好/兴趣 到了喜闻乐见的查成分环节（雾 首先声明，因为本人有一点“三分钟热情”，所以爱好范围非常广。 Minecraft 因为mc这个圈子太大，所以我把它分成三个部分awa PVP 代表up主：Q3、雷疯 入坑时间 | 入坑原因：初一下左右 | 看了B站大神（就是这两位，当时还没有这么出名）的视频 最吸引我的东西：应该就和其他PVP游戏所给予玩家的那种“快感”无异 备注资料：之前玩过很长一段时间的Hypixel MCYT 代表up主：Technoblade（烤肉：漠然一笑）、DSMP（烤肉：老白）、sbi等 入坑时间 | 入坑原因：初二上左右 | 当时Dre爆火整个mc圈，然后就在B站刷到了Dre和Tech的Duel。对Dre的失败而感到惊讶，于是就认识了猪猪（当时他提到了“秦王绕柱”，是我第一次从YTB的口中听到有关中国文化的正面的东西，所以就被深深的吸引了awa） 最吸引我的东西：喜欢猪猪的不悲不喜的说话方式 和线下社恐线上和粉丝相互80的神奇社交模式（雾 和奇怪的冷笑话（地狱笑话 和中华文化传播大使（bushi 生电圈 代表up主：黑山大叔、TIS、Fallen_Breath、XeKr 入坑时间 | 入坑原因：未知 | 未知 最吸引我的东西：科 技 感 十 足 备注资料：附一张之前一直玩的1.16.2的投影文件列表： 米哈游 代表up主：M枫叶ML、查de君、Bowen波波、ziv紫薇（攻略区）、影月月（攻略区） 入坑时间 | 入坑原因：2022年5月27日* | 耐不住寂寞，在小蝴蝶、YHY的传教下入坑（雾 为什么如此确定？因为这个活动二维码： 二编补充：好吧这个二维码现在因为一些原因放不出来了…… 最吸引我的东西：B站上有人是有理有据的夸原的（例如叶泽君Pro），我的理由和他们差不多 备注资料：现在是57级 厨草神 补充一些图片awa： ∆ 账号概览 ∆ 我有一段时间还是很肝的 现在应该一共有7个区域满探索度 音游 代表up主：Ek_Ruby（单手制霸IN）、MayLight39（锁屏练习）、广大自制谱社区 入坑时间 | 入坑原因：2022年7月24日* | 先是玩原，就会给我推一些Phigros X 原神 的自制谱创作视频 为什么如此确定？因为这张图： 最吸引我的东西：很喜欢音游圈（小鬼除外）和 打歌、收歌 的成就感和获得感 入坑过程：Phigros -&gt; 喵斯 -&gt; （翻到外区 AppStore ） -&gt; Rizline -&gt; Arcaea -&gt; pjsk 其中Phigros的ranking score达到了14.43（ L 最喜欢的曲子和第二喜欢的曲子： 打的还算可以的曲子： 二编补充：现在已经进步好多好多了请看下图： 数码（信息） 代表up主：LinusTechTips 入坑时间 | 入坑原因：不知道，一直都挺喜欢 | 不知道，应该得益于我喜欢折腾东西 最吸引我的东西：额，折腾东西的时候的感觉？ 我描述不出来 转载者注：深有同感 化学类（知识区） 代表up主：H2元素实验室、柴知道 入坑时间 | 入坑原因：不知道，一直都挺喜欢 | 和我的一个学习理念有关（曲线救国系列） 飞机 代表up主：昕有凌兮杂货铺 入坑时间 | 入坑原因：不清楚 | 偶然刷到，喜欢这个up主的视频风格，同时羡慕这个up主的婚姻（雾 最吸引我的东西：每个男孩都喜欢飞机对吧？是这样吧是这样吧？（温迪音 备注资料：真的很推荐这个up主，他手撕营销号的视频让我觉得我国的网络环境还有救 萌宠 最吸引我的东西：有谁不会喜欢一只可爱的猫猫头呢（温迪除外 ∆猫猫！！！！！！！！！！！！！！！ 术力口 萌新，屁都不懂 总结：分析纯（AR）杂质 杂质含量不少于 99.9% 口述无凭，给大家截两张B站首页和收藏夹就知道了： 四 他人刻画 这个还没做好，做好了也不会放出来（应该 转载者注：做个他人刻画有啥难的（doge）","categories":[{"name":"转载","slug":"转载","permalink":"https://justpureh2o.cn/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"整活","slug":"整活","permalink":"https://justpureh2o.cn/tags/%E6%95%B4%E6%B4%BB/"},{"name":"转载","slug":"转载","permalink":"https://justpureh2o.cn/tags/%E8%BD%AC%E8%BD%BD/"}],"author":"Lucas2011"},{"title":"（转）F444 の 光荣历史 · 其一","slug":"f444-history-i","date":"2024-04-20T16:20:29.091Z","updated":"2024-04-30T23:38:15.725Z","comments":true,"path":"articles/10072/","link":"","permalink":"https://justpureh2o.cn/articles/10072/","excerpt":"","text":"首次编辑：2023/07/31 二次编辑：2024/04/20 转载者注：2024.4.21 更改了一些错别字、样式 负一 关于二次编辑 自从上次GGapa的网站爆炸后，我一直没时间把我写的东西重新排版（主要是图片） 今天一时兴起，于是就出现了这篇重新发布的文章 零 写在前面 寝室简介： 是在sl压迫下，在重新换寝时被sl内定的一间满是“问题少年”的寝室。虽然学习非常优秀（寝室中有至少有三人常年稳居班级前十五，其中FRC常年为年级第一）但是仍然入不了宿雷的“法眼”。于是常年被sl针对、反讽。你将在接下来的“寝室大事记”中具体领会sl的刻薄与尖酸。 公民有FRC(天皇陛下｜数学之王)、SJY(我｜英语之王)、HZY(小蝴蝶｜表达之王)、YYQ(YYYX｜谦谦)、LJH 非生物环境有LTR(飞飞鱼｜sbffy) 外部压迫势力有宿雷(班主任)、王川(生活老师) 其实wc原来不是压迫势力的，但万恶的sl用邪恶的手段对其实施拉拢（bushi 请大家务必记住这些外号(括号里的内容)和首拼，因为在我在记叙的过程中可能随时会用到这些别名。（真的改不过来了orz 要想了解F444，就应该先了解其规章制度。 随着漫长的时间推移，F444的公民们迫于各方压力（内忧、外患），制定了许多寝室条约，接下来将介绍最为重要的两个——《46A》和《12·5》条约，这两个条约被一致认为是F444能够凝聚的重要粘合剂（什 一 《46A》· 解决内忧 背景： 在原来的8班，每个男生几乎都拥有一些难听的侮辱性绰号。由于活跃于起绰号和叫绰号的同学都基本在我们寝室，所以我们常常因为绰号的原因而产生矛盾。在这样的背景下，伟大的《46A》协定诞生了。 ∆图为寝室各成员外号的投票（具体外号的详解会单独写一期，就人物传记里 内容： 外号需征得本人同意（最重要），每人可选择一个外号进行保护，被保护的外号在本人未经允许的情况下不可以随便乱叫。当违约时，被侵权公民可以通过大喊“46A”来请求其他公民对其进行调解； 寝室由公民和非生物环境（sbffy）共同构成； 3. sbffy玩你妈的门； 本协议与《12·5》协议共同生效，若遇到与《12·5》相悖的情形，一切以《12·5》协议为准。 名字来源： 其实《46A》原来不叫这个名字，原名应是根据制定日期所命名的《11•30协定》。但是天皇嫌这个名字太长了，于是作为数学之王的他将其转换成了16进制，成为了现在的《46A》。 二 《12·5》· 对抗外患 背景： 在sl的高压下，寝室的安危越来越吃紧。面对在sl的审问下可能出现的口供不一的情况，特制定了本协议。总而言之，本协议是对抗外患的一种尝试。 中心思想： 争取不被通报，力求寝室总损失最少。 内容： 1.在危机时刻内部团结一致对外，不向压迫势力检举揭发他人，在“审讯”时，提供尽可能模糊的事件描述（最重要）； 2.在可以承受的范围内，将受力面积最大化，当他人情况危急时（例如连续犯了很多错，或者最近在被sl针对等）部分的代其承担错误。 名字来源： 和《46A》一样也是时间awa，只不过就是12月5日定的啦。 三 在后面写 这个系列应该会继续往后写，准备分成两个部分：人物传记和像编年体一样的事件记录。同时，这个系列里面可能会出现一些我收藏了很久的“古董”哈哈。下一篇是啥容我再想想，反正就二选一…………","categories":[{"name":"转载","slug":"转载","permalink":"https://justpureh2o.cn/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"整活","slug":"整活","permalink":"https://justpureh2o.cn/tags/%E6%95%B4%E6%B4%BB/"},{"name":"转载","slug":"转载","permalink":"https://justpureh2o.cn/tags/%E8%BD%AC%E8%BD%BD/"}],"author":"Lucas2011"},{"title":"Flood Fill 算法——大自然的智慧","slug":"flood-fill-algorithm","date":"2024-04-10T00:50:51.506Z","updated":"2024-04-23T23:52:19.632Z","comments":true,"path":"articles/19985/","link":"","permalink":"https://justpureh2o.cn/articles/19985/","excerpt":"","text":"头图为成都锦城湖畔，与本文内容无关。 Flood Fill 算法——大自然的智慧 ，在这个世界的某个角落，生活这一个人。祂喜欢田园般宁静的生活、还有OI。每至假期，祂便会扳着自己的小笔记本回到乡下老家，开始祂的内卷生活。 这天，下起了大雨，祂一如既往的坐在屋中刷题。这是一道搜索题，要求求出地图中连通块的个数。可是祂没学过BFS和DFS，冥思苦想了一会，祂变得比较烦躁。一缕阳光透过窗帘，照在祂紧握鼠标的右手上——雨停了，此时祂意识到，是时候放松一下自我，出门去转悠转悠了…… 雨后的田地无比清香，雨珠垂挂在苇叶上，倒映着绿草蓝天……但是此时，祂一脚踩进了盛满泥水的土坑里，原本愉悦的心情瞬间化为乌有。泥水泼溅出去，流进了祂方才踩出的泥脚印里。看到这一幕，祂陷入了沉思，短短的两分钟后，祂似乎想到了什么，冲进屋里、打开电脑，又开始码起字来了…… 以上纯属虚构 这段故事从某种角度上揭示了Flood Fill算法的基本工作原理——将深度相同的节点染上相同颜色。如同自然界中的洪水，总是从始发地开始，优先向海拔低于始发地的地点扩散，因此更高的地方就不会被淹没，自然也就不会被染色。在扫雷游戏中，消除无地雷的连通块也是基于这个原理实现的；而在画图软件中，填充颜色桶的实现也是这个原理（它甚至还是C语言中的一个函数）。 Flood Fill 算法实现 对于连通块的处理，分两种情况——四连通和八连通。前者将斜方向的四个方块判定为不连通、后者则是将某方块周围围绕的八个方块全部看作连通。如下图所示： （其中判定为与棕色方块连通的方块用绿色标出） 实现细节就是：在搜索下一个方块时，先判断是否连通，若连通则在该点进行 Flood Fill 算法。用DFS（递归）和BFS（队列）均可实现该算法。 DFS版： 1234567891011121314151617181920int matrix[N][N];bool vis[N][N];int n;void floodfill(int x, int y, int color, int old_color) { if (1 &lt;= x &lt;= n &amp;&amp; 1 &lt;= y &lt;= n &amp;&amp; !vis[x][y] &amp;&amp; matrix[x][y] == old_color) { vis[x][y] = true; matrix[x][y] = color; // 四连通 floodfill(x + 1, y, color, old_color); floodfill(x, y + 1, color, old_color); floodfill(x - 1, y, color, old_color); floodfill(x, y - 1, color, old_color); // 八连通// floodfill(x + 1, y + 1, color, old_color);// floodfill(x + 1, y - 1, color, old_color);// floodfill(x - 1, y + 1, color, old_color);// floodfill(x - 1, y - 1, color, old_color); }} BFS版： 1234567891011121314151617181920212223242526272829struct Point { int x, y, color;};int matrix[N][N];bool vis[N][N];queue&lt;Point&gt; q;int n;void floodfill(int x, int y, int color, int old_color) { while (!q.empty()) { Point p = q.front(); q.pop(); if (1 &lt;= p.x &lt;= n &amp;&amp; 1 &lt;= p.y &lt;= n &amp;&amp; !vis[p.x][p.y] &amp;&amp; p.color == old_color) { vis[p.x][p.y] = true; matrix[p.x][p.y] = color; // 四连通 q.push((Point) {x + 1, y, matrix[x + 1][y]}); q.push((Point) {x, y + 1, matrix[x][y + 1]}); q.push((Point) {x - 1, y, matrix[x - 1][y]}); q.push((Point) {x, y - 1, matrix[x][y - 1]}); // 八连通// q.push((Point) {x + 1, y + 1, matrix[x + 1][y + 1]});// q.push((Point) {x + 1, y - 1, matrix[x + 1][y - 1]});// q.push((Point) {x - 1, y + 1, matrix[x - 1][y + 1]});// q.push((Point) {x - 1, y - 1, matrix[x - 1][y - 1]}); } }} 两端代码均实现将连通块内的数字更改为另一个数字的功能。 洛谷 P1596 [USACO10OCT] Lake Counting S 题目传送门：P1596 题目难度：普及- 题目来源：USACO 2010 由于近期的降雨，雨水汇集在农民约翰的田地不同的地方。我们用一个 的网格图表示。每个网格中有水（W） 或是旱地（.）。一个网格与其周围的八个网格相连，而一组相连的网格视为一个水坑。约翰想弄清楚他的田地已经形成了多少水坑。给出约翰田地的示意图，确定当中有多少水坑。 输入输出： 输入第 行：两个空格隔开的整数： 和 。 第 行到第 行：每行 个字符，每个字符是 W 或 .，它们表示网格图中的一排。字符之间没有空格。 输出一行，表示水坑的数量。 样例输入 #1 123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W. 样例输出 #1 13 Flood Fill 裸题，题目要求简化为输出由字符 组成的连通块的总数，即可套用模板求解。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define N 110using namespace std;struct Point { int x, y;};int n, m;char matrix[N][N];bool vis[N][N];queue&lt;Point&gt; q;void floodfill(char color, char old_color) { while (!q.empty()) { Point p = q.front(); q.pop(); if (!vis[p.x][p.y] &amp;&amp; 1 &lt;= p.x &lt;= n &amp;&amp; 1 &lt;= p.y &lt;= m &amp;&amp; matrix[p.x][p.y] == old_color) { vis[p.x][p.y] = true; matrix[p.x][p.y] = color; for (int i = p.x - 1; i &lt;= p.x + 1; i++) { for (int j = p.y - 1; j &lt;= p.y + 1; j++) { q.push((Point) {i, j}); } } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cin &gt;&gt; matrix[i][j]; } } int ans = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (matrix[i][j] == 'W' &amp;&amp; !vis[i][j]) { q.push((Point) {i, j}); floodfill('.', 'W'); ans++; } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 总用时： 记录 洛谷 P3456 [POI 2007] GRZ-Ridges and Valleys 题目传送门：P3456 题目难度：普及+/提高 题目来源：POI 2007 给定一个地图，为小朋友想要旅行的区域，地图被分为n*n的网格，每个格子(i,j) 的高度w(i,j)是给定的。若两个格子有公共顶点，那么他们就是相邻的格子。（所以与(i,j)相邻的格子有(i-1, j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)）。我们定义一个格子的集合S为山峰（山谷）当且仅当： 1.S的所有格子都有相同的高度。 2.S的所有格子都联通3.对于s属于S，与s相邻的s’不属于S。都有ws &gt; ws’（山峰），或者ws &lt; ws’（山谷）。 你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。 输入 第一行包含一个正整数n，表示地图的大小（1&lt;=n&lt;=1000）。接下来一个n*n的矩阵，表示地图上每个格子的高度。(0&lt;=w&lt;=1000000000) 输出 应包含两个数，分别表示山峰和山谷的数量。 感谢@Blizzard 提供的翻译 输入输出： 输入的第一行，为一个整数 （）。 接下来 行，每行 个数字，为高程图 输出仅一行，分别是地图中山峰和山谷的总数，用空格分开。 样例输入 #1： 12345658 8 8 7 77 7 8 8 77 7 7 7 77 8 8 7 87 8 8 8 8 样例输出 #1 12 1 显然山峰山谷只能是在同一高度上的连通块，在输入里体现为由同一数字组成的连通块。不难发现，这个题目是一个八连通问题。 整体思路架构在 Flood Fill 算法的基础上，只是我们需要对当前方块的连通方块进行高度判断，以确定该高度上的连通块是否是山峰或者山谷。考虑当 BFS 扫到的点的高度与当前连通块高度不同时，进行判断——如果周边存在一个连通方块，并且这个扩展方块的高度高于当前的方块，那么当前连通块显然不可能是山峰，反之亦然。 代码（这个题卡 queue，建议手写队列）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define N 3010#define x first#define y secondusing namespace std;typedef long long ll;typedef pair&lt;int, int&gt; Point;int n;int g[N][N];bool vis[N][N];Point q[N * N];void floodfill(int x, int y, bool &amp;not_peak, bool &amp;not_valley) { q[0] = (Point) {x, y}; int hh = 0, tt = 0; while (hh &lt;= tt) { Point p = q[hh++]; vis[p.x][p.y] = true; for (int i = p.x - 1; i &lt;= p.x + 1; i++) { for (int j = p.y - 1; j &lt;= p.y + 1; j++) { if (i == p.x &amp;&amp; j == p.y) continue; if (0 &lt;= i &amp;&amp; i &lt; n &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; n) { if (g[i][j] != g[p.x][p.y]) { if (g[i][j] &lt; g[p.x][p.y]) not_valley = true; else not_peak = true; } else if (!vis[i][j]) { //q.push((Point) {i, j}); q[++tt] = (Point) {i, j}; } } } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; g[i][j]; } } int peak = 0, valley = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (!vis[i][j]) { bool npeak = false, nvalley = false; floodfill(i, j, npeak, nvalley); if (!npeak) peak++; if (!nvalley) valley++; } } } cout &lt;&lt; peak &lt;&lt; ' ' &lt;&lt; valley &lt;&lt; endl; return 0;} 总用时： 记录","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"搜索算法","slug":"搜索算法","permalink":"https://justpureh2o.cn/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"最小二乘问题——从一般到特殊","slug":"least-square-estimation","date":"2024-04-03T00:34:16.975Z","updated":"2024-04-04T19:37:34.175Z","comments":true,"path":"articles/20270/","link":"","permalink":"https://justpureh2o.cn/articles/20270/","excerpt":"","text":"线性最小二乘法相关公式的详细推导请转到人教版数学选修三 终于到最后一章了不是吗？很快就可以逃离高中数学的苦海了。 圆锥曲线和导数都通关了，统计那不得直接秒！ 等等，这 的公式是啥来着，残差是谁减去谁来着…… 还有尾杀是吧，数学书你不讲武德（吐血） 以上纯属虚构。非常好卡方独立性检验，使我的卡西欧旋转 前言 最小二乘法是最为常用的带误差数据拟合法，除开数学卷子，它也可能出没于如下地点： 物理卷子（例如“实验——探究弹簧伸长量和所挂重物质量的关系”中的作图题） Excel表格 这篇文章 某些抽卡游戏的玩家自制概率图 可见在数据统计领域，最小二乘法是不可获缺的分析数据的方法；在应试教育领域，它也是高考的一个重要考点。今天就由易到难介绍一番最小二乘法的计算方法。 线性最小二乘法 学完了高中数学，我们就应该知道这样一些用于计算线性回归的公式： 在线性拟合过程中，我们希望拟合直线能够尽可能接近所给的点。而“点与直线的竖直距离”自然就是刻画上述“点与直线接近程度”的首选方案，然而计算距离需要加入绝对值，使得计算不方便，因此以竖直距离平方代替，也就是“二乘”的由来（指平方）。看以下例题： Example 1. Science of Prescience Pt.I 你向太卜司符玄请教了穷观阵的运作原理。 简而言之，穷观阵会对给定输入物品进行某种运算，根据计算结果，可以推演出周遭事物从古至今的变化历程，从而实现窥探历史、预测将来的神奇功能。当然，由于要保证仙舟的平稳运作，穷观阵的推算模块也必须尽可能减小一切形式的估算误差——即对给定的数据，求得某个直线，使得这条直线能最好的适应这些散点，并请根据推演结果预测数据 的结果。 编号 x y 1 1 3 2 2 7 3 3 10.5 4 0.5 0 易知 。 问题很简单，代入上文公式中可以求得 ，从而得到 。因此经验回归方程就是 。特别地，点 一定在这条拟合直线上，称作“样本中心”。根据经验回归方程，可得当 时， 。 当然拟合也存在误差，接下来就要设计函数关系，使我们可以对拟合效果进行定量分析。 1.残差分析 实质上是比较估计值和实际值之间的差距，是很简单的一种误差分析方法。定义为“观察值减估计值得到的差”，假如例一中接着给出点 ，那么残差就是 。可以发现差别不是很大。 2. 线性相关系数 稍难一些，计算量也比较大。样本线性相关系数定义为 。也就是样本的协方差除以根号下 方差的积。与上边残差分析相比，它能通过 的符号判断 究竟是呈现正相关还是负相关，并且 越接近 ，变量之间的线性相关度就越高（拟合效果更好）。例一条件下计算得 ，可知 呈正相关关系，且线性相关关系度高，可以用一条直线近似拟合出来。 那么至此我们就完成了一个典型的线性回归方程的例题，接下来看更复杂的情况。 一般形式的最小二乘法 首先引入一个例题，作为例一的加强版： Example 2. Science of Prescience Pt.II 我们都知道，命运是捉摸不定的，在起起落落间交替…… 你请求太卜大人帮你预测一下近些日子的运势，尽管符玄早已看破你的小心思，但她还是决定给你一次机会。 人生有诸多起伏，符玄从中摘取了一段，并随机挑出了一些散点，拿到你的面前。你发现这些散点近似组成了一个二次函数，符玄也肯定了这点。你的任务是写出一段二次解析式，使得该函数与给出的散点之间的误差最小，并计算当 时 的值。 编号 x y 1 3 4 2 1.5 8.5 3 -0.5 0.5 4 2 8 在二次最小二乘法问题中， 的求解将变得极为复杂。因此我们引入一个新方法来计算拟合曲线。 假设二次函数为 ，令矩阵 ；矩阵 ；矩阵 。那么有 ，也就是 ，根据这个公式就可以直接求出二次函数的系数了。类似地，若需要拟合更高次数的函数，只需更改 矩阵的形式即可（并按需填充 矩阵的值）。需要注意的是， 次拟合要求至少给出 个点的明确坐标，否则这个方法无效。 总结一下，矩阵二乘法的公式是类似于 的形式。因为高考只涉及线性回归方程的计算，而在某些情况下，矩阵法计算最小二乘会更加容易和好算（尤其是 或 出现了小数点的情况下），同时它的公式也比一般的最小二乘公式简便。适合秒选择题（不过一般高考会给出 的计算公式，最终还是按需取用）","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.cn/tags/%E5%AD%A6%E6%9C%AF/"}]},{"title":"闫氏DP 学习笔记 二","slug":"yans-dp-learning-notes-ii","date":"2024-03-15T00:16:46.781Z","updated":"2024-03-22T02:48:44.982Z","comments":true,"path":"articles/24864/","link":"","permalink":"https://justpureh2o.cn/articles/24864/","excerpt":"","text":"书接上文：学习笔记 一 背包DP 进阶 多维费用背包 顾名思义，在背包中加入多个限制。例如每个物品都有一定的体积和质量，要求在最大体积和最大质量的限制下选出总价值最高的物品。通过加入合适的限制，这样的背包问题就会更加切合现实情况。多维费用背包的模型更贴近于生活中我们经常面临的多决策问题，因而它的求解更具有现实意义。 “多维费用”在我看来其实是一种状态设计的思想，其实并不是某种特定类型的物品取用方式，所以不宜和0/1背包等按物品取用方式区分的背包类型混为一谈。正因如此，多维费用背包问题中也会出现0/1背包、完全背包、多重背包的影子。下面的两道题目就是最好的例证： 洛谷 P1507 NASA的食物计划 题目传送门：这里 题目难度：普及- NASA（美国航空航天局）因为航天飞机的隔热瓦等其他安全技术问题一直大伤脑筋，因此在各方压力下终止了航天飞机的历史，但是此类事情会不会在以后发生，谁也无法保证。所以，在遇到这类航天问题时，也许只能让航天员出仓维修。但是过多的维修会消耗航天员大量的能量，因此 NASA 便想设计一种食品方案，使体积和承重有限的条件下多装载一些高卡路里的食物。 航天飞机的体积有限，当然如果载过重的物品，燃料会浪费很多钱，每件食品都有各自的体积、质量以及所含卡路里。在告诉你体积和质量的最大值的情况下，请输出能达到的食品方案所含卡路里的最大值，当然每个食品只能使用一次。 输入第一行 个整数，分别代表体积最大值 和质量最大值 。 输入第二行 个整数代表食品总数 。 接下来输入的 行每行 个数 体积 ，质量 ，所含卡路里 。 输出一个数，表示所能达到的最大卡路里（int 范围内） 数据范围： 对于 的数据，，，。 读题我们会发现，这道题设置了两个限制条件：其一为体积、其二是质量。那么该如何设计求解方案来求解呢？ 运用0/1背包的思想，每个物品其实都只有“选”和“不选”两种情况。假设目前是第 个物品：如果不选，就相当于是选前 个物品的最大价值；反之就需要将背包的剩余体积和质量给更新了。我们还可以观察到，这两个限制条件是互不影响的，均分别取决于选择的物品的性质，那事情就很好办了。在dp数组里设置两个分立的维度，分别代表当前背包的剩余容量和剩余承重量，然后借助滚动数组的一点点知识就可以解决了。 代码： 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define M 410using namespace std;int dp[M][M], vol[M], val[M], mas[M];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int h, t, n; cin &gt;&gt; h &gt;&gt; t &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; vol[i] &gt;&gt; mas[i] &gt;&gt; val[i]; } for (int i = 1; i &lt;= n; i++) { for (int j = t; j &gt;= mas[i]; j--) { for (int k = h; k &gt;= vol[i]; k--) { dp[j][k] = max(dp[j][k], dp[j - mas[i]][k - vol[i]] + val[i]); } } } cout &lt;&lt; dp[t][h] &lt;&lt; endl; return 0;} 总用时： 记录 洛谷 P1541 乌龟棋 题目传送门：这里 题目难度：普及+/提高 题目来源：NOIp 提高组 2010 NOIP2010 提高组 T2 小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。 乌龟棋的棋盘是一行 个格子，每个格子上一个分数（非负整数）。棋盘第 格是唯一的起点，第 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。 乌龟棋中 张爬行卡片，分成 种不同的类型（ 张卡片中不一定包含所有 种类型的卡片，见样例），每种类型的卡片上分别标有 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。 游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。 很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。 现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？ 输入： 每行中两个数之间用一个空格隔开。 第 行 个正整数 ，分别表示棋盘格子数和爬行卡片数。 第 行 个非负整数，，其中 表示棋盘第 个格子上的分数。 第 行 个整数，，表示 张爬行卡片上的数字。 输入数据保证到达终点时刚好用光 张爬行卡片。 输出： 一个整数，表示小明最多能得到的分数。 每个测试点 1s。 对于 的数据有 ，且 种爬行卡片，每种卡片的张数不会超过 ；。 输入保证了用完所有爬行卡片后刚好到达终点，也就是说 。我们真正需要去担心的还是这 张卡片的顺序问题。 既然是多维费用背包，那我们就要找到其背后的限制条件，我们看看，每次前进某格时，什么量是变化的？ 答案很明显了——卡牌的个数。我们进一步想——每种类型卡牌的个数。接下来就可以设计数组了！ 考虑dp数组，状态dp[a][b][c][d]表示目前已经使用过 张四种类型的卡牌后的最大价值。在读入时进行统计，接着挨个枚举“选”和“不选”的情况即可。 那么如何确定状态转移呢？ 当前所在格子的编号很显然取决于使用过的爬行卡牌的类型和数目，假设四类卡牌分别使用了 次，起始点编号为 ，那么当前格子编号就是 。 最后注意初始化，在一张卡牌都不选的情况下，也能得到第一个格子的分数！这是读题可以读出来的信息。以及下标判负（见代码） 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define N 45#define M 370#define K 130using namespace std;int dp[N][N][N][N], mp[M], st[K];int getIdx(int a, int b, int c, int d) { // 获取下标 return 1 + a + b * 2 + c * 3 + d * 4;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; mp[i]; } for (int i = 1; i &lt;= m; i++) { // 统计每种类型卡牌的个数 int x; cin &gt;&gt; x; st[x]++; } dp[0][0][0][0] = mp[1]; // 记住初始化 for (int a = 0; a &lt;= st[1]; a++) { for (int b = 0; b &lt;= st[2]; b++) { for (int c = 0; c &lt;= st[3]; c++) { for (int d = 0; d &lt;= st[4]; d++) { int now = mp[getIdx(a, b, c, d)]; if (a) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a - 1][b][c][d] + now); if (b) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a][b - 1][c][d] + now); if (c) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a][b][c - 1][d] + now); if (d) dp[a][b][c][d] = max(dp[a][b][c][d], dp[a][b][c][d - 1] + now); } } } } cout &lt;&lt; dp[st[1]][st[2]][st[3]][st[4]] &lt;&lt; endl; return 0;} 总用时： 记录 分组背包 一般形式是——在 组中选择总重量不超过限制的、且总价值最高的一些物品，且最多在每组物品中选择其中一个计入总价值。由于这类背包描述了特定的物品选择方式，和多维费用不同，它是一种和0/1背包、完全背包、多重背包同类型的背包。 洛谷 P1757 通天之分组背包 题目传送门：这里 题目难度：普及- 自 背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于 背包，他的物品大致可分为 组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。 输入两个数 ，表示一共有 件物品，总重量为 。 接下来 行，每行 个数 ，表示物品的重量，利用价值，所属组数。 输出一个数，最大的利用价值。 数据范围： ，，， 在 int 范围内。 其实类似0/1背包的思路，因为每一组物品中至多选一个，我们就遍历某一组物品，在其中执行选或不选的判断就好。 因此我们大概需要设计三重循环——分别要枚举组数、当前组的每件物品和剩余容量。考虑到题目限制，每一组只能最多选出一件物品，因此将组数枚举放在最外层、接着是剩余价值、最后是每一组的物品。 加入“分组”的概念后，二维数组w[i][j]就代表第 组的第 个物品的价值，v 数组同理。 如果把剩余价值和每组物品枚举的顺序搞反了呢？那么输出将会是15，不难发现：程序选择了第一组的两个物品，与“每组至多选择一个物品”的要求有悖。细化到执行逻辑本身，如果每组物品的枚举放在了外边，假设当前是第 个物品，那么对于可能循环到的剩余价值 和 ，都有可能做出“选择”这一操作；接着是第 个物品，同样可能循环到剩余价值 与 ，也有可能做出“选择”这一操作，总体来说，就是这一组的第 和第 组物品都被选择了，也就造成了同一组选择超过一件物品的情况。 代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define M 110#define N 1010using namespace std;int w[M][N], v[M][N];int cnt[M], dp[N];int gr = 0;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin&gt;&gt;m&gt;&gt;n; for (int i = 1; i &lt;= n; i++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; gr = max(gr, c); v[c][++cnt[c]] = a; w[c][cnt[c]] = b; } for (int i = 1; i &lt;= gr; i++) { for (int k = m; k &gt;= 0; k--) { for (int j = 1; j &lt;= cnt[i]; j++) { if (k &gt;= v[i][j]) dp[k] = max(dp[k], dp[k - v[i][j]] + w[i][j]); } } } cout &lt;&lt; dp[m] &lt;&lt; endl; return 0;} 总用时： 记录 树形背包 顾名思义，树形背包是在树形结构上运行的背包算法。一般来说，树形背包所求的问题和树的边权、点权相关。 洛谷 P2015 二叉苹果树 题目传送门：这里 题目难度：普及+/提高 有一棵苹果树，如果树枝有分叉，一定是分二叉（就是说没有只有一个儿子的结点） 这棵树共有 个结点（叶子点或者树枝分叉点），编号为 ，树根编号一定是 。 我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有 个树枝的树： 123452 5 \\ / 3 4 \\ / 1 现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。 给定需要保留的树枝数量，求出最多能留住多少苹果。 输入第一行有 个整数 和 ，分别表示表示树的结点数，和要保留的树枝数量。 接下来 行，每行 个整数，描述一根树枝的信息：前 个数是它连接的结点的编号，第 个数是这根树枝上苹果的数量。 输出一个数，最多能留住的苹果的数量。 数据范围： ，每根树枝上的苹果 。 树上背包怎么做呢？ 联想一下数字三角形这道题，当时我们选择从下往上的更新方式。这道题也可以用这样的思想来解决，但是最大的一个问题是这道题的树并没有数字三角形那么规整，因此采用深搜到子节点，再向上更新的方式来更新状态。 在这道题中，我们设置dp数组为dp[u][i]，含义是以 为根，且选择了子树里 条边的方案的最大边权和。 我们把样例画成一个树状图： 样例输出 ，就是将边 和边 删去、保留节点 。 假设当前深搜到节点 ，发现无法继续向下搜索，于是开始更新边：对于边 ，可以选、也可以不选。如果不选，很简单，根据滚动数组思想，就是dp[u][i]本身；如果选择这条边，就很有意思了—— 子节点不好解释，让我们向上移动一下。假设当前在 号点上DP ，对于数组第二维，可以枚举的值在 内：即一条边都不选、选子树的某一条边、子树两条边都选上。不难发现，变量的取值是 ，其中 是以节点 为根的所有子树的边数之和。 然后是前驱状态的问题，既然顺序是从下到上，那状态dp[u][j]就是从dp[son(u)][j - 1]转移来的，这里为什么是 ？因为根节点 和这个子树的根节点 中间还连了一条边，因此需要将它排除在外。循环变量 为上述数组第二维的值，用来枚举可选择的子树的边数。那么子树需要选择 条边，算上刚刚的特殊边 ，根节点 对应的树就只需要选择 条边了。最后，因为选中了边 ，因此需要累加边权，状态转移方程就是 dp[u][j] = max(dp[u][j], dp[u][j - k - 1] + dp[son(u)][j] + w[to[i]]) 注意存无向边，因此前向星结构体数组要开 ！血的教训 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define N 110using namespace std;int h[N];int cnt[N], dp[N][N];int idx = 0;int n, q;struct Edge { int to, ne, w;} edges[N &lt;&lt; 1];void add(int u, int v, int x) { edges[idx].to = v; edges[idx].w = x; edges[idx].ne = h[u]; h[u] = idx++;}void dfs(int now, int fa) { for (int i = h[now]; ~i; i = edges[i].ne) { int son = edges[i].to; if (son == fa) continue; dfs(son, now); cnt[now] += (cnt[son] + 1); for (int j = min(q, cnt[now]); j; j--) { for (int k = min(j - 1, cnt[son]); k &gt;= 0; k--) { dp[now][j] = max(dp[now][j], dp[now][j - k - 1] + dp[son][k] + edges[i].w); } } }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt; n; i++) { int u, v, x; cin &gt;&gt; u &gt;&gt; v &gt;&gt; x; add(u, v, x); add(v, u, x); } dfs(1, -1); cout &lt;&lt; dp[1][q] &lt;&lt; endl; return 0;} 总用时： 记录 洛谷 P1352 没有上司的舞会 谨以此题，缅怀高2022届那五位被蓝桥杯官方送来的双倍经验雷倒的OIer们 题目传送门：这里 题目难度：普及+/提高 来源：福建省历届夏令营 某大学有 个职员，编号为 。 他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。 现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 ，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。 所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 输入： 第一行是一个整数 。 第 到第 行，每行一个整数，第 行的整数表示 号职员的快乐指数 。 第 到第 行，每行输入一对整数 ，代表 是 的直接上司。 输出： 输出一行一个整数代表最大的快乐指数。 对于 的数据，保证 $1n ^3 ，-128 r_i$，，且给出的关系一定是一棵树。 同样是一道经典的树形背包问题。但是和上面那个二叉苹果树不同，这道题相当于求一定条件下的点权最大和、而上一道题则是求边权最大和，因而这道题的状态表示策略稍有不同——让dp[i][0]代表员工 不来参加舞会的最大欢乐值，dp[i][1]代表员工 前来参加舞会的最大欢乐值。那么很明显，状态之间的关系就出来了。 如果这个员工不来参加，那么他的直接下属，也就是节点 直接相连的子节点，就可以自由选择来或不来，因为他的直接上司选择了不来舞会；如果这个员工参加了舞会，那么他的直接下属是无论如何也不会来的。这样就形成了一个递归的过程，看得出来父节点的状态最大值取决于子节点的“来”和“不来”状态的最大值，因此对于大boss来讲（树的根节点），只要对他“来”和“不来”两种状态取最大值即可解决问题。 整体采用深搜到子节点然后向上更新的方式，这一点和二叉苹果树相似（不用更新子树边数和），用上刚才分析的状态转移就好。值得注意的是，对每个节点的一号状态——也就是“来参加”，需要初始化成该点的欢乐值。寻根采用输入时累加节点入度的方法，如果入度为 则证明该点是树的根节点，从这里开始深搜即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define N 6010using namespace std;typedef long long ll;struct Edge { int to, ne;} edges[N &lt;&lt; 1];int dp[N][2], h[N], w[N], size[N];int indeg[N];int idx = 0, n;void add(int u, int v) { idx++; edges[idx].to = v; edges[idx].ne = h[u]; h[u] = idx;}void dfs(int now, int fa) { for (int i = h[now]; ~i; i = edges[i].ne) { int son = edges[i].to; if (son == fa) continue; dfs(son, now); dp[now][0] += max(dp[son][0], dp[son][1]); dp[now][1] += dp[son][0]; }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(h, -1, sizeof h); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; w[i]; } for (int i = 1; i &lt; n; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; indeg[v]++; add(u, v); add(v, u); } int rt = -1; for (int i = 1; i &lt;= n; i++) { if (!indeg[i]) { rt = i; break; } } for (int i = 1; i &lt;= n; i++) dp[i][1] = w[i]; dfs(rt, -1); cout &lt;&lt; max(dp[rt][0], dp[rt][1]) &lt;&lt; endl; return 0;} 总用时： 记录 有人说数据水了，我挺赞同的…… 有依赖的背包 顾名思义，有依赖的背包在选择物品时要注意主物品和副物品的从属关系。一般来说，在选择副物品前，要先把对应的主物品选择了。实质上它是一种变形的0/1背包，因此在状态转移方面和0/1背包的状态转移方程有诸多相似之处。 洛谷 P1064 金明的预算方案 题目传送门：这里 题目难度：普及+/提高 来源：NOIp 提高组 2016 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 个、 个或 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 元。于是，他把每件物品规定了一个重要度，分为 等：用整数 表示，第 等最重要。他还从因特网上查到了每件物品的价格（都是 元的整数倍）。他希望在不超过 元的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第 件物品的价格为 ，重要度为，共选中了 件物品，编号依次为 ，则所求的总和为： 。 请你帮助金明设计一个满足要求的购物单。 输入第一行有两个整数，分别表示总钱数 和希望购买的物品个数 。 输入第 到第 行，每行三个整数，第 行的整数 ，， 分别表示第 件物品的价格、重要度以及它对应的的主件。如果 ，表示该物品本身是主件。 输出一行一个整数表示答案。 对于全部的测试点，保证 ，，，，，答案不超过 。 NOIP 2006 提高组 第二题 这道题属于是这类背包的经典入门题。不难发现，它有很明显的从属选择关系——主物品和附件。 那么在设计转移方程时就要注意，此时我们的选择方案已经不再是普通0/1背包单纯的“选”和“不选”了。而是“选哪些”和“不选”两种思考方向。 分类讨论可以发现，选择方案分五种：第一种是只选主物品、第二种是只不选主物品、第三种是选主物品且只选第一个附件、第四种是选主物品且只选第二个附件、最后一个是选主物品和所有两个附件。那么在设计转移方程时只需要分类判断 和 的大小关系，注意倒序循环！ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define N 32010#define M 110using namespace std;int dp[N], w[M][3], v[M][3], cnt[M];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cnt[c]++; if (!c) { v[i][0] = a; w[i][0] = a * b; } else { v[c][cnt[c]] = a; w[c][cnt[c]] = a * b; } } for (int i = 1; i &lt;= m; i++) { for (int j = n; j &gt;= v[i][0]; j--) { if (!v[i][0]) break; dp[j] = max(dp[j], dp[j - v[i][0]] + w[i][0]); if (j &gt;= (v[i][0] + v[i][1] + v[i][2])) dp[j] = max(dp[j], dp[j - v[i][0] - v[i][1] - v[i][2]] + w[i][0] + w[i][1] + w[i][2]); if (j &gt;= v[i][0] + v[i][1]) dp[j] = max(dp[j], dp[j - v[i][0] - v[i][1]] + w[i][0] + w[i][1]); if (j &gt;= v[i][0] + v[i][2]) dp[j] = max(dp[j], dp[j - v[i][0] - v[i][2]] + w[i][0] + w[i][2]); } } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;} 总用时： 记录","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"dp","slug":"dp","permalink":"https://justpureh2o.cn/tags/dp/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://justpureh2o.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"OI算法——矩阵加速递推","slug":"matrix-acceleration","date":"2024-03-13T02:42:32.793Z","updated":"2024-03-23T07:10:39.858Z","comments":true,"path":"articles/11861/","link":"","permalink":"https://justpureh2o.cn/articles/11861/","excerpt":"","text":"在开始之前，确保你至少已经学会了矩阵乘法的计算方法。 矩阵加速递推（后边简称矩阵递推）充分利用了初等矩阵的性质，可以将原本耗时间费空间的函数递归、优化但复杂度较高的记忆化搜索进一步加速为复杂度仅 的对数级别算法（ 一般为 或 ）。在数据范围很大时可以考虑使用。 矩阵乘法是如何起作用的 初等矩阵——概念及用法，花一点篇幅来复习一下： 初等行变换： 交换矩阵某两行 将某一行的元素全部乘以一个非零数 将某一行的非零倍加到另一行上 非常简单，甚至我们化简多元方程式都会用到上边的变换。事实上，如果把一次方程组的系数和常数项按一定顺序排列起来，将会得到一个系数矩阵，系数矩阵经过一系列化简和反代也可以解出原方程组的解。 考虑一个单位矩阵 ，它很特殊，和实数运算的 类似：任何矩阵左乘和右乘单位矩阵所得的乘积矩阵都是这个矩阵本身。顺便说一句，矩阵乘法一般不符合乘法交换律，但单位矩阵乘法除外，也就是说当矩阵长和宽符合要求时，就有 成立。 那么一个初等矩阵就是单位矩阵只进行一次初等行变换得到的矩阵。进行变换法则的第几条就是第几类初等矩阵。一般来说，矩阵递推里的转移矩阵不属于初等矩阵，因为它通常会经过不止一次的初等行变换。递推时，如果初始矩阵是一列数，那么一般选择左乘转移矩阵；如果是一行数字，就选择右乘。（具体情况具体分析） 接下来进入正题： 假如有下边这个递推关系 初始情况下，我们向矩阵中放入两个元素：。我们希望构造出一个转移矩阵使得转移后的结果就是前两个元素相加的和（根据递推方程），做一次乘法，矩阵变为 ；再来一次，变成 。不难发现，当做了 次乘法后，矩阵变为 。所以假设我们的转移矩阵是 ，，其中矩阵 。就基本搞清楚了矩阵递推的原理了。 矩阵结构体 函数I()的功能是构造单位矩阵，后面会涉及到定义它的原因。整体思路就是定义二维数组存放矩阵元素，声明时对内部元素自动置零，以及构造单位矩阵 123456789101112struct Matrix { ll mat[N + 1][N + 1]; Matrix() { memset(mat, 0, sizeof mat); } void I() { memset(mat, 0, sizeof mat); for (int i = 1; i &lt;= N; i++) mat[i][i] = 1; }}; 矩阵快速幂 和实数运算一样，矩阵自乘也可以用二进制快速幂的方式快速求解，复杂度是 的。 下边是实数快速幂的代码（带取模）： 123456789int qpow(int a, int b) { int res = 1; while (b) { if (b &amp; 1) res = (ll) res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;} 原理不再赘述。如果想要把它改造成适用于矩阵的快速幂算法，我们就需要实现这两个运算： 矩阵乘法 矩阵置一 对于第一点，我们根据矩阵乘法的定义可以很轻松写出代码。一般来说，重载运算符是一个很方便的办法（注意如果重载在结构体内就需要在函数定义时加上friend友元访问权）： 1234567891011Matrix operator *(const Matrix &amp;l, const Matrix &amp;r) { Matrix res; for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= N; j++) { for (int k = 1; k &lt;= N; k++) { res.mat[i][j] += (l.mat[i][k] * r.mat[k][j]); res.mat[i][j] %= MOD; } } }} 那么“置一”是什么呢？ 相当于实数快速幂里的int res = 1;，试想一个全新定义的零矩阵（元素全为零）拿去计算乘法，最终的结果总会是零。因此我们就需要找到和 作用相同的矩阵，赋上初值，计算出来的结果才是正确的。于是很自然想到了单位矩阵，结构体中的I()函数用于将矩阵变为一个主对角线元素全为 、其他元素均为 的矩阵。 类比实数快速幂，矩阵快速幂是这样的： 12345678910Matrix qpow(Matrix a, int b) { Matrix res; res.I(); while (b) { if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; } return res;} 此时就不能图省事用*=运算符了（除非你另外重载，但这样会更麻烦） 转移矩阵的构造 转移矩阵可谓是矩阵递推题目的灵魂所在，合理地构造转移矩阵可以达到事半功倍的效果。接下来通过几个例子来深入探究转移矩阵的构造方法： 洛谷 P1962 斐波那契数列 题目传送门：这里 题目难度：普及+/提高 大家都知道，斐波那契数列是满足如下性质的一个数列： 请你求出 的值。 输入一行一个正整数 输出一行一个整数表示答案。 数据范围： 对于 的数据，； 对于 的数据，。 正如这头图所示，我们的初始矩阵是 ，转移矩阵是 。 就是 的第一个元素。嘎嘎好用是不是 首先，要求出某一项，就必须明确它的前两项。因此我们让初始矩阵填上 和 。对于转移，我们有一个非常好的小技巧：整体左移——这就好比一个滑动窗口（但不是单调队列那个），斐波那契数列按顺序排列在一起：。最开始这个矩阵框住了 和 ，操作一次，它框住 和 ，以此类推……每次挪一下，因此做了 次乘法后就挪到了 的位置。那我们怎么构造这种转移矩阵呢？ 所谓左移，就是让 换到 的位置来，根据矩阵乘法系数配对的原理。对于转移矩阵第一列，就是下面这样： 第二列也很简单，对原先的转移矩阵的两个元素都配上系数 即可： 于是代码就出来了（不开long long见祖宗）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define N 15using namespace std;typedef long long ll;const int MOD = 1e9 + 7;struct Matrix { ll mat[N][N]; Matrix() { memset(mat, 0, sizeof mat); } void I() { memset(mat, 0, sizeof mat); for (int i = 1; i &lt;= 2; i++) mat[i][i] = 1; }};Matrix operator *(const Matrix &amp;l, const Matrix &amp;r) { Matrix res; for (int i = 1; i &lt;= 2; i++) { for (int j = 1; j &lt;= 2; j++) { for (int k = 1; k &lt;= 2; k++) { res.mat[i][j] += (l.mat[i][k] * r.mat[k][j]); res.mat[i][j] %= MOD; } } } return res;}Matrix qpow(Matrix a, ll b) { Matrix res; res.I(); while (b) { if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; } return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); ll n; cin &gt;&gt; n; Matrix A, M; A.mat[1][1] = A.mat[1][2] = 1; M.mat[1][2] = M.mat[2][1] = M.mat[2][2] = 1; A = A * qpow(M, n - 1); cout &lt;&lt; A.mat[1][1] % MOD &lt;&lt; endl; return 0;} 总用时： 记录 这种类型的题还有洛谷 P1349 广义斐波那契数列，同样是左移技巧，只不过转移矩阵要稍作变动。 洛谷 P1397 矩阵游戏 题目传送门：这里 题目难度：提高+/省选 题目来源：NOI 2013 NOI 2012 和 2013连着两年都考了矩阵递推，真的强！ 婷婷是个喜欢矩阵的小朋友，有一天她想用电脑生成一个巨大的 行 列的矩阵（你不用担心她如何存储）。她生成的这个矩阵满足一个神奇的性质：若用 来表示矩阵中第 行第 列的元素，则 满足下面的递推式: 递推式中 都是给定的常数。 现在婷婷想知道 的值是多少，请你帮助她。由于最终结果可能很大，你只需要输出 除以 的余数。 输入包含一行，有六个整数 。意义如题所述。 输出包含一个整数，表示 除以 的余数。 数据范围： 这道题需要我们推一个式子，因为递推公式出现了两种情况，我们就需要两个不同的转移矩阵。假设一个为 ，一个为 ，分别对应递推式里的系数，以及一个初始矩阵 。 这里出现了常数项，通常选择在初始矩阵中放入一个常量 ，每次递推将它乘以这个常数、并且需要保证它不被转移矩阵改变，这样一来才能保证递推稳定运行。 那么在初始矩阵的第二列放上常量 ，以 为例，要满足递推关系，未知数和 的系数分别是 和 ，于是转移矩阵第一列就是 ，第二列就是 。 同理有：、、。 接下来根据题目描述，要想一路推到右下角的 ，首先就得把 弄出来，而这一行又从 递推得来，以此类推……那么每一行最右边的元素和该行第一个元素的关系就是 ，又因为矩阵共 行，每一行的开头还得乘上一个 ，因此公式就是：。再看看数据范围，十的一百万次方？？？太抽象了，对于这么大的幂，普通的位运算快速幂已经满足不了时限了，于是我们引入一种高级方法——十进制快速幂： 快速幂基于数字的拆位，所以我们可以选择在十进制表示下拆位运算。因此就算是十的一百万次方，应用十进制快速幂就会让复杂度降落不少，因此我们试验这个方法： 十进制矩阵快速幂： 12345678910111213141516Matrix dec_qpow(Matrix a, string b) { Matrix res; res.I(); int len = b.length(); while (len) { int p = b[len - 1] - '0'; if (p) { for (int i = 1; i &lt;= p; i++) { res = res * a; } } for (int i = 1; i &lt;= 10; i++) a = a * a; len--; } return res;} 当然可以用二进制快速幂取代中间的循环乘幂，代码会简洁一些： 123456789101112Matrix dec_qpow(Matrix a, string b) { Matrix res; res.I(); int len = b.length(); while (len) { int p = b[len - 1] - '0'; res = res * bin_qpow(a, p); a = bin_qpow(a, 10); len--; } return res;} 然后我们再来算上面推出的式子，考虑到变量 和 必须要用字符串读入，可以用高精度的思想对二者进行预处理，将它们的值分别减少 ，然后将处理后的字符串作为参数传入快速幂函数中计算即可。下边是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define N 5using namespace std;const int MOD = 1e9 + 7;typedef long long ll;struct Matrix { ll a[N][N]; Matrix() { memset(a, 0, sizeof a); } void I() { a[1][1] = a[2][2] = 1; }} A, M, S;Matrix operator *(const Matrix &amp;l, const Matrix &amp;r) { Matrix res; for (int i = 1; i &lt;= 2; i++) { for (int j = 1; j &lt;= 2; j++) { for (int k = 1; k &lt;= 2; k++) { res.a[i][j] = (res.a[i][j] + l.a[i][k] % MOD * r.a[k][j] % MOD) % MOD; } } } return res;}Matrix bin_qpow(Matrix a, ll b) { Matrix res; res.I(); while (b) { if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; } return res;}Matrix dec_qpow(Matrix a, string b) { Matrix res; res.I(); int len = b.length(); while (len) { int p = b[len - 1] - '0'; for (int i = 1; i &lt;= p; i++) { res = res * a; } a = bin_qpow(a, 10); len--; } return res;}string init(string s) { for (int i = s.length() - 1; i &gt;= 0; i--) { if (s[i] == '0') s[i] = '9'; else { s[i]--; break; } } return s;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); string n, m; ll a, b, c, d; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; A.a[1][1] = 1, A.a[1][2] = 1; M.a[2][2] = 1, M.a[1][1] = a, M.a[2][1] = b; S.a[2][2] = 1, S.a[1][1] = c, S.a[2][1] = d; n = init(n), m = init(m); Matrix T = A * dec_qpow((dec_qpow(M, m) * S), n) * dec_qpow(M, m); cout &lt;&lt; T.a[1][1] % MOD &lt;&lt; endl; return 0;} 这段代码只能得80分，最后四个点TLE了。此时有两种解决办法，第一是卡常——将矩阵乘法的三层循环完全展开、内联函数、加法取模，可以将代码运行时间压到 （最慢的点 ）记录。 矩阵递推的变式 广义矩阵乘法 相信你已经背下了矩阵乘法的模板了，为了避免遗忘，再在这里给出矩阵乘法的一般定义：假设一个 的矩阵 和一个 矩阵 相乘，就有： 最终结果 ，满足 为一个 矩阵。 那么是不是非得要求和和相加呢？当然不是，对于一般的矩阵乘法，才会像上边一样对乘积求和。广义矩阵乘法不仅限于上边的“对积求和”的规则，它还可以做到“对位与求位或和”。接下来探讨广义矩阵乘法所要满足的条件： 定义运算符 为“异加”（变种加法）、 为“异乘”（变种乘法）。假如还是上面的 矩阵，那么广义矩阵乘法将是这种形式： 要想让这种运算关系能够支持递推算法，那就必须使算式 成立才行。而这个转化很明显是将连乘的 结合为矩阵的幂，因此只要上边的新定义算式满足乘法结合律，就可以被归入广义矩阵乘法的范畴内。假设此时有 三个能够相乘的矩阵，那么： 换句话说： 类比一般加法和乘法。当 运算符合交换律、结合律；并且 成立，则原式化简为：","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"Volantis魔改记录","slug":"blog-personalization","date":"2024-02-21T23:18:20.738Z","updated":"2024-05-01T06:01:36.403Z","comments":true,"path":"articles/14712/","link":"","permalink":"https://justpureh2o.cn/articles/14712/","excerpt":"","text":"在此记录我个人对博客的一些个性化改造 本博客使用Volantis（v6 alpha 1）主题。 前端类 刷新式Banner 对视差滚动插件进行改造，将原先的定时更换变为了刷新更换，以减少窗口重获焦点后重复加载图片的问题。 themes/volantis/layout/_plugins/parallax/script.ejs 1234567891011121314151617181920212223242526// In function 'parallax()'// ... next_parallax(); Parallax.init(); index++;/* - if (imgs.length&gt;1) { - IntervalParallax = setInterval(function () { - next_parallax(); - }, '&lt;%- theme.plugins.parallax.duration %&gt;'); - } */// In function 'next_parallax()'// ... if (imgs.length&gt;=1) { // + Parallax.options.src = imgs[new Date().getTime() % imgs.length]; Parallax.options.src = imgs[new Date().getTime() % imgs.length]; // - Parallax.options.src = imgs[index % imgs.length]; Parallax.start(); index++; if (Parallax.cache) { fetch(imgs[index % imgs.length] +\"?t=\" + new Date().getTime()); if (index == imgs.length) { Parallax.cache = 0; } } } 在这里查看本网站的Banner信息 预览新Banner效果（多次刷新效果更佳） OJ网站题目标签 简化了洛谷样式的HTML标签 添加了常用OJ网站（洛谷、AcWing）的题目难度标签CSS，现在可以直接通过span标签显示： 洛谷风格 printf(\"China\"); 用脚切的题 只用一只手切的题 大规模出现DP、字符串、模拟等恶心题 恭喜你进阶提高组 只要线代学得好，蓝题狂刷少不了 同学，网络流好学吗 构造秒了 题目来源：收钱协会举办的比赛之提高组 收钱协会举办的比赛之普及组 多 人 信 息 学 比 赛 残 害 奶 牛 组 织 举 办 的 比 赛 相关比赛年份：2024 2023 2077 2233 算法标签：大模拟 退火邪教 毒瘤数据结构 卡常 特殊题目标签：氧气优化,O2 臭氧优化,O3 四聚氧优化,O4 红氧优化,O8 题目来源区域：蒙德城 璃月 稻妻城 须弥城 枫丹廷 以上均为整活 本站使用的span标签： 1234567891011121314151617181920212223242526&lt;!-- 题目难度 --&gt;&lt;span data-luogu data-grey&gt;暂无评定&lt;/span&gt;&lt;span data-luogu data-red&gt;入门&lt;/span&gt;&lt;span data-luogu data-orange&gt;普及-&lt;/span&gt;&lt;span data-luogu data-yellow&gt;普及/提高-&lt;/span&gt;&lt;span data-luogu data-green&gt;普及+/提高&lt;/span&gt;&lt;span data-luogu data-blue&gt;提高+/省选&lt;/span&gt;&lt;span data-luogu data-purple&gt;省选/NOI-&lt;/span&gt;&lt;span data-luogu data-black&gt;NOI/NOI+/CTSC&lt;/span&gt;&lt;!-- 题目来源 --&gt;&lt;span data-luogu data-source&gt;NOIp 提高组&lt;/span&gt;&lt;!-- 相关比赛年份 --&gt;&lt;span data-luogu data-date&gt;2023&lt;/span&gt;&lt;!-- 算法标签 --&gt;&lt;span data-luogu data-algorithm&gt;动态规划,dp&lt;/span&gt;&lt;!-- 特殊题目标签 --&gt;&lt;span data-luogu data-special&gt;O2优化&lt;/span&gt;&lt;!-- 题目来源区域 --&gt;&lt;span data-luogu data-region&gt;四川&lt;/span&gt; 原生CSS标签： 123456789101112.lfe-caption { font-size: 0.875em;}span[data-v-71731098] { display: inline-block; padding: 0 8px; box-sizing: border-box; font-weight: 400; line-height: 1.5; border-radius: 2px;} AcWing风格 简单 中等 困难 本站使用的span标签： 12345&lt;span class=\"label label-success round\"&gt;简单&lt;/span&gt;&lt;span class=\"label label-warning round\"&gt;中等&lt;/span&gt;&lt;span class=\"label label-danger round\"&gt;困难&lt;/span&gt; 原生CSS标签： 12345678910111213141516171819202122232425262728.round { border-radius: 1020px;}.label { display: inline; padding: .2em .6em .3em; font-size: 75%; font-weight: 700; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: .25em;}.label-success { background-color: #5cb85c;}.label-warning { background-color: #f0ad4e;}.label-danger { background-color: #d9534f;} 段落缩进（未启用） 注入以下的CSS代码： 1234.md{ text-align: left text-indent: 2em}","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://justpureh2o.cn/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://justpureh2o.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://justpureh2o.cn/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://justpureh2o.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"https://justpureh2o.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"开发记录","slug":"开发记录","permalink":"https://justpureh2o.cn/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}]},{"title":"闫氏DP 学习笔记 一","slug":"yans-dp-learning-notes","date":"2024-02-19T20:15:55.881Z","updated":"2024-03-15T00:42:54.643Z","comments":true,"path":"articles/1057/","link":"","permalink":"https://justpureh2o.cn/articles/1057/","excerpt":"","text":"说在前面 本博客中“闫氏DP”指的是2011年NOI金牌保送北京大学计算机系的算法选手闫学灿（yxc/y总）在教授动态规划时提出的“从集合角度分析DP问题的思维方式”。并非指代某类动态规划题型、也不是某种求解动态规划的固定算法。该文章仅作“闫氏DP”的学习笔记，一并附上例题的个人理解。为了使文章生动有趣，后文使用“yxc”或“y总”指代闫学灿本人。 代码均经过本人实际测试AC后才给出（故意演示超时的朴素做法也会选择性展出），代码总耗时也会给出，以AC记录的时间为准。代码均由CLion格式化，方便阅读。 了解动态规划 了解DP的大佬可以直接看到下一节~ 动态规划（Dynamic Programming，简称DP）是运筹学的一个分支，用于求解多决策过程的最优解，最初由Bellman等人提出。当一个过程存在多个决策，且每个决策之间都会互相影响（最终影响到结果）时，就可以考虑使用动态规划。动态规划建立在递推关系之上，主张用已有的状态去表示未知的状态。正因如此，找出各个决策所产生的状态之间的关系是至关重要的（这个重要信息后期会被转译为状态转移方程求解DP）。 常见的动态规划根据问题的特点，分别被称作：线性DP，背包，树上DP，区间DP，数位DP，插头DP…… 传统DP分析法 DP自诞生之初就用来解决多决策过程问题，解决多决策问题就需要考虑如下性质，这些也是传统动态规划所考虑的角度： 状态：相当于 dp[i][j]所表示的意义，各个状态之间有内在的联系 无后效性：第 个状态仅由第 个状态决定，而不是其他的任何状态 最优子结构：把最优解拆开成一个个小部分，每个组成最优解的部分也一定是最优的 这样的传统方法看起来比较抽象，但这种方法的确是DP问题的标准解法，因为上述几种性质组成一个完整的动态规划问题。自然针对其组成部分提出的解决方案是最为标准的。 闫氏DP分析法 这张图（讲课板书）很清晰的阐明了闫氏DP分析法的内核，其中动态规划问题的求解依赖于状态的表示和计算，而搞清楚状态表示又需要读题分析需要规划的总集合、以及问题的属性。这个基本框架在求解DP问题中发挥了极其重要的作用。 状态计算里有一个非常重要的地方——搞清楚“前驱状态的转移”。就是需要解释清楚当前的状态是怎么由前面一个状态得到的。虽然说起来用不了几个字，但是这也是DP问题的难点，毕竟转移方程是DP问题的灵魂，得到了方程整个问题也就解决了。 线性DP 迷宫型 线性DP P1216 数字三角形 题目传送门 难度：普及- 观察下面的数字金字塔。 写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。 在上面的样例中，从 的路径产生了最大权值。 这个题似乎连读入都要好好想一想 定义一个二维 map数组，map[i][j]表示第 层从左数第 个数，所以实际读入的数组输出出来会与上图有一些差别，为了与读入保持一致，使用下面给出的数组进行思考： 1234573 88 1 02 7 4 44 5 2 6 5 我们需要解决的问题的总集合就是从第一层走到第五层的可能路径，而属性就是 max（最大值）。这些都是读题能找出来的东西。 接着思考状态表示：摸清楚前驱状态。如果按照正向思维，从上往下遍历（第一次在第一层、第二次在第二层），会有一个问题——不知道前驱状态。那我们就反着来，由最下层向最上层遍历！ 既然向上遍历，我们就脑补一下——把题图里面所有的箭头反向。这样一来上层的总和就可以用下边的点之和来转移了。例如倒数第二层的 ，表示出来就是 dp[4][2]；它可以用下层的 或 得来，分别对应 dp[5][2]和 dp[5][3]。推广一下就是 dp[i][j]可以由 dp[i + 1][j]和 dp[i + 1][j + 1]得来，结合先前所述的状态表示，得出状态转移方程：dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + map[i][j]。那么这个最大和从下边一路推到最上边，到达点 （顶点）时显然就是整个问题的解，因此最后输出 dp[1][1]即可。 最后是初始化：明显地，dp数组的最后一层应该全部赋值为 map数组的最后一层，这样才能让整个算法基于金字塔的最底端进行递推，得到正确答案（或者可以直接用 map数组计算）。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define N 1010using namespace std;int dp[N][N], mp[N][N];int main() { int r; cin &gt;&gt; r; for (int i = 1; i &lt;= r; i ++) { for (int j = 1; j &lt;= i; j ++) { cin &gt;&gt; mp[i][j]; } } for (int i = 1; i &lt;= r; i ++) dp[r][i] = mp[r][i]; // 初始化最后一层 for (int i = r - 1; i &gt;= 1; i --) { // 反着扫每一层 for (int j = 1; j &lt;= r - 1; j ++) { // 每一列 dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + mp[i][j]; } } cout &lt;&lt; dp[1][1] &lt;&lt; endl; return 0;} 由于命名冲突，原文中 map数组实为 mp数组。 总用时： 记录 AcWing1015 摘花生 原题地址：AcWing1015（原AcWing1017） 难度：简单 不知道为什么听课的时候y总说是1017现在变成1015了（但网址还是1017）……可能是题库变动，前面少了两道题吧…… Hello Kitty想摘点花生送给她喜欢的米老鼠。 她来到一片有 行 列的网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。 地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。 Hello Kitty只能向东或向南走，不能向西或向北走。 问Hello Kitty最多能够摘到多少颗花生。 1.gif 这道题属于经典的“走方格最值型线性DP”（自己瞎起的名字），很多DP题目里都有它的影子。例如洛谷 P1176 路径计数2、洛谷 P1958 上学路线和AcWing 1018 最低通行费。 首先读入整个地图，用数组w存储每个点的花生数（点权）。 接下来解题：状态表示，读题——总集合是从点 （左上角）走到点 （右下角）的所有路径，属性则是max。 接下来是状态计算，既然全集是所有合法路径，那我们如何划分这个“合法路径集”呢？ 再读题，它说：“只能向东或向南走”。对应到方向标（上北下南左西右东），那就是只能向右或向下走（不走回头路）一直到右下角。假如她某次移动到了点 （ ），那么她可能是从点 或者是 过来的。既然如此，将两条支路的数据汇集起来，取一个最大值max，不就是整道题的答案吗？因而，状态转移方程就是dp[i][j] = max(dp[i - 1][j] + w[i][j], dp[i][j - 1] + w[i][j])，等价于dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + w[i][j]。由于递推是正向的，到点 结束，因此最终输出dp[r][c]。 当我们高高兴兴写代码的时候就会发现一些问题：如果我在第一列（最左边那一列），按照转移方程，左侧的点将会汇入计算，但第一列左侧的点并不存在；同理，第一行（最上边那一行）的上侧的点也不存在。那么该怎么样处理这样的特殊情况呢？ 一般来说，OIer在开数组存值时，会从下标 开始——但是在计算机中，一个数组真正的下标从 开始。因此可以考虑在第一列和第一行的左侧和上侧点在w数组中设为-INF（ 和负数均可），总之让它们成为“虚点”，对整体结果无实际影响就行。或者在循环中写入特判第一列和第一行的情况，两种方案均可。我选择了比较方便的填充特殊值法，代码在下边给出： 1234567891011121314151617181920212223242526272829303132// 给地图外部的行/列赋特殊值#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define N 110using namespace std;int dp[N][N], w[N][N];int main() { int T, r, c; cin &gt;&gt; T; while (T--) { cin &gt;&gt; r &gt;&gt; c; for (int i = 1; i &lt;= r; i++) { for (int j = 1; j &lt;= c; j++) { cin &gt;&gt; w[i][j]; } } // 初始化特殊行/列 for (int i = 0; i &lt;= r; i++) w[0][i] = -INF; for (int i = 0; i &lt;= c; i++) w[i][0] = -INF; for (int i = 1; i &lt;= r; i++) { for (int j = 1; j &lt;= c; j++) { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + w[i][j]; } } cout &lt;&lt; dp[r][c] &lt;&lt; endl; } return 0;} 当然，这道题也可以不填充特殊值，因为全局定义的数组在内存中的默认值就是0，但为了保险这里还是加上了负无穷的填充。 总用时： 记录 P1004 方格取数 题目传送门 难度：普及+/提高 来源：NOIp 提高组 2000 2008年NOIP官方送来的双倍经验，请注意查收：P1006 传纸条 设有 的方格图 ，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 。如下图所示（见样例）: 某人从图的左上角的 点出发，可以向下行走，也可以向右走，直到到达右下角的 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 ）。 此人从 点到 点共走两次，试找出 条这样的路径，使得取得的数之和为最大。 输入的第一行为一个整数 （表示 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 表示输入结束。 数据范围：。 好家伙，两次DP？？？我们就选择用一个DP数组记录两条路径，同时遍历寻找最优解，最后输出即可。 状态表示就很明朗了，全集是两条从点 走到点 的路径可能性，属性是max。在状态计算方面，我们选用dp[i1][j1][i2][j2]表示第一条路线从 走到了当前的 ；第二条路线从 走到了当前的 。这样来看，我们就只需要判断路径重合的情况：当 时两条路径有可能重合。既然是「有可能」，那也就是说存在误判的情况失手了口牙。这里，y总引入了一个新变量 ，并使上式中的 ，如此操作，就可以删去dp数组的 和 ，转而用dp[k][i1][i2]表示，移项可得 。因为DP操作仅限于这个 的方阵中，所以取值范围 ，最大值就是到达右下角的 ，因此 （严格来说， ）。关于 的循环应该是从 开始一直到 才对。 然后考虑状态之间的转移，就需要找到当前状态和上一个状态之间的联系。dp数组存储了两条路径，第一条路径可能从左侧过来、同时第二条路径也可能从左边过来；第一条从左边来、第二条从上边来；第一条从上边来、第二条从左边来；最后是两条都从上边来的情况。我们显然需要计算出这四种情况的状态后对所有状态联合取最大值，以第一种情况为例：两条都从左边来，那么 就是从 来的；如果是第二种情况，那么 由 过来、 由 来，该情况写成转移方程就是dp[k][i1][i2] = max(dp[k][i1][i2], dp[k - 1][i1][i2] + w[i1][j1] + w[i2][j2])。 最后是重合路径的问题，当 唯一确定， 时， ，所以 ，两点重合。所以当循环内出现 的情况时直接抛除就好。状态转移方程里面也不能按w[i1][j1] + w[i2][j2]加和而是需要按w[i1][j1]进行累加。注意判断 和 是否都在地图范围内。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define N 15using namespace std;int dp[2 * N][N][N], w[N][N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; int x = 1, y = 1, d = 1; while (x || y || d) { // 谨防毒瘤数据权值出成0！！！ // 我也不知道权值会不会是0……保险保险 cin &gt;&gt; x &gt;&gt; y &gt;&gt; d; w[x][y] = d; } for (int k = 2; k &lt;= 2 * n; k++) { // 注意k的取值范围 for (int i1 = 1; i1 &lt;= n; i1++) { for (int i2 = 1; i2 &lt;= n; i2++) { int j1 = k - i1, j2 = k - i2; if (1 &lt;= i1 &lt;= n &amp;&amp; 1 &lt;= i2 &lt;= n &amp;&amp; 1 &lt;= j1 &lt;= n &amp;&amp; 1 &lt;= j2 &lt;= n) { int val = (i1 == i2) ? w[i1][j1] : w[i1][j1] + w[i2][j2]; // 判断是否重合 int &amp;current = dp[k][i1][i2]; // 设置引用缩减码量 current = max(current, dp[k - 1][i1][i2] + val); // 两条都从上边来 current = max(current, dp[k - 1][i1][i2 - 1] + val); // 第一条从上边来，第二条从左边来 current = max(current, dp[k - 1][i1 - 1][i2] + val); // 第一条从左边来，第二条从上边来 current = max(current, dp[k - 1][i1 - 1][i2 - 1] + val); // 两条都从左边来 } } } } cout &lt;&lt; dp[2 * n][n][n] &lt;&lt; endl; return 0;} 总用时： 记录 来都来了，顺便放一下传纸条的代码，两道题思路是相同的（状态转移方程都不需要改！），但是读入有点恶心，一定注意读入问题！ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define N 110using namespace std;int dp[2 * N][N][N], w[N][N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; // 注意读入问题 for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { int d; cin &gt;&gt; d; w[i][j] = d; } } for (int k = 2; k &lt;= m + n; k++) { // 注意k的取值范围 for (int i1 = 1; i1 &lt;= n; i1++) { for (int i2 = 1; i2 &lt;= n; i2++) { int j1 = k - i1, j2 = k - i2; if (1 &lt;= i1 &lt;= n &amp;&amp; 1 &lt;= i2 &lt;= n &amp;&amp; 1 &lt;= j1 &lt;= m &amp;&amp; 1 &lt;= j2 &lt;= m) { int val = (i1 == i2) ? w[i1][j1] : w[i1][j1] + w[i2][j2]; // 判断是否重合 int &amp;current = dp[k][i1][i2]; // 设置引用缩减码量 current = max(current, dp[k - 1][i1][i2] + val); // 两条都从上边来 current = max(current, dp[k - 1][i1][i2 - 1] + val); // 第一条从上边来，第二条从左边来 current = max(current, dp[k - 1][i1 - 1][i2] + val); // 第一条从左边来，第二条从上边来 current = max(current, dp[k - 1][i1 - 1][i2 - 1] + val); // 两条都从左边来 } } } } cout &lt;&lt; dp[m + n][n][n] &lt;&lt; endl; return 0;} 总用时： 记录 子序列型 线性DP 子序列指在原序列中，在不改变元素之间的相对顺序的前提下，从中抽取出的元素组成的序列。例如数列1 4 5 6 7 8，1 5 7 8就是原序列的一个长度为 的子序列，特殊地，原序列本身也是它的一个子序列。根据子序列元素之间的大小关系，大致分为“上升型”、“不下降型”、“下降型”和“不上升型”，分别对应前后元素是小于、小于等于、大于和大于等于的关系。在引入第二个序列的情况下，问题还可以进阶成为“公共子序列问题”，公共子序列正如其名：若某序列是两个及以上的序列的子序列，那么这个序列就是后者的公共子序列。 线性DP可以用于求解符合以上特点的子序列的最长长度，在 的复杂度内得出结果，某些子序列计算可以通过贪心进行优化，最快可到 级别。在竞赛中通常以英文缩写称之，例如最长上升子序列LIS、最长公共子序列LCS和二者的融合——最长上升公共子序列LCIS问题。 洛谷 B3637 最长上升子序列 LIS 题目传送门：B3637 最长上升子序列 难度：普及- 来源：NOIp 提高组 2004 这是一个简单的动规板子题。 给出一个由 个不超过 的正整数组成的序列。请输出这个序列的最长上升子序列的长度。 最长上升子序列是指，从原序列中按顺序取出一些数字排在一起，这些数字是逐渐增大的。 甚至你有可能都没见过B开头的洛谷题……在题库上端的“入门与面试”选项卡里，你可以找到B开头的题 在子序列DP的思考中，通常对DP的全集有一个比较跳脱常理的思维，通常让dp[i]作为以a[i]结尾的某类型子序列的最长长度。而子序列问题的状态集合属性也自然而然就是max了。 那么假设此时DP进行到了第 项（ ），为了得出状态转移方程，我们聚焦到dp[i]的前一项，也就是dp[i - 1]。搞明白在什么情况下dp[i - 1]才能转化为dp[i]。不难发现，解决LIS问题，核心就是保证后一项的数严格大于前一项的数。于是当 时，我们就可以将 纳入最长子序列的计数中，也就是dp[i] = dp[i - 1] + 1。 对于dp数组初始化，因为每个元素本身就是原序列的一个长度为1的上升子序列，所以必须让dp数组的每个位置都初始化成 。在最后，因为我们也不知道以第几个元素为结尾的上升子序列可以取到最大长度，因此我们还需要从头到尾扫一遍取最大值。代码给出： 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define N 5010using namespace std;int dp[N], a[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) dp[i] = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt; i; j++) { if (a[j] &lt; a[i]) dp[i] = max(dp[i], dp[j] + 1); } } int ans = -1; for (int i = 1; i &lt;= n; i++) ans = max(ans, dp[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;} 总用时： 记录 洛谷 P1091 合唱队形 题目传送门：这里 难度：普及/提高- 位同学站成一排，音乐老师要请其中的 位同学出列，使得剩下的 位同学排成合唱队形。 合唱队形是指这样的一种队形：设 位同学从左到右依次编号为 … ，他们的身高分别为 … ，则他们的身高满足 … 。 你的任务是，已知所有 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 输入共二行。 第一行是一个整数 （），表示同学的总数。 第二行有 个整数，用空格分隔，第 个整数 （）是第 位同学的身高（厘米）。 对于全部的数据，保证有 。 样例输入 128186 186 150 200 160 130 197 200 样例输出 4 要想出列的人最少，留下的人必须最多！废话 那么如何保证留下的人最多呢？读题，要求是让整个队形变成先升后降的形式。我们不妨将样例输入进行一次可视化： 题目想让我们把这张图变成左边上升右边下降的样子，形状酷似山峰，因此我称之为山峰模型。联系到刚才所说，需要让留下的人最多。我们在选择C位同学时就需要注意一下，让他左侧留下的人最多、而不是一定要让最高的站中间。这下就很明朗了，我们先正向（从左至右）做一遍LIS问题，就知道让哪个人站C位可以使得Ta左边的人出列最少。那么还差右边的人，怎么办呢？我们会发现如果将整个序列倒序一下（水平翻转），那么原先的右侧就变为现在的左侧，原先让右侧单调下降，现在就变成了左侧单调上升，也就是和处理左侧同样的思路。于是我们就对原序列跑一遍LIS，再对反向的序列跑一遍LIS。最后 统计一下每个点跑两次LIS后结果的总和（对应留下的人的人数），找出总和最大的那个就好了。至此我们已经成功将这个问题转化为两次异向LIS问题了！ 最后有一点小细节，是关于最终结果的。样例输入的原理是将中间那个身高两米（176cm小矮个瑟瑟发抖）的设为C位，让左侧150cm和任意一个186cm、右侧197cm和200cm的人出列（注意是保证严格上升，因此若连续二者身高相等则不计入LIS计数）。答案就是 。可以发现中间200cm的同学，正向LIS的结果是 、反向LIS的结果是 。但是 ，少了一个人去哪了——这是因为正反向LIS都算入了一次那个两米的同学，根据容斥原理，多算一次，就要减去一次，实际留下的人数是 人，答案就是 人。 代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define rev(x) n - x + 1#define N 5010using namespace std;int dp[N], rev_dp[N];int a[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) { dp[i] = 1; for (int j = 1; j &lt; i; j++) { if (a[j] &lt; a[i]) dp[i] = max(dp[i], dp[j] + 1); } } reverse(a + 1, a + n + 1); for (int i = 1; i &lt;= n; i++) { rev_dp[i] = 1; for (int j = 1; j &lt; i; j++) { if (a[j] &lt; a[i]) rev_dp[i] = max(rev_dp[i], rev_dp[j] + 1); } } int ans = -1; for (int i = 1; i &lt;= n; i++) ans = max(ans, dp[i] + rev_dp[rev(i)]); cout &lt;&lt; n - (ans - 1) &lt;&lt; endl; return 0;} 总用时： 记录 洛谷 P2782 友好城市 题目传送门：这里 难度：普及/提高- 有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的 个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航道不相交的情况下，被批准的申请尽量多。 输入第一行，一个整数 ，表示城市数。 输入第二行到第 行，每行两个整数，中间用一个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。 输出仅一行，一个整数，表示政府所能批准的最多申请数。 样例输入 12345678722 42 610 315 129 817 174 2 样例输出 14 数据范围 对于 的数据，，。 对于 的数据，，。 样例看起来不是那么直观，考试时可以考虑用画图软件增强样例可读性，样例画成图就是下边这样： 样例输出为 ，意味着我们需要删去 条边，分别是边 、 和 。为了探寻普遍规律，我们分离部分相交的航道来看一看，寻找相交线与河岸两头编号的规律。 我将北岸城市所连接的南岸城市的编号以深蓝色字体标在了对应北岸城市的下方，这下就可以看出端倪了：北岸城市从左至右，当底部蓝色数字单调上升时，航线不会交叉；反之若出现破坏单调性的蓝色数字，就代表航线交叉。但这个不完全归纳出来的结论还是欠缺证据支撑，对于北岸城市，编号单调递增，也就是说若航线以北岸城市为起点，那么起点处航线是绝对不会相交的；但是对于整条航线，它在整条河上是连续不断的——比如上图中蓝色数字 和 ，表明北四号城市连接了一个很远的南二十二号城市；下一个是北十二号城市，连接南十五号城市。整条航线在河上连续不断，意味着航线 总会在河上有一个正对南四~二十二号城市的点，此时当航线 出现时，它们总会在某处相交。南岸证明同理。至此就证明了这个单调递增规律的问题，因此我们就想办法把南北岸城市的编号一一对应起来，接着跑一遍LIS，就可以解出答案了。 这里介绍一下C++的pair：pair是一个二元组，在定义时传入第一参数和第二参数的数据类型，类似于vector的定义，它们也用一对尖括号包裹。特定类型的pair，例如pair&lt;int, int&gt;、pair&lt;double, double&gt;、pair&lt;float, float&gt;等，在sort函数中可以自动按第一参数排序。这里我们选择双int型pair来存储南北城市的对应关系。代码如下： 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define N 200010using namespace std;typedef pair&lt;int, int&gt; coord;int dp[N];coord a[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].first &gt;&gt; a[i].second; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; i++) { dp[i] = 1; for (int j = 1; j &lt; i; j++) { if (a[j].second &lt; a[i].second) dp[i] = max(dp[i], dp[j] + 1); } } int res = -1; for (int i = 1; i &lt;= n; i++) res = max(res, dp[i]); cout &lt;&lt; res &lt;&lt; endl; return 0;} 总用时：TLE 记录 注意到这里的数据范围：前50%没有问题，重点是后50%，它们的 。LIS的时间复杂度是 ，早T飞了。不过AcWing对应的例题的数据没有洛谷上这么强，在AcWing 1012 友好城市里可以用LIS代码AC，后者的数据范围是 。要想通过洛谷的友好城市，就必须用贪心等其他优化方式将时间复杂度降到对数级别才行……画大饼画大饼 AcWing 1016 最大上升子序列和 题目传送门：这里 难度：简单 最大上升子序列和，又称MASS（Maxiumum Ascending Subsequence Sum）问题。是LIS问题的一种变式，它不再是只局限于上升子序列的最长长度、而是开始关注选定子序列的元素之和。MASS问题其实可以拆分为两个子问题求解，其一是上升子序列问题、其二是最大和问题。上升子序列无需多言，其本质是在循环内加上判断a[j] &lt; a[i]来累加合法解个数。因此，如果想要再融合进最大值问题，我们就需要在状态转移那里改一下代码：考虑到LIS问题的dp数组记录的是合法解的个数，而每次找到一组合法解，答案只会累加 ；对于MASS问题，每次找到一组合法解，需要累加的是元素本身的权值，特殊情况，单元素组成子序列时，答案就是它本身的权值，因而初始化时需要把dp[i]设置成a[i]才对。 代码： 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define N 1010using namespace std;int dp[N], a[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) { dp[i] = a[i]; for (int j = 1; j &lt; i; j++) { if (a[j] &lt; a[i]) dp[i] = max(dp[i], dp[j] + a[i]); } } int res = -1; for (int i = 1; i &lt;= n; i++) res = max(res, dp[i]); cout &lt;&lt; res &lt;&lt; endl; return 0;} 总用时： 记录 AcWing 1010 拦截导弹 题目传送门：这里 难度：简单 来源：NOIp 提高组 1999 某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入仅一行，若干个整数，中间由空格隔开。 输出包含两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 样例输入 1389 207 155 300 299 170 158 65 样例输出 1262 保证导弹数量不超过 同样画图理解样例抽象派画师又要登场喽！ 那么怎么做才是样例输出的解呢？很明显，把207和155单独提出来作为一个新系统；剩下的作为一个系统。也就是说最多能拦截除开207和155的其他六枚导弹，而新开了一个系统，所以总共是两个系统。 乍一看这很像一个求解最长单调不上升子序列的问题，但是它居然让我们求出系统的数量，这就很棘手了……所以我们需要一个两头兼顾的方法来解题： 当我们拿到这个序列，之后只会进行两种操作：第一种是将某个数接到已有的子序列之后、第二种是新开一个子序列。考虑到我们的目标之一是让新开的子序列尽量小，那我们就需要尽可能缩减第二种操作的执行次数——让尽可能多的数被归入子序列中，这样的话我们就需要让插入的数和插入前队尾的数尽可能接近才是，如此会让系统的利用率最大化（如果你是舰长总司令，拿到这种系统，你肯定不会轻易地让它拦截很低的导弹，这样只会降低系统利用率）。当然，我们也希望打头的元素尽量大一些，这样才会容纳进更多的元素。诶？这不就是贪心的思路吗？为了方便阅读，做归纳如下： 贪心过程：从前到后扫描每个数，并且： 如果现有的所有子序列的结尾都小于这个数，显然不能插入，就开新序列（创建新系统） 如果存在合法（符合题意且当前元素可插入队尾）的子序列，遍历队尾元素，找到和当前元素最相近的那个队尾对应的子序列插入 代码： 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define N 1010using namespace std;int dp[N], a[N], b[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n = 1; while (cin &gt;&gt; a[n]) n++; n--; int lis = -1; for (int i = 1; i &lt;= n; i++) { dp[i] = 1; for (int j = 1; j &lt; i; j++) { if (a[j] &gt;= a[i]) dp[i] = max(dp[i], dp[j] + 1); } lis = max(lis, dp[i]); } int cnt = 0; for (int i = 1; i &lt;= n; i++) { int tmp = 0; while (tmp &lt; cnt &amp;&amp; b[tmp] &lt; a[i]) tmp++; b[tmp] = a[i]; if (tmp &gt;= cnt) cnt++; } cout &lt;&lt; lis &lt;&lt; endl &lt;&lt; cnt &lt;&lt; endl; return 0;} 总用时： 记录 AcWing 897 最长公共子序列 LCS 题目传送门：这里 难度：简单 最长公共子序列，又称LCS（Longest Common Subsequence）问题。这个问题要求我们解出两个不相关序列的最长的公共子序列长度。公共子序列，顾名思义：假设有两个序列 和 ，它们的公共子序列 既是 的子序列、也是 的子序列。搞明白了公共子序列的定义，我们来解题： 给定两个长度分别为 和 的字符串 和 ，求既是 的子序列又是 的子序列的字符串长度最长是多少。 输入输出 第一行包含两个整数 和 第二行包含一个长度为 的字符串，表示字符串 。 第三行包含一个长度为 的字符串，表示字符串 。 字符串均由小写字母构成。 输出一个整数，表示最大长度。 数据范围 样例输入 1234 5acbdabedc 样例输出 13 这道题就和前面的LIS问题不一样了，人家是在一个序列里操作，现在变成了两个序列。我们在选取状态的表示时就要换一种思维了。假设dp[i][j]表示的是以 序列中前 个元素和 序列中前 个元素组成的最长公共子序列的长度。根据公共子序列的定义，我们可以抛出如下两种情况： 当 时，证明元素 不能被选入到公共序列中（数据不相同，即不满足“公共”） 当 时，证明元素 可以被选入到公共序列中 第一种情况，大问题被切分了，我们要找到距离它最近的一个合法的公共子序列。我们先后尝试删去当前的 和 ，然后看一下得到的结果是否是合法的公共子序列，类似于一个递归的过程。因此dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])。 第二种情况，我们选入了 和 ，注意到 ，我们只需要选一个进入公共子序列即可，因此长度也只需累加 。类比第一种情况的思路，我们往回查找距离当前状态最近的一个合法的公共子序列，也就是尚未选中 或 时的状态。得到dp[i][j] = dp[i - 1][j - 1]。 综上所述： 或且且 这个 看起来就高级多了 代码： 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define N 1010using namespace std;int dp[N][N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (a[i - 1] == b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } cout &lt;&lt; dp[n][m] &lt;&lt; endl; return 0;} 总用时： 记录 AcWing 272 最长公共上升子序列 LCIS 题目传送门：这里 难度：中等 最长上升公共子序列，听名字就能看出是最长上升子序列和最长公共子序列的结合体。如此高级的题目自然有非常高级的方法来解决，请看下边例题： 熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。 小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。 小沐沐说，对于两个数列 和 ，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。 奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。 不过，只要告诉奶牛它的长度就可以了。 数列 和 的长度均不超过 。 输入第一行包含一个整数 ，表示数列 的长度。 输入第二行包含 个整数，表示数列 。 输入第三行包含 个整数，表示数列 。 输出一个整数，表示最长公共上升子序列的长度。 状态表示和上边LCS差不太多，这里的dp[i][j]表示的是 序列的前 个元素与 序列中前 个元素组成、且以 结尾的最长上升公共子序列的长度。看起来只是多了一条限制信息——“以 结尾”。 首先套用LCS的思想（LIS什么时候都可以求，但求出的LIS不一定符合LCS的定义，因此LCS求解优先级大于LIS）： 当 时，当前子序列不允许 的加入（没有满足是LCS序列的大前提） 当 时，当前子序列中加入 。枚举 分析是否满足LIS序列的要求。 第一点不再赘述，如果连LCS都不是，更不用说LCIS了。重要的是第二点，当 和 已经满足公共的前提时，就需要接着处理“上升”的关系。很明显，以不同的 结尾得出的LIS的解是不同的，类似于先前 求解LIS的思路，我们从 枚举到 来记录全局最大值，因为以 、 …… 结尾的上升子序列长度是不一定相同的。在这里，我们枚举第二变量 ，使得上升子序列求得最大值。这回可以套LIS代码，效果是在求解LCS的同时求解LIS，合起来就是LCIS！ 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define N 3010using namespace std;int dp[N][N];int a[N], b[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { dp[i][j] = dp[i - 1][j]; if (a[i] == b[j]) { for (int k = 1; k &lt;= j; k++) { if (b[j] &gt; b[k]) { dp[i][j] = max(dp[i][j], dp[i - 1][k] + 1); } } if (!dp[i][j]) dp[i][j] = 1; // 切记，LIS问题的初值是1，也就是说单元素LIS的值是1 } } } int ans = -1; for (int i = 1; i &lt;= n; i++) ans = max(ans, dp[n][i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;} TLE了~ 记录 y总当时做的时候估计只有10个比较弱的数据，现在可能是加上了3个强数据，卡掉了 的朴素做法 注意到上边这段代码是在LCS的双层循环里又套了一层属于LIS的循环，复杂度是 的，极其之抽象。数据范围是 ，最坏情况下要跑几十秒……那么如何优化？对照数据范围，我们的目标是将算法复杂度降到 $ 及以下。优化思路如下： 优化从第三层循环入手，如果找到一种方法，让最大值的获取变成 ，那么整体复杂度就会降到 。看起来不错。因为整体的循环的大前提是 ，循环的目的是找到当 时dp数组里存储的最大值，那么维护最大值maxx，当 时更新值就可以了。根据等式，有 ，因此当 时就可以更新maxx为max(maxx, dp[i - 1][j])。 优化代码： 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define N 3010using namespace std;int dp[N][N], a[N], b[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; for (int i = 1; i &lt;= n; i++) { int maxx = 0; // 注意从0开始 for (int j = 1; j &lt;= n; j++) { dp[i][j] = dp[i - 1][j]; if (a[i] == b[j]) dp[i][j] = maxx + 1; else if (a[i] &gt; b[j]) maxx = max(maxx, dp[i - 1][j]); } } int res = -1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { res = max(res, dp[i][j]); } } cout &lt;&lt; res &lt;&lt; endl; return 0;} 总用时： 记录 当然，这段代码实际上只使用到了dp[i - 1][j]一个前驱状态，可以用滚动数组法把dp数组压缩至一维的。滚动数组法将在后边介绍。 补 贪心优化子序列问题 正常做子序列问题的时候，由于要枚举每一个可能的状态，因此需要循环 级别次，时间复杂度也就来到了惊人的 （大多数题目的暴力算法都是这个复杂度），当 时就TLE了，更别说更加毒瘤的数据了……好在对于最值子序列问题，人们提出了贪心法，可以将复杂度降落到对数级别，一般是 （某些题用特定的数据结构还可以降到 复杂度）。是一种极其高效的优化方式。 之前我们T掉了一道题，洛谷 P2782 友好城市，TLE的主要原因是求解LIS时使用了 的朴素DP法。那我们就回填之前挖出来的大坑，试着用 的贪心法求解LIS。 假设原序列为a，len为LIS问题的解，p数组是维护的最长上升子序列，q作为操作序列暂存（不是最终结果）。LIS问题的贪心思路如下： 将第一个元素压入q中，让len累加 ，并且让q[1] = a[1]。此时len = 1 对于每一个新元素x，如果x &gt; q[len]，让q[++len] = x，并扩展p 反之，在q数组中找到第一个大于等于x的元素y，并将y替换成x 第一点很显然是第二点在q数组为空时（刚开始求解）的特殊情况，我们只看第二和第三点。当新元素大于队尾，意味着它完全有资格进入最长上升子序列的行列中，因此压入队尾；但是当这个元素不再大于队尾，而是一个较小的值，就要好好考虑一下了…… 通常，我们在求解的中途希望相邻的两个候选元素相差尽可能小，这样才有更多的空间存更多的值，从而达到最长。在这种情况下，我们称替换用的元素比被替换的元素有更好的潜力值。当然，寻找替换元素的下标无疑是一个耗时的工作，考虑到q数组严格递增的性质，我们不妨采用二分查找（或者lower_bound()函数）找到指定元素的下标： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int a[N], q[N], p[N];int len = 0;int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) { if (a[i] &gt; q[len]) q[++len] = a[i]; else { int idx = lower_bound(q + 1, q + 1 + len, a[i]) - q; // 在[1,len]区间内查找待替换目标的下标，适用于单调上升序列 //int idx = upper_bound(q + 1, q + 1 + len, a[i], greater&lt;int&gt;()); // 适用于单调下降序列 q[idx] = a[i]; } } cout &lt;&lt; len &lt;&lt; endl; return 0;} 既然我们已经学会了这个优化方法，可以拿它来切题了。 洛谷 P1020 导弹拦截 题目传送门：这里 难度：普及/提高- 来源：NOIp 提高组 1999 实际上是这道题的洛谷数据加强版…… 实现思路和前面AcWing 1010一个道理，这里我们加上LIS的优化。注意根据题目，我们需要求一个最长不上升子序列的长度，那么用到上边优化代码里被注释的那一行： 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int a[N], b[N], q[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n = 1; while (cin &gt;&gt; a[n]) n++; n--; int lis = 0; q[++lis] = a[1]; for (int i = 2; i &lt;= n; i++) { if (a[i] &lt;= q[lis]) q[++lis] = a[i]; else { int idx = upper_bound(q + 1, q + lis + 2, a[i], greater&lt;int&gt;()) - q; q[idx] = a[i]; } } int cnt = 0; for (int i = 1; i &lt;= n; i++) { int tmp = 0; while (tmp &lt; cnt &amp;&amp; b[tmp] &lt; a[i]) tmp++; b[tmp] = a[i]; if (tmp &gt;= cnt) cnt++; } cout &lt;&lt; lis &lt;&lt; endl &lt;&lt; cnt &lt;&lt; endl; return 0;} 总用时： 记录 这里把能AC友好城市的代码一并贴在这里，因为这道题需要求上升子序列最长长度，我们使用的是lower_bound()： 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define N 200010using namespace std;typedef pair&lt;int, int&gt; coord;int dp[N];coord a[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].first &gt;&gt; a[i].second; sort(a + 1, a + n + 1); int lis = 0; for (int i = 1; i &lt;= n; i++) { if (dp[lis] &lt; a[i].second) dp[++lis] = a[i].second; else { int idx = lower_bound(dp + 1, dp + 1 + lis, a[i].second) - dp; dp[idx] = a[i].second; } } cout &lt;&lt; lis &lt;&lt; endl; return 0;} 总用时： 记录 背包DP 基础 背包问题是一种组合优化问题，大多数时候用来求解有限定条件的最值选择问题。一般的背包问题会给出这个背包所能承受的“最大容量”，并同时列出各物品的体积和价值，要求从中选择物品，使得选择的物品在不超过背包限定容量的情况下，总价值最大。根据物品的选法，可以大致分成几类：0/1背包、完全背包、多重背包等。 0/1背包 在0/1背包问题中，限制每个物品至多被选择一次，因此对于某个物品，只有“选”和“不选”两种情况。因此得名0/1（不选为0，选为1）。 对于背包问题的空间优化（滚动数组优化）将在后边统一涉及。 洛谷 P1048 采药 题目传送门：这里 难度：普及- 来源：NOIp 普及组 2005 辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？ 输入：第一行有 个整数 （）和 （$1 M ），用一个空格隔开，T$ 代表总共能够用来采药的时间， 代表山洞里的草药的数目。 接下来的 行每行包括两个在 到 之间（包括 和 ）的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出：在规定的时间内可以采到的草药的最大总价值。 在背包问题中，通常让dp数组带上题目的限制条件。在这里，我们令dp[i][j]表示选择前 个物品且此时所选物品总容量不超过 （剩余可用容量）时的最大价值。属性自然是max。假设第 个物品价值是 、体积是 。 因为每个物品至多选择一次，分两种情况讨论——“选”或者是“不选”第 个物品。 如果不选这个物品，相当于这个状态不存在，因此第二维不需要更新，相当于是只选择了前 个物品的情况，也就是dp[i][j] = dp[i - 1][j]；但如果选择了这第 个物品，我们就需要观察分析一下数组的变化了——这个状态很明显，是从它的前驱dp[i - 1][j]转移过来的。那么在选择了物品 之后，背包的剩余容量自然就是 了，并且总价值会增加 ，为了保证状态数组的最值，对“选”和“不选”两种情况取最大值，也就是dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i])。注意，若当前的容许最大容量小于当前物品的体积时，就无法选择这个物品，相当于不选时的情况，加上循环内特判就行了。 当我们把这道题里的时间想象成背包问题的总容量，题目就变成了一个0/1背包模板题了。 代码： 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define N 1010using namespace std;int dp[N][N], w[N], v[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t, m; cin &gt;&gt; t &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; v[i] &gt;&gt; w[i]; } for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= t; j++) { if (j &gt;= v[i]) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]); else dp[i][j] = max(dp[i][j], dp[i - 1][j]); } } cout &lt;&lt; dp[m][t] &lt;&lt; endl; return 0;} 总用时： 记录 完全背包 类比0/1背包每样物品至多选择一次的策略，完全背包则是让每样物品的选择次数上限变成了正无穷。也就是说我们可以抓住一个物品暴风吸入，只要保证在限定容量内装入最大价值的物品即可。 洛谷 P2722 总分 Score Inflation 题目传送门：这里 难度：普及- 来源：USACO 选手在我们 USACO 的竞赛中的得分越多我们越高兴。 我们试着设计我们的竞赛以便人们能尽可能的多得分,这需要你的帮助。 我们可以从几个种类中选取竞赛的题目，这里的一个“种类”是指一个竞赛题目的集合，解决集合中的题目需要相同多的时间并且能得到相同的分数。 你的任务是写一个程序来告诉 USACO 的职员,应该从每一个种类中选取多少题目，使得解决题目的总耗时在竞赛规定的时间里并且总分最大。 输入的第一行是用空格隔开的两个整数，分别代表竞赛时间 和题目类 。 第 到第 行，每行两个用空格隔开的整数，第 行的整数 分别代表解决第 类题得到的分数和需要花费的时间。 既然是某一类题目，那么这一类题目可以重复选择 输出一行一个整数，代表最大的总分。 对于 的数据，保证 $1 n, m ^4 $，。 状态的表示和上面0/1背包是相同的，不再多说。重要的是推导状态，还是分为“选”和“不选”两种情况，如果不选，和上面一样，就是dp[i - 1][j]；但是如果选择这个物品，那就需要千万注意了： 我们找到上一步的状态，是dp[i - 1][j]吗？——显然欠缺考虑，万一第 个物品已经选择过不止一次呢？使用这个状态相当于直接放弃了先前选择过数次的物品 ，有悖于集合划分“不重不漏”的基本原则。假设当前状态已经减去了 ，变成了dp[i][j - v[i]] + w[i]，那么上一个状态就是dp[i][j]。这是因为上一个状态可能已经选取了多个物品 ，我们不能放弃掉原先存储的状态，就可以换个思路，直接在原有基础上，再选一个物品 。因此该情况下，dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i])。 代码： 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int dp[N][N], w[N], v[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t, m; cin &gt;&gt; t &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; w[i] &gt;&gt; v[i]; } for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= t; j++) { if (j &lt; v[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j]); else dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]); } } cout &lt;&lt; dp[m][t] &lt;&lt; endl; return 0;} 总用时：MLE 记录 原因是当数组占满时，整个内存将会来到，题目限制125MB，爆了三倍还多。后文会介绍滚动数组优化法后会提供能AC此题的正解代码。 多重背包 多重背包的物品选择策略可以说是最接近日常生活的一种了，它规定某种物品只能选择至多 次。因此它介于0/1背包和完全背包之间，状态转移也更加复杂，但更具普遍性。接下来引入一道模板题来感受多重背包的解题思路。 洛谷 P1833 樱花 题目传送门：这里 难度：普及/提高- 爱与愁大神后院里种了 棵樱花树，每棵都有美学值 。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。 输入：共 行： 第 行：现在时间 （几时：几分），去上学的时间 （几时：几分），爱与愁大神院子里有几棵樱花树 。这里的 ， 格式为：hh:mm，其中 ，，且 均为正整数。 第 行到第 行，每行三个正整数：看完第 棵树的耗费时间 ，第 棵树的美学值 ，看第 棵树的次数 （ 表示无数次， 是其他数字表示最多可看的次数 ）。 输出：只有一个整数，表示最大美学值。 数据：（即开始时间距离结束时间不超过 $1000 $ 分钟），。保证 为同一天内的时间。 这道题怎么降黄了？ 如何处理这种个数有限的物品呢？常规的思路是将一个价值为 ，个数为 的物品拆分成 个个体，对于整体，使用0/1背包的方式求解即可；或者也可以在选择物品时采用计数+特判，当容量不够或达到上限时退出循环即可。但是限于题目要求，这种方法在大多数情况下是无法完美通过测试点的，尤其是当物品种类数和物品件数的乘积过大时，光是拆分这一项就足够超时了。因此我们需要一个更为高效的拆分法来拆分这些物品。 想象这样一个情境，你的面前放着 个苹果。但是你只需要其中的 颗，你希望将它们装到 个盒子里自己带走，请问 之间有什么关系？ 根据情境，我们就需要将 分为 个数的和，当 是 的倍数时还好说，那万一不是呢？能不能提出一种通用解法？ 学OI的人们都知道，世界上所有的数都可以用一个01串表示，也就是二进制下的表示，和十进制一样按位计数。比如：；。那么问题就解决了， 就是 的二进制表示下 的个数（解法不唯一） 对于物品 ，假设个数为 ，价值 ，体积 ，根据二进制表示法，对 进行二进制分解。只是这里和刚刚讲的二进制转化有些许不同，这里我们不停的用 的 次幂来作差，如此操作下来，。那么所有在区间 内的数就都可以表示出来了。 以上边的拆分结果为例，相当于分成了 个价值 的物品、 个价值为 的物品、 个价值为 的物品、 个价值为 的物品和 个价值为 的物品。整体跑0/1背包就行了。 二进制拆分的复杂度就是这个数的二进制形式表示下的长度，即 ，拆分的总复杂度是 ，还是对数级别的，效率会高很多。 二进制核心拆分代码： 12345678910111213141516for (int i = 1; i &lt;= n; i++) { int wei, vol, s; int bin = 1; cin &gt;&gt; vol &gt;&gt; wei &gt;&gt; s; while (bin &lt;= s) { w[++idx] = bin * wei; v[idx] = bin * vol; s -= bin; bin *= 2; } if (s) { w[++idx] = s * wei; v[idx] = s * vol; }} 事实上这道题应该说是一个多重背包和完全背包混起来的混合背包问题。混合背包顾名思义，把几种背包混在一起考，有些物品只有一个（0/1背包）、有些物品有多个（多重背包）、有些物品有无数个（完全背包）。每种物品特判一下，用不同的状态转移方程计算就行。 补 滚动数组优化空间 回顾一下前面所讲的0/1背包、完全背包和多重背包（实质上是0/1背包的状态转移方程）的状态方程，会发现我们其实只用到了前一个物品的状态，也就是形如dp[i - 1][...]的状态。如果还在用二维数组，那显然浪费了空间，可能导致MLE的出现。我们在这里针对这几种背包来讲解压维优化的实现思路。 0/1背包 状态转移方程：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]) 我们舍弃掉第一维，它变成了dp[j] = max(dp[j], dp[j - v[i]] + w[i])。完成了吗？——肯定不会这么容易！观察一下两层循环： 12345for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { dp[j] = max(dp[j], dp[j - v[i]] + w[i]); }} 0/1背包必须满足某个物品至多被选择一次，试想如果从 开始升序循环，那么物品 就会被不止放入一次。例如下面这样（ ）： 更新状态dp[1]，执行dp[1] = max(dp[1], dp[1 - v[1]] + w[1]) 更新状态dp[2]，执行dp[2] = max(dp[2], dp[2 - v[1]] + w[1]) 相当于物品 被选择了两次。不符合0/1背包的定义。因此改版代码应如下： 12345for (int i = 1; i &lt;= n; i++) { for (int j = vmax; j &gt;= v[i]; j--) { dp[j] = max(dp[j], dp[j - v[i]] + w[i]); }} 完全背包 状态转移方程：dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]) 如上文所说，第二层循环如果是升序的，那么这个物品在更新时就会被重复计入。但是对于完全背包来说，它不存在像0/1背包那样的“至多选择一次”的数量限制，每个物品都是无穷多的，因此重复选择不仅不用去刻意避免，相反这还是我们所需要的。因此改版代码如下： 12345for (int i = 1; i &lt;= n; i++) { for (int j = w[i]; j &lt;= vmax; j--) { dp[j] = max(dp[j], dp[j - v[i]] + w[i]); }} 从 开始升序循环，避免 情况的出现。 多重背包则是套用0/1背包的一维数组，不再赘述。 再战错题 错误解法 原因在之前已经分析过：数组空间过大导致MLE。因此用到完全背包的滚动数组优化法，我们可以将空间压缩至先前的 。 代码： 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int dp[N], w[N], v[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t, m; cin &gt;&gt; t &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; w[i] &gt;&gt; v[i]; } for (int i = 1; i &lt;= m; i++) { for (int j = v[i]; j &lt;= t; j++) { dp[j] = max(dp[j], dp[j - v[i]] + w[i]); } } cout &lt;&lt; dp[t] &lt;&lt; endl; return 0;} 总用时： 记录 跑得飕飕快是不是 补 最低限制型背包 一般的背包问题会对背包的最大容量进行限制，这也是背包问题的一大特征。但是实际比赛时题目有可能会让你求出满足 的最小 值，即所谓“最低限制”。 洛谷 P5365 英雄联盟 题目传送门：这里 难度：普及/提高+ 来源：各省省选 2017 正在上大学的小皮球热爱英雄联盟这款游戏，而且打的很菜，被网友们戏称为「小学生」。 现在，小皮球终于受不了网友们的嘲讽，决定变强了，他变强的方法就是：买皮肤！ 小皮球只会玩 个英雄，因此，他也只准备给这 个英雄买皮肤，并且决定，以后只玩有皮肤的英雄。 这 个英雄中，第 个英雄有 款皮肤，价格是每款 Q 币（同一个英雄的皮肤价格相同）。 为了让自己看起来高大上一些，小皮球决定给同学们展示一下自己的皮肤，展示的思路是这样的：对于有皮肤的每一个英雄，随便选一个皮肤给同学看。 比如，小皮球共有 5 个英雄，这 5 个英雄分别有 款皮肤，那么，小皮球就有 种展示的策略。 现在，小皮球希望自己的展示策略能够至少达到 种，请问，小皮球至少要花多少钱呢？ 输入第一行，两个整数 。 输入第二行， 个整数，表示每个英雄的皮肤数量 。 输入第三行， 个整数，表示每个英雄皮肤的价格 。 输出一个整数，表示小皮球达到目标最少的花费。 样例输入 #1 1233 244 4 42 2 2 样例输出 #1 118 样例解释 每一个英雄都只有4款皮肤，每款皮肤2 Q币，那么每个英雄买3款皮肤，，共花费 Q币。 数据范围 共 10 组数据，第 组数据满足： 的数据：。保证有解。 根据分布计数乘法原理可以得出总展示种类数的计算方法，不再赘述。 这道题其实并非一个严格最低限制型背包，因为如果你仔细分析这道题，你会发现其实“Q币数量”才是背包问题中的“最大容量”；“展示种类数”只是一个附加条件。那么针对于这类题目，我们的方法是在代码最后将所有状态扫描一遍从而找出最优解。接下来分析一下这道题： 这道题很明显是一个多重背包，直接使用滚动数组优化法，定义一维数组dp[i]表示使用Q币数为 时的总展示种类数（实际上一维dp数组可以同时表示三个变量——被滚动压维的物品编号；下标：总容量；数组值：需要求出的量）。假设物品 在某次决策中被选中了 次，对应过来，总展示方案数将乘上 ，Q币数将减去 （单价×数量）。也就是dp[j] = max(dp[j], dp[j - n * v[i]] * n)。 在最后处理最低限制部分，我们正序循环Q币数，自然，循环在区间 内。所以读入时累加Q币总数，在循环内部若第一次出现 ，就直接输出，记住对dp[0]初始化（否则不论怎么乘都是零）。注意到题目中 的最大值为 ，使用多重背包的朴素拆法也可以过关！不开 见祖宗（开始因为这个痛失 ）！ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define N 1000010using namespace std;typedef long long ll;ll dp[N], v[N], quan[N];ll cnt = 0;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); ll n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; quan[i]; } for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; v[i]; cnt += v[i] * quan[i]; } dp[0] = 1; for (int i = 1; i &lt;= n; i++) { for (ll j = cnt; j &gt;= 0; j--) { for (int k = 0; k &lt;= quan[i] &amp;&amp; k * v[i] &lt;= j; k++) { dp[j] = max(dp[j], dp[j - k * v[i]] * k); } } } for (ll i = 0; i &lt;= cnt; i++) { if (dp[i] &gt;= m) { cout &lt;&lt; i &lt;&lt; endl; break; } } return 0;} 总用时： 记录 补 第k优解记录 背包题目一般所求结果都是最优解，但是有些题目他就是吃饱了没事干对变式思维考察比较透彻。有些题目就非常好地践行了中庸思想，不当出头鸟，让我们求出第二优解、第三优解……甚至于最劣解（但我从来没见到过）。这里介绍一下DP问题的第k优解记录问题。 洛谷 P1858 多人背包 题目传送门：这里 难度：提高+/省选 求01背包前k优解的价值和 DD 和好朋友们要去爬山啦！ 他们一共有 个人，每个人都会背一个包。这些包 的容量是相同的，都是 。可以装进背包里的一共有 种物品，每种物品都有 给定的体积和价值。 在 DD 看来，合理的背包安排方案是这样的： 每个人背包里装的物品的总体积恰等于包的容量。 每个包里的每种物品最多只有一件，但两个不同的包中可以存在相同的物品。 任意两个人，他们包里的物品清单不能完全相同。 在满足以上要求的前提下，所有包里的所有物品的总价值最大是多少呢？ 输入： 第一行三个数K、V、N 接下来每行两个数，表示体积和价值 输出： 前k优解的价值和 数据范围： 对于100%的数据, 0/1背包蓝题？好耶！ 这道题题面已经很明确了，甚至都已经写出来了，让我们求出前 优解的和。为了求出第 优解，我们考虑在状态表示里加上一维表示当前状态是第几优解，因此dp[i][k]表示当前背包容量为 且是第 优解的方案的价值之和。我们都知道，DP时各个状态是在不断更新的，如果能找到一种方法使得状态随改随排序，那将是绝杀。于是我们把目光投到状态更新那里，众所周知，0/1背包的状态转移方程是dp[j] = max(dp[j], dp[j - v[i]] + w[i])，当前状态只会从dp[j]或dp[j - v[i]]那里转移过来。数据范围有 ，考虑使用最没思维含量的暴力修改法更新最优解排名，最终的输出就是 。 暴力排名的过程类似于归并排序中数组归并的实现，下面是归并排序中实现数组归并时的部分代码： 1234while (i &lt;= mid &amp;&amp; j &lt;= right) { if (a[i] &lt; a[j]) tmp[t++] = a[i++]; else tmp[t++] = a[j++];} 此处的tmp数组用来缓存需要归并的两个数组排序后的结果（亚定数组），t就是当前元素在亚定数组中的位置（升序）。这篇博客详解了这段代码的运行逻辑。 我们变通一下，我们需要找到前驱状态的排名。代码如下： 123456int a = 1, b = 1, t = 1;while (t &lt;= k) { if (dp[j][a] &lt; dp[j - v[i]][b] + w[i]) tmp[t++] = dp[j - v[i]][b++] + w[i]; else tmp[t++] = dp[i][a++];}for (int m = 1; m &lt;= k; m++) dp[j][m] = tmp[m]; 最后一行相当于是将亚定数组变为结果数组。 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define N 5010using namespace std;int dp[N][N], w[N], v[N], tmp[N];int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int k, vmax, n; cin &gt;&gt; k &gt;&gt; vmax &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; v[i] &gt;&gt; w[i]; } // 注意：赋初值为负无穷 memset(dp, -0x3f, sizeof dp); dp[0][1] = 0; for (int i = 1; i &lt;= n; i++) { for (int j = vmax; j &gt;= v[i]; j--) { // 借鉴归并排序的思想，对前驱状态排名 int t = 1, a = 1, b = 1; while (t &lt;= k) { if (dp[j][a] &lt; dp[j - v[i]][b] + w[i]) tmp[t++] = dp[j - v[i]][b++] + w[i]; else tmp[t++] = dp[j][a++]; } for (int m = 1; m &lt;= k; m++) dp[j][m] = tmp[m]; } } int ans = 0; for (int i = 1; i &lt;= k; i++) { ans += dp[vmax][i]; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 总用时： 记录 想我初中方入门信竞之时，授课的是一位壮年先生。尤喜摸鱼，开课时点名，完便坐下放视频了。DP课习题有五，前四普及-，压轴就是这道多人背包……而今A了此题，猛然忆起往事，不觉唏嘘当年——老师不管不顾，自己也欠阙自觉性，费了大好时光。现已高中，徒赶时间为一纸通知书。扣笔独叹，只可说白首方悔读书迟罢！","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"dp","slug":"dp","permalink":"https://justpureh2o.cn/tags/dp/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://justpureh2o.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"洛谷  陌路寻诗礼 题解","slug":"i-love-furina-instead","date":"2024-02-19T01:44:37.366Z","updated":"2024-02-19T19:22:58.270Z","comments":true,"path":"articles/6080/","link":"","permalink":"https://justpureh2o.cn/articles/6080/","excerpt":"","text":"题目传送门：P10178 受到了题面的启发，我才想起那个早已死去的算法——SPFA 题面总结成一句话就是：最短路只能有一条。 那么我们用最短路算法：如果有最短路，先选择最短路。如果在更新最短值时出现了冲突——即某两种方案路径长度相等时，让后来者考虑加上一个 范围内的值，使它变长、不再是最短路（退出奖牌争夺）就好了。 对于加上的正整数值，不妨从 开始加。不够就加上 ，还不够就加上 ，以此类推……在经历若干次最短路淘汰后，如果边权加上 仍然不能满足最短路唯一的硬性需求时，代表这组数值根本就是无解的，因此需输出No。反之将试加的值记录到ans数组中去，在每组数据结束后输出即可。 同时请注意多测清空！ 代码，但是 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define N 300010using namespace std;int k;int h[N], to[N], ne[N], ans[N], dis[N];bool st[N];int idx = 0;void add(int u, int v) { idx++; to[idx] = v; ne[idx] = h[u]; h[u] = idx;}bool spfa() { queue&lt;int&gt; q; q.push(1); dis[1] = 0; st[1] = true; while (!q.empty()) { int top = q.front(); q.pop(); for (int i = h[top]; ~i; i = ne[i]) { int j = to[i]; if (top == j) { ans[i] = k; continue; } int trial = 1; if (dis[j] &gt; dis[top] + trial) { dis[j] = dis[top] + trial; if (!st[j]) q.push(j), st[j] ^= 1; } else if (dis[j] == dis[top] + trial) trial++; if (trial &gt; k) return false; ans[i] = trial; } } return true;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t, n, m; cin &gt;&gt; t; while (t--) { memset(dis, 0x3f, sizeof dis); memset(h, -1, sizeof h); memset(st, 0, sizeof st); idx = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; add(u, v); } if (spfa()) { cout &lt;&lt; \"Yes\\n\"; for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; } else cout &lt;&lt; \"No\"; cout &lt;&lt; endl; } return 0;} 这段代码居然一反常态的在第一组测试点处TLE了？？？于是重新看到数据范围——，发现竟然是清空的memset出了问题！当你定义了一个大小为 的数组时，调用memset的结果就是对这整个 的空间进行内存赋值，而且估计第一组测试点出了一个比较大的询问个数 ，导致TLE。 解决方案就是从 循环到 清空，避免不必要的性能浪费 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define N 300010using namespace std;int k;int h[N], to[N], ne[N], ans[N], dis[N];bool st[N];int idx = 0;void add(int u, int v) { idx++; to[idx] = v; ne[idx] = h[u]; h[u] = idx;}bool spfa() { queue&lt;int&gt; q; q.push(1); dis[1] = 0; st[1] = true; while (!q.empty()) { int top = q.front(); q.pop(); for (int i = h[top]; ~i; i = ne[i]) { int j = to[i]; if (top == j) { ans[i] = k; continue; } int trial = 1; if (dis[j] &gt; dis[top] + trial) { dis[j] = dis[top] + trial; if (!st[j]) q.push(j), st[j] ^= 1; } else if (dis[j] == dis[top] + trial) trial++; if (trial &gt; k) return false; ans[i] = trial; } } return true;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t, n, m; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { idx = 0; dis[i] = 0x3f3f3f3f; st[i] = false; h[i] = -1; ans[i] = 0; } for (int i = 1; i &lt;= m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; add(u, v); } if (spfa()) { cout &lt;&lt; \"Yes\\n\"; for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; } else cout &lt;&lt; \"No\"; cout &lt;&lt; endl; } return 0;} 发现第一组数据跑得飞快，完全不见了方才TLE时的拖沓！ 本蒟蒻第一篇题解，害怕~","categories":[{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"OI 分块","slug":"oi-partitioning","date":"2024-02-17T16:19:26.709Z","updated":"2024-02-18T18:10:04.497Z","comments":true,"path":"articles/114/","link":"","permalink":"https://justpureh2o.cn/articles/114/","excerpt":"","text":"何为分块 分块，正如其名，将一个整区间分为若干小区间进行操作。分块拥有比线段树更强的泛用性，但是时间复杂度略输一筹；分块代码更加直观、减少理解难度，但是时间复杂度稍逊风骚；分块的代码比线段树更短，但是时间复杂度惜败后者……线段树所上下传递的操作计算必须满足结合律，区间平均数、方差还行，像计算区间众数、中位数这样的问题，线段树就只能被薄纱了…… 考虑到树状数组理解难度较大、较难调试，一般都选用泛用性强、码量折中、效率及格、调试简便的分块算法求解。 如何分块 不同于线段树的二分存储，分块所使用的块状数组本质上只是一个带有块起始下标和块末尾下标的普通数组，就像在一列数中间插上分割线分出区块。对于区间修改操作，只需要进行以下几步就可以： 判断左端点l和右端点r所在的区块 若两个端点在同一个区块内：暴力循环更新值 若两个端点不在同一个区块内：在l所在区块内，从l开始循环至该区块结束，暴力更新值，相应的从r开始，往回循环至该区块起始处，暴力更新值，最后将二者中间整块的区块打上更新标记 我们会发现，分块其实就是将完全暴力的操作拆分成部分暴力的操作和部分取巧的操作。尽管看起来还是在使用暴力算法，但实际上优化了不少东西，而优化的效率还得取决于每个区块的长度。那么我们如何选择区块的长度呢？ 最坏情况下，指定的左右端点就是整个数组的左右端点。假设总长度为，一般采取的区块长度是。这样一来，就有个整区块会被打上标记，而两头的区块（长度都为）暴力修改的复杂度是。这也就意味着分块是一种根号算法（时间复杂度是根号级别的算法），尽管它在时间复杂度上比不过线段树的。但是只要满足或者（为询问个数），基本上就不会TLE（1s）。 既然已经知道了的来历，我们对数组进行分块时就简单了。首先循环次用以记录区块的起点和终点，但是注意如果数组长度不为完全平方数就需要将最后一个区块（编号为的区块）的终点下标设为以免访问越界。开两个长度略大于的数组st和ed分别记录每个区块的起点下标和终点下标；加上一个查询数组bel，用于查找第个数所属的区块编号；同时为了避免后期访问到最后一个区块时出现下标越界RE的情况，再开一个长度的数组记录每个区块长度（也可以只开一个变量存，特判是否是最后一个区块即可）。接下来就可以循环遍历整个数组了： 这是求解区间和的一段代码，init()函数中，我们把每个区块的和存在sum对应下标处 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define N 1000010#define SQN 1010typedef long long ll;int st[SQN], ed[SQN], size[SQN], bel[SQN];ll a[N], tag[N], sum[N];void init() { int sq = (int) sqrt(n); for (int i = 1; i &lt;= sq; i++) { st[i] = sq * (i - 1) + 1; ed[i] = sq * i; size[i] = ed[i] - st[i] + 1; } ed[sq] = n; size[sq] = ed[sq] - st[sq] + 1; for (int i = 1; i &lt;= sq; i++) { for (int j = st[i]; j &lt;= ed[i]; j++) { bel[j] = i; sum[i] += a[j]; } }} 按照如上所述的修改原理： 123456789void update(int l, int r, int x) { if (bel[l] == bel[r]) { for (int i = l; i &lt;= r; i++) a[i] += x, sum[bel[i]] += x; } else { for (int i = l; i &lt;= ed[bel[l]]; i++) a[i] += x, sum[bel[l]] += x; for (int i = st[bel[r]]; i &lt;= r; i++) a[i] += x, sum[bel[r]] += x; for (int i = bel[l] + 1; i &lt; bel[r]; i++) tag[i] += x; }} 询问区间和的原理比较相似，同样是分l和r所在区块进行讨论。只是当进行整体区块操作时，用与线段树相似的方法——将标记乘到总和中并累加即可。 1234567891011ll askSum(int l, int r) { ll res = 0; if (bel[l] == bel[r]) { for (int i = l; i &lt;= r; i++) res += (a[i] + tag[bel[l]]); } else { for (int i = l; i &lt;= ed[bel[l]]; i++) res += (a[i] + tag[bel[l]]); for (int i = st[bel[r]]; i &lt;= r; i++) res += (a[i] + tag[bel[r]]); for (int i = bel[l] + 1; i &lt; bel[r]; i++) res += (size[i] * tag[i] + sum[i]); } return res;} 以上求区间和的代码可以提交到洛谷 P3372 线段树模板 一里。与线段树相比，分块的速度慢了大约40ms，在300ms左右，还是可以接受的。","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Hexo云后台——Qexo搭建教程","slug":"qexo-deploy","date":"2024-02-14T17:52:57.521Z","updated":"2024-08-24T05:25:33.354Z","comments":true,"path":"articles/17536/","link":"","permalink":"https://justpureh2o.cn/articles/17536/","excerpt":"","text":"在开始之前，首先你需要有一个自己的域名（官方提供的github.io 域名不算在内，确保你必须能够亲自更改 DNS解析设置），并已经在博客仓库设置的 Pages 选项卡中绑定自己的域名。 本文使用 PostgreSQL+Vercel+Github Actions 部署云端后台及实现自动更新推送等功能。建议在阅读本文的同时查询官方文档以获得最保险的效果。 部署 Qexo 环境 官方提供了四种方式来部署 Qexo 环境，其中一种允许你在本地进行部署，另外三种各自使用了不同网站提供的免费数据库服务。综合考虑操作便捷性和成功率，这里选用 Vercel 提供的免费 PostgreSQL 服务进行部署。 首先点击这里进入 Vercel 的仓库克隆界面。建议新建一个私有仓库进行 Qexo 仓库的克隆工作，第一次操作时你需要授权 Vercel 登录你的 Github 账号，在新跳出的浏览器窗口里按顺序授权即可。 设置好仓库名称后，点击 Create 创建，下边会有一个 Deploy 界面。Vercel 在创建和更改仓库时会自动进行一次部署，因此创建完毕后部署将会自动启动，并且这第一次部署是一定会失败的。因为 Qexo 所依赖的数据库还没有配置。因此点击网页左上角的三角形符号，或者点这里快捷进入你的项目管理页面。不出意外的话，界面将是这个样子： （我这里是已经配置好了 Qexo） 然后我们开始配置 PostgreSQL 数据库，在 Storage 界面可以申请，点击右上角 Create Database并选择Postgres，Vercel 的免费 PostgreSQL 数据库仅限创建一个，如果你先前没有配置过——点击 Continue进入数据库连接配置，在Connect界面选择地区为Washington DC或者USA (east)。创建完毕后，在 Storage选项卡里选择进入你创建的数据库配置界面。在左侧边栏点击Project，接着点击 Connect Project： 选择自己想要部署 Qexo 的仓库即可，接着回到项目管理界面，点击部署用的仓库。在 Settings 里面选择 Domains 域名选项，添加自己购买的域名。 不要将域名直接指向到主页地址，如果你购买的主域名是abcd.xyz，务必绑定到它的子域名例如 admin.abcd.xyz，而不能直接绑定到abcd.xyz！ 当你添加了一个目标域名后，Vercel 会自动对填入的域名进行 DNS 检查，若第一次配置，大概率会出现以下报错信息： 此时你需要打开自己域名的DNS解析设置，添加一个A解析：主机记录为 @，记录值为 76.76.21.21。补充一句，这个IP地址指向 vercel.app 的域名服务器，然而这个域名已经处于DNS污染的状态，无法访问。Vercel的临时备用方案是将IP改成 76.223.126.88，事实证明到现在这个方案还是有效的。 配置完部署域名后，转到顶端选项卡 Deployment 中点击 Redeploy 开始二次部署。一般等待一分钟左右无报错信息即可完成部署。 如果你使用的是 MongoDB，有可能在二次部署开始三到四分钟后接收到部署失败的信息。如果失败信息里出现了类似于 handshake failed 的握手失败信息时，建议放弃该方法（很可能是国内墙掉了MongoDB的连接接口导致部署时无法访问）并转而使用上边介绍的PostgreSQL法重新部署。 查看其他部署具体步骤，见官方文档——部署；若部署时遇到报错，可以进入官方文档——常见问题排错。 初始化 Qexo Github 配置 部署完毕后，切换到绑定的域名，本例中我们转到 admin.abcd.xyz。如果没有出现 Qexo 的初始化配置界面，试着转到 admin.abcd.xyz/init/。如果你使用 Hexo，并在 Github 上托管，在 Github 的配置界面，你会看到这几项： （这是已经配置好的 Qexo 的设置界面，只是我将填写的内容删去了，但是项目是完全一致的） Github 密钥这一项，你需要在Github设置中申请。右上角选择 Generate New Token，有两个选项，选择 classic。接着完成身份验证。改变如下几项： Note 必填，作为这个token的使用目的；Expiration 是生效期限，安全起见建议设置一个较短的期限，然后定时重置，重新配置Qexo设置，这里我选择的是永久有效；在下边的生效条目里，保证 repo 下的复选框全部勾选，建议同时勾选 workflow，但官方不建议给出所有权限。这么做的目的是保证Qexo有足够权限访问Github API从而在线修改Github博客源码的内容。 申请完毕后复制下来，出于安全，Github仅在token初次创建完毕后给出复制选项，所以尽快保存，并填入初始化界面的“Github 密钥”文本框中。 然后在Github里新建仓库，用于存放博客源码。接着在本地转到你的博客源码文件夹中（就是你执行 hexo clean &amp; hexo g &amp; hexo d 的文件夹），右键点击 git bash here，依次键入以下的代码： （“查看”里勾选“显示隐藏的文件”后，若源码目录下没有名为 .git 的文件夹，有则跳过该步骤）git init 复制仓库的网页地址，例：https://github.com/&lt;username&gt;/&lt;repo&gt; 输入 git remote add &lt;name&gt; https://github.com/&lt;username&gt;/&lt;repo&gt;.git（这里的 &lt;name&gt; 任取，但保证先前未创建过，且不与已经存在的 &lt;name&gt; 重复，否则将可能不会上传当前的文件夹） 输入 git pull &lt;name&gt; master，master 可更改，但保证和新建仓库的主branch同名 输入 git add .（注意有个点） 输入 git commit -m \"Commit内容\"（内容可更改，但需要用半角双引号包裹起来） 输入 git push &lt;name&gt; master（ master 保持前后一致即可） 如果是第一次上传，按顺序执行以下七步操作；如果已经上传过了，想要提交一些个人的更改，执行第四到第七步即可。“Github 仓库”这一项就填刚刚创建并上传的源码仓库，格式是 &lt;username&gt;/&lt;repo&gt;（例：mynameisabcd/BlogSourceCode）。 “项目分支”填源代码仓库的主要分支，一般是 master；“博客路径”留空即可。 若使用Gitlab，或者想要通过本地进行初始化，见官方文档。 Vercel 配置 “VERCEL_TOKEN”一项，需要在这里生成。 同样是填写 token 名称、生效范围（这里选择 xxx's projetcs）和生效期限（建议期限短些）。完毕后点击 Create 生成密钥，也是需要尽快复制下来，粘贴到“VERCEL_TOKEN”里。 “PROJECT_ID”则需要回到Vercel对应的项目的 Settings 里，在 General 选项卡中向下翻到 Project ID 并复制内容，粘贴到 PROJECT_ID 中就完成 Vercel 配置了。 接下来你还需要设置管理员账号密码，设置完毕后就可以从 admin.abcd.xyz 快捷进入管理界面了。 Github Actions 自动部署 脚本如下，将如下代码复制到路径 .github/workflows/main.yml 文件中，如果不存在则新建并复制内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374name: 自动部署 Hexoon: push: branches: - masterjobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [20.x] steps: - name: 开始运行 uses: actions/checkout@v2 with: submodules: true - name: 安装Pandoc uses: nikeee/setup-pandoc@v1 - name: 设置 Node.js ${{ matrix.node-version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node-version }} - name: 安装 Hexo CI run: | export TS='Asia/Shanghai' npm install hexo-cli -g - name: 缓存 uses: actions/cache@v1 id: cache-dependencies with: path: node_modules key: ${{runner.OS}}-${{hashFiles('**/package-lock.json')}} - name: 安装依赖插件 run: | # Install Plugins with 'npm install' - name: 安装插件 if: steps.cache-dependencies.outputs.cache-hit != 'true' run: | npm install - name: 配置SSH私钥 env: HEXO_DEPLOY_PRIVATE_KEY: ${{secrets.GIT_PRI}} run: | mkdir -p ~/.ssh/ echo \"$HEXO_DEPLOY_PRIVATE_KEY\" &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts - name: 部署博客 run: | # 以防万一有些遗留代码还是没删 # hexo clean 以下的代码都是必需的，不可删去 git config --global credential.helper store git config --global init.defaultBranch master git config --global user.name \"${{secrets.GIT_NAME}}\" git config --global user.email \"${{secrets.GIT_EMAIL}}\" git config --global user.password \"${{secrets.GIT_PSW}}\" hexo clean hexo g -d cd ./public git init git add . git commit -m 'Update' git push --force --quiet 'https://${{secrets.GH_TOKEN}}@github.com/${{secrets.GH_REF}}' master 常见问题 Q：出现“node deprecated.js”、“Cannot find module 'hexo' from XXX”怎么解决？ 将 Node.js 的版本更新一下，建议至少在 18 以上。具体在工作流文件的开头修改： 123456jobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [20.x] # 修改此处数字，建议至少为18，推荐20 Q：自动部署时 Actions 报错“fatal: could not read Username for https://github.com/XXX/XXX”怎么办？ 首先检查一下你的工作流文件是否已经正确配置，看一下有没有在进行提交操作之前给 git 设置对应的用户名和密码。如果已经设置了用户名和密码，且问题依旧存在，则考虑将 _config.yml 文件的部署选项改成如下形式： 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://&lt;Your Github Token&gt;@github.com/&lt;Your Username&gt;/&lt;Your Username&gt;.github.io.git branch: master 通过先前生成的 token 来访问仓库。 Q：我的博客使用 Pandoc 渲染器来渲染数学公式，渲染器又需要依赖本地安装的 Pandoc 程序来渲染，如何为在线部署添加 Pandoc 支持？ 在工作流的靠前位置添加一个配置 Pandoc 的工作即可： 12- name: 安装Pandoc uses: nikeee/setup-pandoc@v1","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://justpureh2o.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://justpureh2o.cn/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"后端","slug":"后端","permalink":"https://justpureh2o.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"qexo","slug":"qexo","permalink":"https://justpureh2o.cn/tags/qexo/"}]},{"title":"信息竞赛 高级数学","slug":"oier-math-senior","date":"2024-02-13T19:02:49.000Z","updated":"2024-02-17T18:22:46.873Z","comments":true,"path":"articles/15336/","link":"","permalink":"https://justpureh2o.cn/articles/15336/","excerpt":"","text":"诗曰： “高数第一杀手，考试一考就寄。复数知识一用，算成正一。朴素演算善后，死磕公式何必？考场信心十足，全错当场暴毙。” 前置知识：复数、位运算 Part1. 快速傅里叶变换 Div1. 世界上最优雅的算法 FFT起源 FFT的前身是DFT，可以简单看作是一堆OIer争先恐后对DFT算法进行优化的结果。美苏冷战期间，双方都对自己的核实力有所隐瞒，就等着某一天用自己的核导弹打对方个措手不及……在一次科学议会上，有人提出在苏联国境周边安装大量地震波传感器，将传感器的数据回收处理，分析是否出现了类似于核试验产生的震波从而判断苏联是否在进行秘密核试验。但是在当时用于频谱分析的DFT算法效率太过低下，传感器又必须在短时间内分析大量的频谱数据，因此逆境出人才——当时参与会议的其中一位科学家Tukey后来找到了程序员Cooley，后者在当时是一名操作ENIAC的程序员。二者分工明确，在1965年他们提出了FFT算法（当时叫做Cooley-Tukey算法），这个算法在后来被IEEE列入他们主编的“20世纪十大程序算法”之中。 FFT在信号处理领域受到了广泛的应用，直至今日它仍然被集成在大多数波谱分析仪器中作为底层算法之一。然而在信息学竞赛中，它被广大的OIer看中，拿去优化了高精度乘法的计算。它可以将朴素的高精度乘法的复杂度大幅降低到，在处理大数据时，它将比Karatsuba乘法算法更为高效…… Div2. 系数表示法与点值表示法 我们在初中时期学过一元二次方程的函数图像。一般情况下，我们都会用形如：的解析式形式来表示它。这种表示函数的方法就叫做系数表示法——自变量的某次幂前乘一个系数得到的，一个次多项式的系数表示法定义为：。 系数表示法可以直接通过值求出值，就好比生物的基因组排列，给出一个基因组，科学家就可以复原出整个生物的全貌，如果在各种函数绘制工具中输入解析式，它都唯一对应一个图像；但点值表示法就不是这样的了。它好比生物的某个性状，并且只是一个小得不能再小的特征点。比如给你两个特征：“白色毛发”和“部分呈现黑色”，不同人会做出不同的回答——动物学家会说“熊猫”、“斑马”、“美国短毛猫”一类的事物；阿宅会说：“伊雷娜”、“仆人”等等。加入其他限定词可能会使结果统一化，但是对于数学函数来说，你需要限定它的最高次数。如果你只给出了点，“求出经过点的二次函数”这样的问题显然是不合适的，因为次函数最少需要个不同的点来唯一确定。 假如我们让一个三次函数和一个四次方程相乘求卷积，得到的函数将会是一个七次函数。如果我们需要将系数转换为点值，需要取定义域上七个不相同的值进行计算，对于每次计算，要将值以不同次幂代入至多七个算式中求出值，显然时间复杂度是的。那还不如不优化 为了减少这里的复杂度，我们借助一点高一所学的奇偶函数的内容~（没学过/没学懂没关系，奇函数相当于关于原点对称、偶函数相当于关于轴对称，并且函数的取值范围也必须关于原点对称——假如能求出对应值，也必须能求出对应值）。 假如该函数是一个偶次的幂函数，幂函数的定义是。如果此处为偶数，整个函数就是一个偶函数、反之为奇函数。对于偶函数满足、奇函数。那么我们可以把原函数分解成多个偶函数和奇函数的和，例如： 函数 经过一轮拆分：。根据奇偶函数的性质：奇函数+奇函数=奇函数、偶函数+偶函数=偶函数。因此左边括号整体组成的函数是奇函数、右边括号整体组成的函数是偶函数，常数单独拆出来： 这张图可以直观看出原函数（绿线）被拆分成偶项（红线）、奇项（蓝线）和常数项（橙线）后的样子。 对于奇项，代任意，求出一个值后，第二个值直接取相反数；偶项则是相反，结果相同。当然只拆一次是不够的，里面还有很多项呢，我们试着把原函数拆分成只有一项，以递归计算。我们对奇项和偶项继续进行拆分 令，。但是此时和的取值变成了平方，相对应地，继续拆分一次，括号里的会变成。因此取相反数值不管用了（），我们急切地想要找到就算平方后也是相反数的一对数据来求值。此时高阶思维娃找到了一个东西——复数域。 Div3. 单位根 首先花一些篇幅来介绍复数的概念。我们学过：形如这样的的一元二次方程是无解的。这并不完全正确——严格来说是在实数范围内无解，这个问题自从几千年前、方程发明之初就引来了无数数学家的疑问与探索，人们找来找去就是为了能找到一个阿拉伯数字，让它的平方等于。很可惜，找不到，因为传统意义上的阿拉伯数字体系建立在实数基础上，又不在实数范围内，自然所有的尝试都会以失败告终。直到有一天，笛卡尔提出了虚数的概念，认为它是“不存在的数”、紧接着高斯使用虚数符号来表示的值，后面他又提出了“复平面”来将复数表示成平面上的一个向量。虚数这才有了立足之地。 而复数就像是实数和虚数的一次友好会面，复数域用字母表示，一个复数由实部和虚部组成。例如复数，它的实部是、虚部是。 紧接着，我们的FFT之旅就要来到下一个目的地——复平面。复平面类似于平面直角坐标系，只不过轴变成了实数、轴变成了虚数。复平面的轴因而称作实轴、轴称作虚轴，刚才的复数可以看作复平面上的一个向量。 比如说上一节遗留的式子，递归继续深入一层时，递归函数会变成。假如我们要让括号里的数是1，也就是这个函数在自变量为时的取值（事实上取成1恰好符合单位根的定义，于是就有简便的计算方式），我们就要解决的问题，而且还必须各不相同……两边同时开根号：。展开成方程组就是：，根据的数学定义，方程1解得，方程2解得。也就是：。 每次递归，函数括号中的参数的幂就会乘2。幂在数值上就是，解决次多项式的拆分需要给出个不同的值，因而递归层数满足如下关系：。因此原方程是七次方程，就需要递归三层，得到8个相异的，从而计算出8个点！ 引入单位根的概念：满足的复数叫做次单位根。在复平面上，次单位根将复平面上的单位圆等分。回到上例中的四次单位根，它们在复平面上的分布如下图： 点和点恰好对应实数解，点与点对应复数解。 如果是八次（）单位根，图像如下： 其中，对应复数，其余同理。由于次单位根相当于将单位圆平分为份，并且其中有一个解一定是（上图点）。联系到三角函数在单位圆中的表示，复平面单位圆上的点一定满足。因此若，则。 假如我们按逆时针方向，起始点（实轴）从0开始编号，并将八次单位根和四次单位根的图像作比较，可以导出单位根的两条性质（）： （对应点关于原点对称） （单位根次数和编号同乘2，坐标相同） 特殊地，. 这下终于可以开始从一般例子出手推了。令。 按照奇偶项分为两组（这里可以直接通过的奇偶性判断），折半次数，递归层数为1——令奇项函数为，偶项函数为。（奇项提出一个避免出现小数次幂）、。将奇偶项的自变量设为以表示出原式，即未折半的函数的未知数的次数：。 函数的自变量来到了，令。该轮到单位根显神通了，令，此时的，根据上述单位根的两条性质，推出如下式子： ，根据第二条性质，次数编号同除以2，得到： ； 如果此时原式、根据第一条性质，以及特殊情况，代入，根据第二条性质，次数编号同除以2，得到： 。 正因此，当已知时，代入计算，那么当取时的值也就明确了（根据性质第二条直接求出）。和就可以将问题规模缩小一半，递归的边界就是。 Div4. IFFT与蝴蝶操作 IFFT的中文名称是快速傅里叶逆变换。有些人比如刚开始接触FFT的我认为只要敲出FFT的代码，就可以解决任何函数卷积的问题了……错了，FFT主要是将系数表示法转换为点值表示法，相当于数学考试解析式求解题题干里给你的已知点坐标！卷积之路才刚刚过半，接下来介绍如何将相乘后得到的点值表示法重新转化为系数表示法。由于FFT是系数到点值的转换、这种方式是点值到系数的转换，因而称之快速傅里叶逆变换——IFFT。 我们的FFT算法已经将两个函数的卷积按照点值形式求了出来，但是一般生活中大家还是习惯性使用解析式，也就是系数表示法表示一个函数，就需要借助IFFT将卷积的点值形式重新转化为系数形式。 假设一个函数的系数形式在经历了一次FFT后变成了其点值形式。根据FFT有：。IFFT的作用就是将变成，下面是具体操作： 简记为：根倒求和、倒乘积。 再加上，复数的乘积在复平面上有个奇妙的性质：复平面上一个向量可以看作是从实轴正半轴逆时针旋转特定的角度后得到的，这个角度称作向量的辐角，复数相乘时，得到的结果的辐角将是这两个向量的辐角之和、模长将是两个向量模长的乘积。简称辐角相加、模长相乘。除法作为乘法的逆运算，它在复平面上操作的结果是辐角相减、模长相除。因而单位根的倒数可以看作，也就是从实轴正半轴顺时针旋转的辐角大小。计算时就可以把原单位根关于实轴做一次对称变换，即虚部取相反数，也就是共轭。 对于代码的设计，尽管C++STL库提供了Complex&lt;&gt;复数类，但还是建议手写Complex。因为STL库的运行效率有时会很慢，会被卡掉，而且它的码量也不大，手写难度不高。强烈推荐手写结构体Complex。 递归Version： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define N 6000010using namespace std;const double PI = acos(-1.0);struct Complex { double real, imag; Complex(double r = 0.0, double i = 0.0) { real = r, imag = i; } } f[N], g[N];Complex operator +(const Complex &amp;l, const Complex &amp;r) { Complex res(l.real + r.real, l.imag + r.imag); return res;}Complex operator -(const Complex &amp;l, const Complex &amp;r) { Complex res(l.real - r.real, l.imag - r.imag); return res;}Complex operator *(const Complex &amp;l, const Complex &amp;r) { //(a+bi)*(c+di)=(ac-bd)+(ad+bc)i Complex res(l.real * r.real - l.imag * r.imag, l.real * r.imag + l.imag * r.real); return res;}Complex operator /(const Complex &amp;l, const Complex &amp;r) { //(a+bi)/(c+di)=(a+bi)(c-di)/(c^2+d^2)=[(ac+bd)+(bc-ad)i]/(c^2+d^2) Complex res((l.real * r.real + l.imag * r.imag) / (r.real * r.real + r.imag * r.imag), (l.imag * r.real - l.real * r.imag) / (r.real * r.real + r.imag * r.imag)); return res;}void FT(int len, Complex *c, int type) { // type=1时为FFT，type=-1时单位根纵坐标取相反数，为IFFT if (len == 1) return; Complex c1[len &gt;&gt; 1], c2[len &gt;&gt; 1]; // c1为偶项系数，c2为奇项系数，数组大小除以2 for (int i = 0; i &lt;= len; i++) { // 按奇偶性分类存储 if (i % 2 == 0) c1[i &gt;&gt; 1] = c[i]; // 紧凑存储，c1、c2数组下标除以2 else c2[i &gt;&gt; 1] = c[i]; } FT(len &gt;&gt; 1, c1, type); // 处理偶项 FT(len &gt;&gt; 1, c2, type); // 处理奇项 Complex omega = Complex(cos(2.0 * PI / len), type * sin(2.0 * PI / len)); // 计算单位根 Complex k = Complex(1.0, 0.0); register Complex butterfly; for (int i = 0; i &lt; (len &gt;&gt; 1); i++, k = k * omega) { butterfly = k * c2[i]; // 蝴蝶操作，记录下复数乘积（现场算太慢）便于调用 c[i] = c1[i] + butterfly; // 单位根 c[i + (len &gt;&gt; 1)] = c1[i] - butterfly; // 单位根性质，系数取反得到另一半 }}void IFFT(int len, Complex *c) { FT(len, c, -1);} void FFT(int len, Complex *c) { FT(len, c, 1);}int main() { int n, m; cin&gt;&gt;n&gt;&gt;m; for (int i = 0; i &lt;= n; i++) cin&gt;&gt;f[i].real; for (int i = 0; i &lt;= m; i++) cin&gt;&gt;g[i].real; int len = 1; while (len &lt;= n + m) len &lt;&lt;= 1; // 得到最小递归层数 FFT(len, f); FFT(len, g); for (int i = 0; i &lt;= len; i++) f[i] = f[i] * g[i]; // 点值相乘得到卷积点值 IFFT(len, f); // 卷积点值转化为系数 for (int i = 0; i &lt;= n + m; i++) cout&lt;&lt;(int) (f[i].real / len + 0.5)&lt;&lt;' '; return 0;} 时间复杂度： 这个代码足够通过模板题有些人说不行，只需把数组开大一点点（5e6起步）就可以了……但是这个代码其实还可以继续优化，但是这下就很棘手了，本来推来推去已经够烧脑了你还要让我优化？，考虑到递归算法有些低效，浪费了一些空间和执行效率。那么我们如何把它变成一个非递归版本呢？答案是迭代！ 迭代FFT与二进制优化 我们按照奇偶下标将原多项式分为了偶项和奇项，这样做的复杂度是。我们仔细观察一下抽出的系数之间下标的联系： 递归之前，系数下标： 递归一层，系数下标： 递归两层，系数下标： 递归三层，系数下标： 既然称作二进制优化，我们来看看第三层的数字写成二进制形式是怎样的：000 100 010 110 001 101 011 没有规律……别急，我们把数字倒过来念：000 001 010 011 100 101 110。诶？他们是单调递增的，再写成十进制就是：0 1 2 3 4 5 6。我们就找到规律了：递归结束时系数下标的二进制值等于原多项式的系数下标的颠倒二进制值 常规操作，我们使用进制转换来实现二进制逆序，这样的时间复杂度是的： 123456789int rev(int n) { int res = 0; int k = log2(n) + 1; for (int i = 1; i &lt;= k; i++) { if (n &amp; 1) res += pow(2, k - i); n &gt;&gt;= 1; } return res;} 借鉴了这篇题解的逆序思路，逆序的时间复杂度是的，处理数组的复杂度是的： 123456789101112131415161718192021int l,r[MAXN];int limit=1;void fast_fast_tle(complex *A,int type){ for(int i=0;i&lt;limit;i++) if(i&lt;r[i]) swap(A[i],A[r[i]]);//求出要迭代的序列 for(int mid=1;mid&lt;limit;mid&lt;&lt;=1)//待合并区间的中点 { complex Wn( cos(Pi/mid) , type*sin(Pi/mid) ); //单位根 for(int R=mid&lt;&lt;1,j=0;j&lt;limit;j+=R)//R是区间的右端点，j表示前已经到哪个位置了 { complex w(1,0);//幂 for(int k=0;k&lt;mid;k++,w=w*Wn)//枚举左半部分 { complex x=A[j+k],y=w*A[j+mid+k];//蝴蝶效应（应为“蝴蝶操作”） A[j+k]=x+y; A[j+mid+k]=x-y; } } }} 以及r数组的读入： 12for(int i=0;i&lt;limit;i++) r[i]= ( r[i&gt;&gt;1]&gt;&gt;1 )| ( (i&amp;1)&lt;&lt;(l-1) ) ; 当然，提高组不考，如果考到，基本上那个递归版本也够用了……","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.cn/tags/%E5%AD%A6%E6%9C%AF/"}]},{"title":"约瑟夫环——春晚魔术表演原理解析","slug":"magic-show-with-josephus","date":"2024-02-10T08:23:45.000Z","updated":"2025-02-02T11:02:21.014Z","comments":true,"path":"articles/60629/","link":"","permalink":"https://justpureh2o.cn/articles/60629/","excerpt":"","text":"（操作没成功の尴尬，图片来自知乎） 前言 这篇文章从数学方面推导刘谦2024年央视春晚上表演的第二个魔术的秘密、分析尼格买提错误之处，并在已知信息的加持下尝试推测尼格买提手上所剩的两张半面扑克牌的牌型。有一说一撒贝宁是真的会测假 对应魔术节目：《守岁共此时》的回看请戳这里，在一小时十分整处。 魔术步骤 四张牌面向下，并打乱。 对折四张牌，并沿折痕撕开，得到两批半牌，每批四个共八个半牌 （反过来折是为了方便撕开）。将左右手的两批牌按同一个方向叠在一起。 根据自己名字的字数，从上端挨个拿出一个牌放到最底端，执行字数次。 拿起最上面三张，插进其他牌的中间（意思是这三张看作一个整体，不能放在最上面或者最下面，必须夹在其他牌中间）。 拿起最上边的牌，藏起来不要看魔术常规操作之不要看。 继续从最上边拿牌：南方人拿一张、北方人拿两张、不确定就拿三张。然后像第四步那样插进中间位置。 还是从最上边拿牌：男生拿一张、女生拿两张。然后将拿出的牌扔出去。 「见证奇迹的时刻」——每一次操作，将最上边的牌移到最下边，每次仅移动一张牌，进行七次。 「好运留下来，烦恼丢出去」——对于每次操作：第奇数次，将牌移到最下边；第偶数次，丢出去。最后直到只剩一张牌 最后拿出藏起来的牌，如果你的名字在四个字及以内、且操作无误，你会发现这两张半牌是严丝合缝的，他们可以拼成一张牌！ 列数模拟 先不管你拿了哪几张牌，也不管打乱前它们的先后顺序如何——因为它们都跟魔术本身、也和我们的推导无关。我们只着眼于打乱后的牌，将它们按照上下依次编号为1~4。如下图： 1234 沿折痕撕开，假设第1号牌撕成的两张半牌编号为1和A（数字在上字母在下），八张半牌叠在一起，得到的牌堆是这样的： 1234ABCD 接下来的推导就围绕上面这个牌堆开展。 对应第三步——从上边拿出和自己名字字数相同的牌，放到最下边。假如我拿出三张，也就是编号为1、2、3的三张牌，放到最下边。牌堆变成这样： 4ABCD123 第四步——再拿出最上边三张牌，卡到中间去： CD4AB123 第五步——藏起最上边的牌，也就是编号为C的牌。 第六步——根据南北方人拿牌。因为我祖籍北方出生在南方，我这里就拿三张牌插入到中间位置（B和1之间）： ABCD4123 我是男生，丢最上边的一张牌，也就是说丢出编号为A的那张（此时内心默默丢掉了两张牌）： 男：BCD4123 女：CD4123 然后是见证奇迹的时刻。此时男生手里剩下7张牌、女生则是6张。这里其实无需说出那句咒语：如果你是男生，就不做操作；如果是女生，就将最上边的牌放到最下边。 男：BCD4123 女：D4123C 最后是好运留下来、烦恼丢出去。按照规则，我们要轮流进行两个操作：移动最上边的牌到最下边、丢掉最上边的牌。如此操作直到只剩下一张牌。这其中涉及到一个知识点——约瑟夫环问题 约瑟夫环问题 百度百科 约瑟夫问题 简而言之，就是从特定编号出发，每经过个数便将此时的数字挑出，剩下的数重新编号（保证起始编号相同），问最后剩下的编号是什么。这个环节的操作在这个例子下可以被抽象成：从D开始，每两次操作，丢出第二张牌。 也就是说，七个人围成一圈，“1、2、1、2……”的报数，最后剩下的是几号。这里有一个巧算的方法，适用于“1、2、1、2……”报数模型。首先找出不大于人数7的最大的2的整数幂，因为，所以令。当最终剩下个人的时候，第一个报数的就是最后一个被留下的，因此有公式：。 对于男生，最后剩下的牌就是最下边的那一个，编号3。 对于女生，剩下的是第个，同样是3。 拿出藏起来的牌C，我们开头就知道了：第三张牌被分成了3和C。也就是说它们可以拼合成同一张牌！魔术成功了！ 回顾总结 不妨从一开始就观察3和C的变换规律，可以发现3号牌自从第三步结束后被移动到最下边以来就几乎没改变过位置；而前四步则是合力将C拉到了最前边好让它被顺利地挑出去。然而最为精妙的还是对“1、2、1、2……”报数约瑟夫环模型的应用。那么为什么尼格买提的操作会失败呢？看下图： 如果你是罕见的“第三性别”，想要在第七步里面丢三张牌，也是可以的，因为这样并不会改变最后一张牌3。事实上，这个魔术最多可以在第七步丢掉七张牌，这样下来就只会剩下一张牌3，全部完成之后还是可以和C配对成功的。 右上角是他的操作：他在“南方人和北方人”的操作里拿了三张牌，但是插入的时候错误将其中两张牌插到了最下边并且这两张牌和另外的那一张牌分开了（原规则是一起插到中间）。 因此这堆牌的底端变成了黑桃Q，不久之前，他藏起了一张黑桃A。所以，他最后拿出的牌是对不上的，一张是黑桃A，一张是黑桃Q。 下面是从班级群里偷的几张图，以实际证明这个理论是成功的： 当然，如果就某位“客串见证人”的失误而大做文章的话，显然是极其招人嫌恶的。刘谦本人的魔术并没有什么问题，尼格买提可能也只是太过关注自己接下来在春晚上的表现而有些分神罢了。如果这个失误真的导致2025年春晚刘谦不被总导演邀请上台的话，这种毫无底线夸大其词的舆论只会是雪上加霜，让所有人更不好过而已……事后小尼本人也道了歉，因此已经没有必要再抓住谁人的过错不放，只是从科学的角度出发，论证这个魔术的成功之处。毕竟少有节目能如此调动起屏幕内外所有人的互动热情，如此看来，刘谦的魔术也是非常成功的了。","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.cn/tags/%E6%95%B4%E6%B4%BB/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.cn/tags/%E5%AD%A6%E6%9C%AF/"}]},{"title":"信竞初等数论导论","slug":"number-theory-junior","date":"2023-11-25T17:37:52.000Z","updated":"2024-02-17T18:23:16.969Z","comments":true,"path":"articles/40325/","link":"","permalink":"https://justpureh2o.cn/articles/40325/","excerpt":"","text":"引入 如果说数论是数学体系中专门用来研究数字性质的一个分支，那么初等数论则是对整数的性质进行系统性的探讨与研究。千万不要因为其中的“初等”二字小瞧这初等数论尽管名称和学习难度上都没有高等数论那么有逼格，就像初等数学之于高数，数论的所有内容均筑基于此。其中欧几里得证明的算数基本定理（一切合数都可被分解为有限个质数的乘积）在质数筛、GCD（以及LCA)计算、无理数证明等问题上均有用武之地。可以说高等数论奠基于初等数论。它同时也是初学者接触数论的必经之路。 Part1. 前置知识 Div1. 数论有关定理 算术基本定理：每一个合数都可以被分解为有限个质数的乘积。即对于任意合数，都存在： ，其中为质数。 推论一：正整数的正因数集合为： 推论二：正整数的正因数个数为： 推论三：正整数的所有正因数之和为 质数分布定理：区间中，当时，质数个数。 费马小定理： 若是一个质数，则（为同余符号）。 欧拉定理（费马小定理扩展）： 若（与互质），则有，其中为欧拉函数。 Div2. 同余 同余，顾名思义，两个数分别除以一个正整数后得到相同的余数。即。但是它的定义给出了这样一句话：“对于正整数和，若（能被整除），则称和对模同余，记作”。当然以上两种说法是等价的。 同余具有以下三种基本性质： 反身性：对于任何正整数， 对称性：即对于，有 传递性：若，且，有 当然，它可以延申到计算机的模运算（毕竟出现了）。模运算有三种基本运算： 加运算： 减运算： 乘运算： 还有两个推论： 幂运算： 求和运算： 同余消去原则： 若同余号两端的项相等，且都与模互质，则可以同时消去 举例：，如果，则。 Part2. 质数 质数的判断：除了它自身以及以外，不存在其他正整数使得。 Div1. 质数判断 试除法： 这是三种方法中，唯一一种能做到100%正确的质数判断方法。对于给定数，遍历所有间的正整数，若出现则证明它不是质数，因为质数只能被1以及它本身整除。 123456bool isPrime(int n) { for (int i = 2; i * i &lt;= n; i++) { if (n % i == 0) return false; } return true;} 复杂度： 适用范围：普及、提高 试除法の大胜利！ 费马素性检验： 是上述费马小定理的实际运用，它与常规算法思想有所不同：它主张在中随机选取一个数。若出现与费马小定理不符的情况，那么一定为合数；若每次均符合定理，称为 费马伪素数 ，因为它很大概率是一个质数。 1234567891011bool isPrime(int n) { if (n &lt;= 2) return false; int k = 10; while (k--) { srand(time(0)); int a = rand() % (n - 2) + 2; if (__gcd(a, n) != 1) return false; if (qpow(a, n - 1, n) != 1) return false; } return true;} 复杂度：，其中为随机数检验次数，是因为使用了快速幂算法。 适用范围：提高T2及以下（慎用） 为什么用该方法判断的质数 大概率 是个质数呢？不妨测试一下561（3）、1105（5）、1729（7）（括号内为它的最小因子），你会发现函数的返回值均为true，即都为质数。可见这个算法不是100%正确的，这些“漏网之鱼”被称为“Carmichael数”。它们极其罕见，一亿范围内仅255个。也因如此，你可以通过打表特判的方式抠掉这些特例（你保证记得住就行）。2016年中国物流工人余建春给出了一个Carmichael数的判断准则，这个标准目前在国际上得到了广泛认同。 对于优化，你可以在函数起始点加入类似于if (n % 2 == 0 || n % 3 == 0) return false;的特判，进一步降低复杂度。 Miller-Rabin算法： 该算法同样无法保证结果100%准确，慎用！ MB算法实质上是对费马素性检验算法的效率和准确度优化。算法流程如下： 将分解为的形式，其中为奇数 从中选取整数，称为“基数” 计算的值，若结果为或，则可能为质数，继续检验 若结果不等于或，计算、、……的值，若结果等于，则可能为质数，继续检验 若都不等于，则一定是合数。称为强费马证据。 当然，它同样有特例，称为强伪质数，如2047（23）、3277（29）、4033（39）等（括号内为它的最小因子）。 Div2. 质数筛 常见的质数筛法有：试除法、埃氏筛、线性筛。 试除法：从质数定义出发，即存在一个正整数，对于任意间的正整数，总有成立。代码实现只需枚举间所有正整数，并让对其取余。若取模运算出现则代表它不为质数，没有出现则为质数。 123456bool isPrime(int n) { for (int i = 2; i * i &lt;= n; i++) { if (n % i == 0) return false; } return true;} 复杂度： 适用范围：普及T2及以下 这里所展示的试除法代码实际上经过一轮优化。若严格根据质数定义，第二行的循环上限应为。考虑到如下性质：，若，则一定有。因此可以将循环上限压缩至。 埃氏筛：全称叫埃拉托斯特尼筛法，老哥生活在2200年前的古希腊，不借助望远镜就计算出了地球的周长（与真实值偏差仅0.96%）、同时他也是第一位根据经纬线绘制出世界地图的人、也是最先提出将地球根据南北回归线分为“五带”的大人物。他提出的筛法核心思想如下： 第一步：列出从2开始的一列连续数字；第二步：选出第一个质数（本例中为2），将该质数标记，将数列中它的的所有倍数划去；第三步：若数列中的末项小于它前一项的平方，则质数已全部筛出；否则返回第二步。 12345678void get(int n) { for (int i = 2; i &lt;= n; i++) { if (!vis[i]) { prime[cnt++] = i; } for (int j = 2; i * j &lt;= n; j ++) vis[i * j] = true; }} 其中，prime数组存储质数，vis数组用于标记（即上文中“划去数字”），变量cnt则存储中质数的个数。 复杂度： 适用范围：普及T2及以下 但是继续观察算法发现：我们其实无需将所有的倍数删去，只需删去前一步得出的质数的所有倍数即可。 这与前文介绍的埃氏法核心相符。因此将循环迁移至条件判断中即可： 12345678void get(int n) { for (int i = 2; i &lt;= n; i++) { if (!vis[i]) { prime[cnt++] = i; for (int j = i + i; j &lt;= n; j += i) vis[j] = true; } }} 优化复杂度： 适用范围：普及T3及以下 线性筛/欧拉筛：实质是埃氏筛的线性优化。因为在埃氏筛中，有些数字被重复筛了多次（例如30会被2、3、5筛到）。本着线性优化的原则，我们需要找到一个方法，使得每个合数仅被筛选一次。主要思想如下： 我们发现，线性筛和埃氏筛均使用了质数的倍为合数的结论。我们只需要保证每一个数仅被它自身的最小质因数筛出即可。即对于数字，是一个合数，且只会被筛出。 123456789void get(int n) { for (int i = 2; i &lt;= n; i++) { if (!vis[i]) prime[cnt++] = j; for (int j = 1; prime[j] &lt;= n / i; j++) { vis[prime[j] * i] = true; if (i % prime[j] == 0) break; } }} 复杂度： 适用范围：普及、提高 例题： P5736 【深基7.例2】质数筛 P5723 【深基4.例13】质数口袋 Part3. 因数 因数定义： 对于一个数，若存在一个正整数使得，则称是的因数。 Div1. 因数分解法 试除法：万能暴力解法。即遍历间的所有数，若可以整除，则和均为的因数。特殊情况：为整数时，因数仅有本身，因此需特判。 123456789101112vector&lt;int&gt; get(int n) { vector&lt;int&gt; ret; for (int i = 2; i * i &lt;= n; i++) { if (n % i == 0) { ret.push_back(i); ret.push_back(n / i); } if (n % (i * i) == 0) ret.pop_back(); } sort(ret.begin(), ret.end()); return ret;} 复杂度： 适用范围：普及T1 Div2.最大公约数 辗转相除法： 又是我们大名鼎鼎的欧几里得老先生提出的一套公约数算法，整个算极其简洁：核心只有一行，即： 两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数 可以写出： 123int gcd(int a, int b) { return b ? gcd(a, a % b) : a; } 但是为什么呢？我们可以通过以下方法证明： 假设如下关系：。其中被除数，除数，商，余数。则。 首先证明充分性：令、，即二者有相同因子。 代入初始除法算式得： 接着由于加减乘法的封闭性，即一个整数进行加减乘运算得到的结果同样是一个整数。可以得出：。即（）与有共同因子。 接下来证必要性。令、 Stein算法： 上一个方法的明显缺点在于，它处理大质数的效率并不好（但总体来说是很好的），因为它使用了取余运算，这会减慢一些速度。可以理解，生在2000多年前——一个没有电脑和OI的古希腊社会，这个算法已经足够兼顾常规效率和手推难度了。但是步入21世纪，加快的生活节奏毒瘤数据使得人们对更快算法的需求空前高涨。Stein算法便应运而生。 算法流程如下： 任意给定两个正整数，先判断它们是否都是偶数，若是，则用2约简，若不是，则执行第二步。 若两数是一奇一偶，则偶数除以2，直至两数都成为奇数。再以较大的数减较小的数，接着取所得的差与较小的数，若两数一奇一偶，仍然偶数除以2，直至两数都成为奇数。再次以大数减小数。不断重复这个操作，直到所得的减数和差相等为止。 两数相等时，第一步中约掉的若干个2与第二步中最终的等数的乘积就是所求的最大公约数。 123456789101112131415161718192021222324int gcd(int a, int b) { int p = 0, t; if (!(1 &amp; a) &amp;&amp; !(1 &amp; b)) { a &gt;&gt;= 1; b &gt;&gt;= 1; p++; } while (!(1 &amp; a)) a &gt;&gt;= 1; while (!(1 &amp; b)) b &gt;&gt;= 1; if (a &lt; b) { t = a; a = b; b = t; } while (a = ((a - b) &gt;&gt; 1)) { while (!(1 &amp; a)) a &gt;&gt;= 1; if (a &lt; b) { t = a; a = b; b = t; } } return b &lt;&lt; p;} 这个算法的优点在于：它大大优化了大质数的运算。但可惜的是，它的代码量膨胀了8倍，因此不太建议赛时使用。毕竟C++都给你内置了__gcd()函数嘛，干嘛不偷个懒？ Div3. 最小公倍数 我们可以简单概括成一句话： 两个数的最小公倍数等于这两个数的乘积与这两个数最大公约数的商 即： 凭啥呀？ 我们假设两个数和有最大公约数，则，且。并且和一定互质（若不互质，和的最大公约数就不会是，而是一个比大的值）。 由乘法交换律，可知： 消去得：。因为、互质，所以或者即为两个数的最小公倍数。得证。 例题： P1075 [NOIP2012 普及组] 质因数分解 P2424 约数和 （需要逆向思维） Part4. 欧拉函数相关 Div1. 欧拉函数推导 问：论牧师欧拉有多么的高产 答：平均每年800页数学论文你说高不高产嘛 欧拉函数，记作。表示中与互质的数的个数，即，满足的的总个数即为的值。举个例子，，因为在中，和均与互质。特殊地，。 欧拉函数有如下计算公式：若可被表示为（算术基本定理分解式）的形式，则。 推导思想即为用减去所有中所有与不互质的数。在计算机上实现，首先需要分解质因数。思路如下：首先抛出第一个质因数，那么将中所有的的倍数删去，因而可以保证筛出的数一定是的质因子，否则他们将存在最大公约数。那么能被整除的数的个数（也就是以内的倍数个数）为——其中的中括号代表整除。 因此我们离解出欧拉函数就进了一步了，我们的过渡式子就是。 好耶 别急着好耶，我们可以发现一个小小的推导谬误（可能并不是很容易发现）。当我们用去筛数时，使用的算式仍然是。对于形如的数，会被重复筛去多次，导致多减，最终结果会小于。有些抽象，我们来看这张图： 容斥原理 易知中可被整除的数字共有个，能被整除的数字共有个。但是如果说能被和整除的数字共有个，显然不合常理，因为、、都既能被整除，也能被整除，如果不加排除，他们将会被减去2次。因此需要补偿损失，正确的计算方法是（仅计算能被和整除的数的总个数）： 能被整除的：个 能被整除的：个 同时被和整除的：个 总个数：个（就是被绿圈和橙圈捆住的的数的个数） 那么对于、、整除问题，中间的被重复加了3次，需减去两次平衡收支。此即容斥原理的简单思想表示。 回到欧拉函数推导上来：过渡公式中的容斥问题可以解决一部分了。对于可同时被两个不同质数整除的数（例如、），我们加上它的总个数。 得到。 当然这又有一个小问题没完没了了是不是？：对于的公倍数，会被先减去3次，然后被上一步的操作加上3次，总体不加不减。还是回到上图：中间的会被每个颜色的圈先减去一次、共3次，上一步的补偿操作，可以看作又被橙绿圈（橙圈和绿圈的交集）、蓝绿圈、蓝橙圈一共加上了3次。减3次加3次相当于没动，为了让它被算上，我们需要加上它，对于则是全部减去（因为括号外有减号需要变号，不要忘记是由一系列不合规的数字个数相减得来的）。得到我们的过渡态3： 又是如上的容斥判断，这里我们省去讨论。将最终的产物合并得到：！（我不会合并，但是你可以把括号拆开看看是不是上述形式。总之，欧拉牛逼！） ，好耶！终于可以好耶了…… Div2. 欧拉函数代码实现 主要是如果压成一个Div会非常的长，因此这里新开一个Div2 我们明确了欧拉函数的推导，接下来就是整理思路写代码的时间了！我们也只需跟着原始思路走就可以了。再次回忆一下：首先我们需要筛出质因数，除去它的所有倍数，再用公式代入就可以了。 1234567891011long long eular(int n) { long long res = n; for (int i = 2; i * i &lt;= n; i++) { if (n % i == 0) { res = res * (i - 1) / i; while (n % i == 0) n /= i; } } if (n &gt; 1) res = res * (n - 1) / n; return res;} 时间复杂度： 适用范围：All Clear Div3. 欧拉函数推论 若为质数，则 让我们回到欧拉函数的定义上去：是中与互质的数的个数（特殊地，）。那么对于这个质数，有多少数与它互质呢？ 很显然，答案是个！因为的质因子只有本身，若不止一个质因子，很显然它不是一个质数。因此。 假设是一个质数，（或），且的值已知，那么 凭啥呀？ 因为已经是一个质数，换句话说：在这个条件下是的一个质因子。在计算时，就已经作为一个质因子以的形式乘进去了。此时可以写作 那么函数值多乘了一个 我们发现：(2)式中包含了(1)式，只是头上乘以了。因而得到 假设是一个质数，（或），且的值已知，那么 这东西长得和性质2很相似，唯一不同的是不再是的一个质因子了。但是变成了的质因子。因此我们计算的值时，不仅需要在头部乘上，而且还需要将乘进去： 因为，所以得到性质3，即。 这三个性质将作为重点性质出现在欧拉函数筛法中。 Div4. 欧拉函数线性筛 我们已经接触了简单的欧拉函数计算方法，那么又该如何解决形如：“给定一个正整数，求的值”的问题呢？ 考虑继续使用上面的朴素算法，时间复杂度将会是。明显无法满足需求，更何况，每个数与每个数之间的值之间有一种推导关系，使得我们无需每次重新计算值，而是用已经求出的来线性推出的值。 欧拉函数涉及到质因子的拆分，我们又需要在线性时间内求各种质数。自然而然想到了先前所学的线性筛： 12345678910111213int primes[N];bool st[N];int cnt = 0;void sieve(int n) { for (int i = 2; i &lt;= n; i++) { if (!st[i]) primes[++cnt] = i; for (int j = 1; primes[j] * i &lt;= n; j++) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } }} 我们运用这段代码可以得出范围内所有的质数，用st[N]数组可以筛出所有的合数。也就是说对于筛出的合数，我们能够得知组成它的质因子是什么，比如st[primes[j]*i]=true;这一行代码。接着套用上述三种性质，我们可以得出值。 此时我们就需要新建一个phi[N]数组来存储每个数的值，并且在代码中三个地方加入对于三种性质的公式： 1234567891011121314151617181920212223typedef long long ll;ll primes[N];bool st[N];int cnt = 0;ll phi[N];void phi_sieve(int n) { for (int i = 2; i &lt;= n; i++) { if (!st[i]) { primes[++cnt] = i; phi[i] = i - 1; } for (int j = 1; primes[j] * i &lt;= n; j++) { st[primes[j] * i] = true; if (i % primes[j] == 0) { phi[primes[j] * i] = phi[i] * primes[j]; break; } phi[primes[j] * i] = phi[i] * (primes[j] - 1); } }} 没错我开了long long防止爆int 时间复杂度： 适用范围：普及&amp;提高 对于开头提出的求和问题，遍历phi[1]到phi[n]的所有值求和即可。 Div5. 欧拉定理 若正整数与互质，则有 对于它的证明，百度百科中如此写到： 取的缩系，故也为的缩系。有 通俗来讲就是这样： 在中取所有与互质的数，很容易知道这样的共有个（根据欧拉函数定义得来）。它们都与互质。 给这列数同时乘上，得到。它们也都和互质，并且各不相同。 提出括号里乘了次的，得到以下关系式： 那么根据同余号两端的消去原则（左右两端两个项相同且与模互质），可以消去。得到，欧拉定理得证。 特殊地，如果是一个质数，有。这被称作费马小定理（先前的费马素性检验就是基于这个原理编写的）。 真不知道明明可以写得通俗点为什么非得省那点空间写看起来那么高深莫测的专业术语，真的是只写给自己看的。 Div6. 降幂算法 尤其对于绿题以上的题目，题面中可能出现“答案可能很大，请对大质数取余”的字样。这意味着题目可能涉及到大规模的幂运算，需要我们用简便的方法计算幂。对于一般的题目，我们使用快速幂。 快速幂：快速幂思想如下： 我们将指数分解为若干的和（二进制表示），例如：，因为。因而不必将连续乘11次，效率大幅提升。 1234567891011typedef long long ll;int qpow(int a, int k, int p) { int res = 1; while (k) { if (k &amp; 1) res = (ll) res * a % p; a = a * a % p; k &gt;&gt;= 1; } return res;} 时间复杂度： 适用范围：基本All Clear 欧拉降幂：上面方法一个缺点在于无法处理过大的指数，在处理类似于的计算时将会疯狂掉san。接下来介绍一种使用上面讲到的欧拉定理来解决大指数幂运算的方法。 欧拉降幂核心公式：（又称 扩展欧拉定理 ） 也就是说：我们只需要算出的值，再用快速幂算法，将作为新指数带入计算即可。当然，这里的可能会爆long long，因此可以选择使用字符串进行高精度计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef long long ll;ll primes[N];bool st[N];int cnt = 0;int qpow(int a, int k, int p) { int res = 1; while (k) { if (k &amp; 1) res = (ll) res * a % p; a = a * a % p; k &gt;&gt;= 1; } return res;}ll eular(int n) { ll res = 0; for (int i = 2; i &lt;= n; i++) { if (!st[i]) { primes[++cnt] = i; res = res * (i - 1) / i; while (n % i == 0) n /= i; } for (int j = 1; i * primes[j] &lt;= n; j++) { st[i * primes[j]] = true; if (i % primes[j] == 0) break; } } if (n &gt; 1) res = res * (n - 1) / n; return res;}int edp(int a, string k, int p) { ll phi = eular(p); int drop = 0; for (int i = 0; i &lt; k.length(); i++) { drop *= 10; drop += k[i] % phi; } drop += phi; return qpow(a, drop, p);} 其中eular(int n)函数用于计算欧拉函数的值、edp(int a, string k, int p)用于计算降幂后的指数、qpow(int a, int k, int p)是快速幂算法。 时间复杂度： 适用范围：所有 扩展欧拉定理可谓是欧拉定理的一般形式，它的定义如下：对于任意正整数、、，满足： $a^k $ 其中第二个式子就是欧拉降幂的核心公式。 扩展欧拉定理的证明见这里。因为太复杂了我不会证 例题： P2158 [SDOI2008] 仪仗队 （欧拉函数板子） P1447 [NOI2010] 能量采集（上一个问题的变式） P1226 [模板] 快速幂 P5091 [模板] 扩展欧拉定理 （欧拉降幂） P4139 上帝与集合的正确用法 （欧拉降幂+递归） Part5. 同余方程的解法 这里会涉及到一元线性同余方程，一元线性同余方程组和高次同余方程的算法解法。 Div.1 裴蜀定理 很多人会把他读成裴除（chú）（比如我的某位好友），这个名词正确的读法是裴蜀（shǔ）。或者可以直接改称作“贝祖定理”，它的提出者艾蒂安·裴蜀估计怎么也没想到后人居然连他的名字都读不对（想想如果这种事情发生到你身上会怎么样）。你也可以读他名字的法语发音（显得你很优雅且有文化）。 切入正题，裴蜀定理表述为：对于任意正整数，，总有整数、，使得，其中等价于，是数论中最大公约数的表述方式。 首先可以知道且，因为和都具有约数，让他们分别乘上另两个数和并不会改变这一约数。所以假设，有。在这里，。 Div2. 扩展欧几里得（EXGCD） 加了“扩展”二字是不是感觉逼格上来了？ 扩展欧几里得算法用于求出线性同余方程的解。线性同余方程，即形如的方程，我们需要求出的值。 回忆一下欧几里得算法的核心思路：。 再看看刚刚讲到的裴蜀定理，发现。根据余数的定义，有：。 那么我们的任务就是求出这里的和值，因此拆开括号，整理出和的系数：。观察裴蜀定理的形式：，我们得出的式子中，变成了。因此每次递归时需要将的值减去。 既然我们设计的是一个递归算法，我们就必须明确它的递归出口。根据欧几里得算法，当时，。我们把和代入发现：，得到，此时可取任意整数值，。这里我所取的解是。 最后，因为这本质上还是一个欧几里得算法，所以返回是有必要的（事实上exgcd算法返回的将作为推导式中的参与运算）。我们可以写出如下函数。 12345678910int exgcd(int a, int b, int &amp;x, int &amp;y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;} 时间复杂度： 但是，题目中一般不会给出裴蜀定理那样的形式，而是形如的形式，让你求出的值，并且上述方法仅求出了一元线性同余方程的一组特解，如果题目中让你求出最小正整数解呢？接下来就是解决上述问题的方法： 1. 同余—等式互转（自己起的名字）： 在上面的介绍中，我们遇到了一个问题：如何将这样的同余式变为这样的二元一次不定方程的裴蜀定理形式呢？ 考虑到同余方程的定义（或者你可以把以下关系死记住），得到。接着由余数定义，得到，移项得到：。提出负号，令，则。它有解的充要条件是。经过如上变换后就变成了裴蜀定理的形式，可以直接用exgcd求解和。 2. 最值解问题： 二元一次不定方程通解的证明 Div3. 中国剩余定理（CRT） 又称孙子定理（但我认为还是中国剩余定理听起来更有实力一些），最早见于《孙子算经》中“物不知数”问题，首次提出了有关一元线性同余方程的问题与解法。 对于一元线性同余方程：，可以构造以下方法求出通解。 首先，令。 然后，令，即除了外所有的乘积。 接着，令为在模意义下的逆元，即。 所以，的通解为：。 Div4. Baby Step Giant Step算法（BSGS） 这个算法用于解决一元高次同余方程问题，模意义下的对数也可以求。又称“北上广深算法”（想出这种名字的人真是人才）。 高次同余方程长成这个样子： 发现跑到了指数上边真是变态呢。这种问题显然没公式解，于是苦恼的人们只得选择一条略显暴力的求解道路，即搜索。严格来说，BSGS所使用的是双搜索，其中的一个变量的搜索步长会长于另一个变量的搜索步长，因而得名“大步小步算法”。或者叫北上广深/拔山盖世算法！ 朴素BSGS（与互质）：不妨令，原式为。根据消去原则，两边同乘得。 接下来我们对同余号右侧的部分求值，再任命一个固定的值，使得左侧模的值等于右侧模的值。为了快速比对左右侧的值，我们选择将右侧预先计算出来的值存入一个哈希表中，让（键为，对应值为）。接着就是选择值，计算并比对了。 关于哈希表冲突，我们希望找到的最小值，因而需要尽可能大。每次冲突即代表一个更大的值被发现了。因此无需处理冲突问题。 对于的选择。可以发现有个可能的取值，有个。取时最佳。因此代码就可以写出来了。 123456789101112131415161718ll bsgs(ll a, ll b, ll m) { unordered_map&lt;ll, ll&gt; hash; ll bs = 1; int t = sqrt(m) + 1; for (int B = 1; B &lt;= t; B++) { bs *= a; bs %= m; hash[b * bs % m] = B; } ll gs = bs; for (int A = 1; A &lt;= t; A++) { auto iter = hash.find(gs); if (iter != hash.end()) return A * t - it-&gt;second; gs *= bs; gs %= m; } return -1;} 时间复杂度： 扩展BSGS（和不互质）： 例题： P1082 [NOIP2012 提高组] 同余方程 (exgcd) P5656 [模板] 二元一次不定方程 (exgcd) P1495 [模板] 中国剩余定理（CRT）/ 曹冲养猪 P1516 青蛙的约会 （CRT+exgcd） P3846 [TJOI2007] 可爱的质数/ [模板] BSGS P2485 [SDOI2011] 计算器 （欧拉降幂+乘法逆元+BSGS） P3306 [SDOI2013] 随机数生成器 （等比数列推导+BSGS） P4195 [模板] 扩展 BSGS/exBSGS Part6. 乘法逆元 乘法逆元定义如下（注意和矩阵求逆不是一个东西）： 若，且与互质，则是在模条件下的乘法逆元，记作 简单来说乘法逆元就是模意义下的的倒数。 费马小定理求逆元：大部分题目会给出一个质数模数，因而互质是可以保证的。此时我们的乘法逆元就是使式子成立的值，考虑到模数为质数，可以带回开头所说的费马小定理中。 得到，由于与互质，消去得：，所以乘法逆元为。 123int inv(int a, int p) { return qpow(a, p - 2, p);} 扩展欧几里得求逆元：这是万能的方法，对任意模数均成立。它不像上面费马小定理那样限制模数必须是质数，因而只要时间充裕，都建议使用这种求逆元的方式。 因为，运用同余-等式互转可以得到。符合exgcd的形式。 12345678910111213141516int exgcd(int a, int b, int &amp;x, int &amp;y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;}int inv(int a, int m) { int x, y; exgcd(a, m, x, y); return (x + m) % m;} 递推求逆元： 例题： P3811 [模板] 模意义下的乘法逆元 （递推求逆元） 来张弔图 Part7. 矩阵相关 矩阵，是一个按照长方排列的实数或复数集合。它最早用来表示方程组中的系数和常数，简单理解就是它将元一次方程组中的系数，按照未知数的顺序依次挑出它们的系数组合为矩阵的某一行。元一次方程的矩阵有列，而行数则取决于方程组中方程的个数。 Div1. 初等行变换 考虑这个方程组： 按照如上所述，将它转换为系数矩阵（只有的系数）就是： 你也可以写成增广矩阵（与系数矩阵相比多了一列常数，即等号右边的常数，这里用竖线隔开）的形式： 不难看出第一列代表了的系数，第二列和第三列是和的系数。那么如果需要求解这个矩阵（得到方程组的解），我们应该通过初等行变换将它变成方便我们求解的模式。初等行变换内容如下（最好用方程组消元的思想简化理解）： 交换某两行 把矩阵的某一行同乘以一个非零的数 把某行的若干倍加和到另一行 假设我们有一个元线性方程组，如何设计算法使计算机能够快速求出它的解呢。我们需要引入三角矩阵的概念： 顾名思义，系数排列看起来像一个三角形的矩阵，叫做三角矩阵。分为上三角矩阵和下三角矩阵。前者的非零系数均分布在对角线的右上方、后者都在左下方，例如矩阵：就是一个上三角矩阵（这里是增广矩阵）。通常用字母表示，求解线性方程组时经常化为这种形式方便求解：本例中当最后一个未知数（见最后一行）已知时，可以通过向上代入求解每一行中待求的未知数值。 那么如何将一个一般矩阵转换为上三角矩阵呢？答案是前面介绍过的初等行变换！步骤如下： 枚举每一列，选出无序组中第列系数绝对值最大的一行，并移到无序组的最上边。 行通过自乘，将第列的系数变成，并标记为有序。 通过加减有序组中某一行的非零倍，将之后所有行的第列系数化为。 文字还是太抽象，我们来举个例子： 令矩阵（有序组用绿色表示） 枚举第一列，。开始时，所有行均无序。选出绝对值最大的那一项，本例中为第二行，进行移动，原矩阵变为： 第二步，自乘并标记有序，因此第一行除以，原矩阵就变成了： 第三步，将无序组的第列消成。本例中，我们让第二行减去二倍第一行；第三行直接减去第一行，得到： 枚举第二列，此时。第一步，选出第二列系数绝对值最大的那一行，移到无序组最上端。本例中无需移动，自乘，标记有序，原矩阵为： 最终的最终，第三行减倍第二行，得到我们心心念念的上三角矩阵： 我们假设从左到右，分别为、、的系数，竖线右侧为常数。矩阵可以改写成方程组的形式： 根据最后一行，显然。将代入2式，解得，以此类推，由下向上代入解出的值即可，本例的唯一解是：。 然而心细的你估计发现了疏漏之处：“求一元二次方程时都要先检验根是否存在（判别式法）再来作答，你这里怎么没有讨论根的分布情况呢？” 事实上，矩阵的解的分布确实不止一种情况，这里是矩阵有唯一解的情况。类比高中立体几何求平面法向量的情景，我们通常都要令某个坐标为或者是其他方便于计算的值，这里就是矩阵有无数组解的经典例子。要想系统分析矩阵方程解的数量情况，我们需要引入秩的概念。 Div2. 秩 在上一节中我们通过初等行变换求出了矩阵的解，然而并不是所有矩阵都能轻而易举求出唯一解，因为它可能无解、也有可能无唯一解（默认最高次数为一）。类比一元二次方程中的判别式法，矩阵是否也有判断根存在性的方法？ 答案是：有滴！在矩阵运算中，我们使用秩来描述矩阵的一些关于解的个数的关系。秩被定义为：将矩阵通过初等行变换后形成的梯形矩阵中非零行的个数。试看如下例子： 定义一个的矩阵： 经过初等行变换后出现了这样的情况： (第二行减去乘3的第一行，第一行乘2减去第三行) 第二行变成了纯的一行，一、三行说什么都无法消成一个未知数的形式。如果写成方程组就是： 它有无数组解，原因是：矩阵的秩与矩阵增广矩阵的秩相等且小于了它的阶。简单来说就是你用两个方程去求三个未知数的值（初一内容），当然是有无数多组解。 规定对于矩阵，它的秩用表示（、、均可）。因此令方程组的阶增广矩阵秩为，系数矩阵的秩为。矩阵有无数组解的条件就是（严格来说：有无数组解的充要条件是） 看第二个例子： 定义增广矩阵：；它的系数矩阵：。 增广矩阵变换后：；系数矩阵： 根据定义，得到，，此时。方程组无解。因而矩阵无解的充要条件是。简单理解起来就是方程组中的两个方程起了冲突，矩阵被省去的其中一步变换是：，第一行和第三行相当于要你求解如下的方程组：。显然矛盾，因此矩阵无解。 加上第一节里面的结论，我们总结出了矩阵解分布的三种情况（方程组的增广矩阵为、系数矩阵为，阶为）： 当时，矩阵有唯一解 当时，矩阵有无数解 当时，矩阵无解 因此就有了一套组合算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define N 110#define NO_SOLUTION -1#define INFINITE 0#define SOLVE_OK 1using namespace std;typedef long long ll;double mat[N][N];int n;double eps = 1e-6; int solve() { int rank = 0; for (int c = 0, r = 0; c &lt; n; c++) { int t = r; for (int i = r; i &lt; n; i++) { if (fabs(mat[i][c]) &gt; fabs(mat[t][c])) t = i; } if (fabs(mat[t][c]) &lt; eps) continue; for (int i = c; i &lt;= n; i++) swap(mat[r][i], mat[t][i]); for (int i = n; i &gt;= c; i--) mat[r][i] /= mat[r][c]; for (int i = r + 1; i &lt; n; i++) { if (fabs(mat[i][c]) &gt; eps) { for (int j = n; j &gt;= c; j--) { mat[i][j] -= (mat[r][j] * mat[i][c]); } } } r++; rank = r; } if (rank &lt; n) { for (int i = rank; i &lt; n; i++) { for (int j = 0; j &lt; n + 1; j++) { if (fabs(mat[i][j]) &gt; eps) return NO_SOLUTION; } } return INFINITE; } for (int i = n - 1; i &gt;= 0; i--) { for (int j = i + 1; j &lt; n; j++) { mat[i][n] -= mat[i][j] * mat[j][n]; } } return SOLVE_OK;} int main() { cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n + 1; j++) cin&gt;&gt;mat[i][j]; } int res = solve(); if (res != SOLVE_OK) cout&lt;&lt;res&lt;&lt;endl; else for (int i = 0; i &lt; n; i++) { if (fabs(mat[i][n]) &lt; eps) mat[i][n] = fabs(mat[i][n]); printf(\"x%d=%.2lf\\n\", i + 1, mat[i][n]); } return 0;} 时间复杂度： 以后上大学解高次线性方程就可以用这段程序秒了。 Div3. 矩阵基本运算 1. 加法： 注意类比元一次方程组的加减消元，两个矩阵相加意味着同一位置的元素相加。需要注意：只有同型的矩阵才有加法运算（同型即行数列数相等）。 可以知道，四则运算的加法交换律和结合律仍然适用于矩阵加法。 2. 减法： 加法的逆运算，让矩阵同一位置的元素相减即可。也是仅限于同型矩阵之间才可做减法。 3. 数乘： 即矩阵中每个元素都跟数字相乘。符合乘法交换律和结合律 矩阵的加法、减法和数乘合称为矩阵的线性运算 4. 转置： 矩阵的转置矩阵用表示。 直观来讲就是将原矩阵旋转一下（行和列互换）。满足如下性质： (转置一次后再转置一次还是原来的矩阵) （常数转置后就是它本身） （上一条是它的特殊形式，类比两数乘积的幂） 5. 共轭： 矩阵的共轭矩阵用表示。 类比共轭复数的定义：实部不变、虚部取相反数。矩阵共轭变换就是将矩阵中的所有复数变为其共轭形式。 6. 共轭转置： 矩阵的共轭转置矩阵记作、、或。 字面意思，先取共轭，再转置。它具备转置矩阵的三条性质。 Div4. 矩阵乘法 只有一个矩阵的行数和另一个矩阵的列数相等时才可进行乘法运算。 例如一个矩阵和一个矩阵。记它们的乘积。则中的某个元素。并且是一个的矩阵。 因此 它满足结合律、分配律，但是大多数情况下不满足交换律。交换律不成立可以看到下面这个例子： 首先根据定义，矩阵的行列数取决于做乘法的两个矩阵和的行列数，比如矩阵和矩阵相乘，得到一个矩阵，但是将它颠倒顺序，让一个矩阵与矩阵相乘，结果将是一个矩阵，和前者行列数相反。 对于结果是正方形矩阵的，可以自己随便设置两个矩阵进行计算。但是部分矩阵仍然可以进行交换律运算：矩阵乘一个单位矩阵/数量矩阵[/]、矩阵乘它的伴随矩阵（）。 Div5. 其他常用类型的矩阵 1. 零矩阵：顾名思义，由组成的矩阵称作零矩阵。零矩阵不可逆，且任何符合条件的矩阵与一个零矩阵的积均为零矩阵。 2. 单位矩阵：形如的矩阵被称作单位矩阵，通常用字母或表示。单位矩阵指仅对角线系数为、且其他系数为的矩阵。阶矩阵与它的逆矩阵相乘得到的结果就是一个阶单位矩阵，即。 3. 数量矩阵：形如的矩阵叫数量矩阵，可以看作实数与单位矩阵进行数乘运算后的结果，通常表示成。矩阵与一个数量矩阵的乘积满足乘法交换律。 4. 逆矩阵：如果存在一个矩阵和单位矩阵，使得，则称矩阵可逆，是的逆矩阵，也可记作。单位矩阵的逆矩阵是它本身；零矩阵不可逆。阶矩阵可逆的充要条件是。 5. 对称矩阵：转置矩阵与自身相等的矩阵叫做对称矩阵，特征是所有元素关于对角线对称，例如：。对称矩阵必为方形矩阵，反之不一定成立，对于一个方形矩阵，必定是对称矩阵。 Div6. 矩阵的几何表示 平面直角坐标系上，一个向量可以被表示成的形式，即。 计算机中，用两个不共线向量和能够表示整个平面直角坐标系。运用一点高中数学的空间几何知识，这里的和被称作基底（当然，如果需要描述三维空间坐标系，则需要三个不共线的基底向量）。于是我们使用矩阵来描述这个平面直角坐标系就是非常简洁明了且优雅的了。 假设我们常规想法中的平面直角坐标系是，经过一轮线性变换后得到的新坐标系是：。用一张图看一下变换后的坐标系： 如果在最开始的坐标系中有一个向量，我们如何在新的坐标系中表示它呢？再根据我们高中数学所学，只需要算出的值即可。因为是轴的基底，相当于上的一个单位，我们求新向量时只需求出在新的参考系中的新值和值，因而直接用方向的系数乘以一个单位即可，在这里就是，得到。 抽象之后变成： 例题： P3389 [模板] 高斯消元法 （上三角矩阵的转换） P2455 [SDOI2006] 线性方程组 （前一道题的升级版） Part8. 组合计数 StarterDiv1. 阶乘概述 阶乘，数学中用表示，表示的值，即 特殊地，。 StarterDiv2. 常用排列总结 1. 排列数：数学中用表示（，老教材记作，）。表示从个数中选择个进行排列，公式为： 为啥呢？，有弔图为证↓ 2. 组合数：假设有个物品，从中任选出个排成一组，叫做组合；所有可能的选法总数叫做组合数。用表示，计算公式为：。简记为：乌鸦坐飞机 弔图×2↓ GZ表示就凭这几张图他能速通整个组合数的内容 StarterDiv3. 二项式定理 学过初中的大家都知道：，这是完全平方和公式。高中的一些牛逼娃还知道完全立方和公式，也就是：。这些式子其实都是可以由二项式定理套出来的。 二项式定理定义式如下： 这里出现的。是不是突然发现它和组合数公式的共同之处喽？但是这一章并不会用它，只是作补充知识的说…… 有这三条就够了，接下来进入组合计数的内容。 Div1. 高考娃狂喜——组合数计算 一个小栗子： 宇宙榜一大学阿福大学的榜一博士后导师黑虎阿福给你出了一道难题： 给你两个正整数和（），让你求出的值。 你：“这还不简单？” 阿福： “好的，我这里将设为，设为，请你求解。” 你： “WTF？” 于是你决定用程序来代替人脑，阿福教授也做出了一定让步，让你求出的值。但是不幸的是，人类的计算机科学水平自从2024之后就被来自几光年外的八体星人文明发出的“侄子一号（NEPHEW 1）”探测僚机锁定了，因此你需要设计一个高效的计算方式，而不是妄想着用2077年的赛博机器运行暴力计算，来解决这个问题。 一旦你的运行时间超过一秒，阿福教授就会使用战技“乌鸦坐飞机”对你造成大量阶乘伤害。已经学习了阶乘的你想必已了解了它的威力，所以还是老老实实推导公式吧！ 递推版： 组合数递推公式：。 分析思路类似于动态规划问题：我们要从个物品中挑选个出来，求组合数。 上图中，若包含这个红色物体，那么我们只需再从剩下的个物体里挑选，因为红色物体自身占据了个位置中的其中一个，因此留给其他物体的总名额就只有个，因此该情况下组合数：；同样地，若不包含红色物体，从剩下的个物体中选出个，因为在该情况下红色的物体不计入组合，因此剩余名额还是个，组合数就是。最后，因为从个物体里选，只有包含红色和不包含红色两种情况（就好像你的双亲，不是你的母亲就是你的父亲），因此可以做到不重不漏。所以总组合数就是。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define N 2010using namespace std;int c[N][N];void Csieve(int p) { for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt;= i; j++) { if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % p; } }}int main() { int a, b, p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; Csieve(p); cout&lt;&lt;c[a][b]&lt;&lt;endl; return 0;} 时间复杂度： 适用于的大部分情况。 预处理版： 但是众所周知，递归有两大痛点：对于主观思维来说，是边界问题；对于客观条件来说，是内存。递归过程中CPU里储存了大量的未运行或者待返回的函数实例，当和的值增大时，尽管它能在时间方面表现出色，但是内存就不那么理想了，反而会显得臃肿至极。当题目中给出时，建议用这种方法。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;typedef long long ll;int fact[N], infact[N];int qpow(int a, int b, int p) { int res = 1; while (b) { if (b &amp; 1) res = (ll) res * a % p; a = (ll) a * a % p; b &gt;&gt;= 1; } return res;}int inv(int a, int p) { return qpow(a, p - 2, p);}int C(int a, int b, int p) { return ((fact[a] % p) * (infact[b] % p)) % p * infact[a - b] % p;}int main() { int a, b, p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; fact[0] = infact[0] = 1; for (int i = 1; i &lt;= N; i++) { fact[i] = (ll) fact[i - 1] * i % p; infact[i] = (ll) infact[i - 1] * inv(i, p) % p; } cout&lt;&lt;C(a, b, p)&lt;&lt;endl; return 0;} 时间复杂度： 适用范围，且均在int范围内的大部分情况。 Lucas定理优化版： 定理如下：（为质数）。证明在此（建议直接背结论）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef long long ll;int p;int qpow(int a, int b) { int res = 1; while (b) { if (b &amp; 1) res = (ll) res * a % p; a = (ll) a * a % p; b &gt;&gt;= 1; } return res;}int inv(int a) { return qpow(a, p - 2);}int C(int a, int b) { int res = 1; for (int i = 1, j = a; i &lt;= b; i++, j--) { res = (ll) res * j % p; res = (ll) res * inv(i) % p; } return res;}ll lucas(int a, int b) { if (a &lt; p &amp;&amp; b &lt; p) return C(a, b); return (ll) C(a % p, b % p) * lucas(a / p, b / p) % p;}int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; int n, m; cin&gt;&gt;t; while (t--) { cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; cout&lt;&lt;lucas(n + m, n)&lt;&lt;endl; } return 0;} 时间复杂度： 其本质是套用定理计算，因为是模意义下的除法，因而我们使用逆元来操作除法。 适用范围，在long long范围内的大部分情况。 高精度版（选修）： 什么？你厌倦了组合数后面挂着的模？不妨试试高精度版的组合数计算吧！它适用于作业上的题目求解！（虽然前面几种也可以，毕竟手算的题数据很小取不取模都一样）是不是心动了呢？ 常规思路来说，我们的组合数公式经过一轮分式化简可以得到：。因此我们可以实现高精度的乘除法来计算这个炒鸡长的算式，但是这样不仅效率低下，手写和调试的难度也会增加。我们急切地想知道如何简化成一种高精度算法。 我们看到了Part1里面讲的算术基本定理，将组合数转化为的质数乘积分解式，最后我们只需要解决质数头顶的指数即可。我们使用以下这个公式： 。 用它可以计算出中的个数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;typedef long long ll;vector&lt;int&gt; num;ll primes[N], sum[N];bool st[N];int cnt = 0;void prime_sieve(int n) { for (int i = 2; i &lt;= n; i++) { if (!st[i]) primes[++cnt] = i; for (int j = 1; i * primes[j] &lt;= n; j++) { st[i * primes[j]] = true; if (i % primes[j] == 0) break; } }}int get(int a, int p) { int res = 0; while (a) { res += a / p; a /= p; } return res;}vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) { vector&lt;int&gt; res; int t = 0; for (int i = 0; i &lt; a.size(); i++) { t += a[i] * b; res.push_back(t % 10); t /= 10; } while (t) { res.push_back(t % 10); t /= 10; } return res;}int main() { int a, b; cin&gt;&gt;a&gt;&gt;b; prime_sieve(a); for (int i = 1; i &lt;= cnt; i++) sum[i] = get(a, primes[i]) - get(b, primes[i]) - get(a - b, primes[i]); vector&lt;int&gt; res; res.push_back(1); for (int i = 1; i &lt;= cnt; i++) { for (int j = 1; j &lt;= sum[i]; j++) { res = mul(res, primes[i]); } } for (int i = res.size() - 1; i &gt;= 0; i--) cout&lt;&lt;res[i]; cout&lt;&lt;endl; return 0;} 时间复杂度： 适用范围，在int范围内。 有了这段代码，我们就可以完成开头阿福教授的原问题了（不模不限数据）！ Div2. 世界上最OI的IDE——Catalan数 当你翻开Catalan数的介绍文章，并大学特学了一番，感觉自己完全掌握了这神奇的数列，正当你兴致勃勃地打开题库搜索到一道Catalan数的题目正准备大展身手时，你会发现，面对这神奇的题干，不同于往常秒模板题的你，你甚至完全看不出来它和Catalan数有任何的关系，而且很有可能，你其实连Catalan数究竟是什么东西都不知道！ 苏子愀然，正襟危坐而问客曰：“何为其然也？” 其实还真不能让那些博客背上黑锅，这种现象与Catalan数本身的应用有很大的关系。 Catalan数，或者习惯叫卡特兰数、明安图数，是组合数学中常用的特殊数列。数列如下：“”，它是一个无穷数列，数与数之间看起来似乎也没什么太大联系……其实它和斐波那契数列有类似之处，它们不具有特定的数学意义（只是斐波那契的递推方法简单得多罢了），只是一个十分普遍的数学规律。所以学习时应该挂靠于例子本身而不是一味依赖于定义所写，那我们就开始吧： 用最经典的例子写出来就是： 给你一个的网格，你将从原点开始移动。对于每次移动，你只能向上/向右一格（坐标/坐标加一），但是需要保证你总向右走的次数不少于向上走的次数，问从原点到有多少种不同的合法路径？ 假设你某时刻走到了点，根据题目要求，意味着需要保证。我们拟合一条经过点的正比例函数，不难看出它的斜率。对于这个的网格，所有的点都在整数刻度上。我们接着画出直线的图像，然后尽可能画几条不合法的路径出来比对一下，你会发现：不合法的路径与直线至少有一个交点，合法路径一定与没有交点。用一张图来直观体会一下： 终点，其中红线为不合法路径，蓝线为合法路径。不难发现，不合法的路径与绿线（）都有至少一个交点，因为它们在某次移动后的端点与原点拟合而成的正比例函数的斜率，因此不是合法路径。 那么如何来计算合法和不合法路径的条数呢？直接求出合法路径不好求，规律不好找，因此我们计算出总路径数量，减去不合法数量即是合法路径数量。 可以看到，无论选择什么样的路径，在不左移、不下移的前提下，到达，你都只能移动次（小学内容，把横线和竖线平移到一块数格子），其中右移次、上移次。转化一下，就是在次移动中选出次进行右移操作，总数就是。 因为所有路径，包括合法的和不合法的路径都最终抵达了，难以将内鬼剔除出来。我们选择将不合法路径关于判定线对称过去，它们的新终点将是，也就是。根据上面的推导方法，这里就是在轮移动中挑出次右移操作，于是不合法路径的数量就是：，合法路径数量是：。 （至于为什么用右移次数而不是上移次数，是因为上移受到限制，这意味着你可以一直右移到而无需担心条件限制；但是你就不能先一直上移到，因为这不符合题目要求） 扩展：如果题干中指明向右走的次数不少于向上走的次数，则只需将判定线上下平移为即可。 那这些又和宇宙第一IDE有什么关系呢 应用场景一：括号匹配 将向右走转化为左括号“（”，向上走转化为右括号“）”。对于每一次输入，检查一下左括号输入次数是否永不小于右括号输入次数。若是，当输入最后一个右括号，使左右括号数量相同时，即为匹配成功；若不是，且左括号个数大于右括号个数，则表明括号等待补全；若不是，且左括号个数小于右括号个数，即立即宣布失配。 应用场景二：合法进出栈序列计数问题 假设一个初始为空的栈，有次操作，次进栈，次出栈，请问合法进出栈序列总数（空栈不出）是多少？ 答案就是Catalan数，自行套公式计算。 应用场景三：圆的不相交弦计数问题 假设一个圆周上分布着偶数个点，对这些点两两连线，使相连的线不相交的所有方案数。其中一个合法解如下图： 聪明如你，答案还是Catalan数！那么如何转化为已知问题求解呢？ 我们将出发点标记为左括号“（”，从出发点引出去的线与其他线/点的所有交点标记为右括号“）”。当所有点两两连接完毕时，根据场景一的模型，一旦左右括号失配即代表不合法，否则合法。因此这个问题也就变成了：给定个左括号和右括号，求出使左右括号匹配的排列个数。在这里，如果问题无解，将会是这样： 例题： P3807 [模板] 卢卡斯定理/Lucas 定理 P5014 水の三角(修改版) （Catalan数公式变形推导）","categories":[{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.cn/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.cn/tags/OI/"}]},{"title":"一命已出，前来还愿","slug":"thanks","date":"2023-11-12T01:42:41.000Z","updated":"2025-02-02T11:02:21.017Z","comments":true,"path":"articles/34393/","link":"","permalink":"https://justpureh2o.cn/articles/34393/","excerpt":"","text":"2023.11.11 21:10","categories":[],"tags":[{"name":"原神","slug":"原神","permalink":"https://justpureh2o.cn/tags/%E5%8E%9F%E7%A5%9E/"}]},{"title":"Latex常用符号大全","slug":"latex-symbols","date":"2023-11-11T17:23:35.000Z","updated":"2024-06-09T07:04:13.954Z","comments":true,"path":"articles/65533/","link":"","permalink":"https://justpureh2o.cn/articles/65533/","excerpt":"","text":"更新记录： 添加了常用的数学符号，简单的矩阵写法 添加了由 Lucas2011 提供的巨大更新，包含“导言区”、“段落层次”、“矩阵、行列式”以及大部分的宏包使用章节 添加了 mhchem 和 chemfig 宏包的使用细节 导言区 页边距&amp;行距 “窄”：\\geometry{left=1.27cm, right=1.27cm, top=1.27cm, bottom=1.27cm} “宽”：\\geometry{left=3.18cm, right=3.18cm, top=2.54cm, bottom=2.54cm} 很合适的行距：\\linespread{1.5} 标题&amp;作者&amp;时间 \\title{-IamTitle-\\vspace{-2em}} 注：\\vspace{-2em} 是用来缩小标题与正文之间的行距 不想显示作者和时间的话可以留空： 123\\author{}\\date{} 其中时间可以用 \\today 来表示今天，会在编译时自动填充 注意：请一定要在正文区使用 \\maketitle 文章样式 用 \\pagestyle{plain} 就好 特殊转义 空格：~（波浪号） 宽分隔符：\\qquad 段落层次 大标题&amp;小标题 大标题：\\section{TITLE} 居中、微软雅黑 小标题：\\subsection{TITLE} 左对齐、微软雅黑 注：若想去除编号，可以在环境名称后面加 *，如：\\subsection*{&lt;人物事迹&gt;} 定理环境 etc. 目前还没用到，所以先空着 加粗&amp;下划线&amp;斜体(Italic) 加粗 在文本环境中使用：\\textbf{} 在公式环境中使用：\\bm{}（见 后文 介绍\\usepackage{bm}宏包） 斜体 在文本环境中使用：\\textil{} 公式环境本来就是斜体…… 下划线 在文本环境中使用：\\underline{} 常用命令总结 自带基础命令 乘号（叉乘）: \\times 乘号（数量积/点乘）： \\cdot 除号： \\div 开方/N次方根： \\sqrt[N]{ABC} 乘方/N次幂： A^N 下标： A_N 约等号： \\approx 加粗约等于：\\thickapprox 不等号： \\neq 恒等号/定义为： \\equiv 大于号： \\gt 小于号： \\lt 大于等于： \\geq 小于等于： \\leq 远大于： \\gg 远小于： \\ll 正负： \\pm 负正： \\mp 垂直： \\perp 平行： \\parallel 角/无标记角： \\angle 角/标记角： \\measuredangle 一般全等： \\cong 相似： \\sim 加粗相似： \\thicksim 三角形： \\triangle 正方形： \\square 圆： \\odot 向量：\\overrightarrow{AB} 属于： \\in 不属于： \\notin 子集： \\subseteqq 真子集： \\subsetneqq 真子集/直线在平面上： \\subset 并集： \\cup 交集： \\cap 补集： \\complement{_U^A} 因为： \\because 所以： \\therefore 存在： \\exists 不存在： \\nexists 任意/对于所有： \\forall 空集： \\varnothing 逻辑或： \\cup 或 \\lor 逻辑与： \\cap 或 \\land 逻辑非： \\lnot 充分条件/右双箭头： \\Rightarrow 大小写敏感 必要条件/左双箭头： \\Leftarrow 大小写敏感 充要条件/双向双箭头： \\Leftrightarrow 大小写敏感 成正比： \\propto 定积分： \\int_{a}^{b} 多重积分： \\iint_{a}^{b} 及 \\iiint_{a}^{b} 导函数/上撇号： \\prime 求和： \\sum_{i=1}^{n} 求积： \\prod_{i=1}^{n} 字母数位/平均数： \\overline{ABCD} 整除符号： \\mid 新定义运算符： \\oplus 及 \\otimes 及 \\ominus 扰动值： \\tilde{K} 上箭头：\\uparrow 下箭头：\\downarrow 无穷大/无限： \\infty 圆周率： \\pi 普朗克常数： \\hbar phi：\\phi 或 \\varphi 分数、矩阵、行列式 分数：\\frac{1}{2}=0.5 小型分数：\\tfrac{1}{2} = 0.5 大型分数：\\dfrac{k}{k-1} = 0.5 大小型分数嵌套： \\dfrac{ \\tfrac{1}{2}[1-(\\tfrac{1}{2})^n] }{ 1-\\tfrac{1}{2} } = s_n 连续分数： \\cfrac{2}{ c + \\cfrac{2}{ d + \\cfrac{1}{2} } } = a \\qquad \\dfrac{2}{ c + \\dfrac{2}{ d + \\dfrac{1}{2} } } = a 二项式分数：\\binom{n}{k} 小型二项式系数：\\tbinom{n}{k} 大型二项式系数：\\dbinom{n}{k} 矩阵（matrix、vmatrix、Vmatrix、bmatrix、Bmatrix、smallmatrix、pmatrix 环境）: 123456789101112131415161718192021222324252627282930313233\\begin{matrix}x &amp; y \\\\z &amp; v\\end{matrix}\\qquad \\begin{vmatrix}x &amp; y \\\\z &amp; v\\end{vmatrix}\\qquad\\begin{Vmatrix}x &amp; y \\\\z &amp; v\\end{Vmatrix}\\qquad\\begin{bmatrix}0 &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; 0\\end{bmatrix}\\begin{Bmatrix}x &amp; y \\\\z &amp; v\\end{Bmatrix}\\qquad\\begin{pmatrix}x &amp; y \\\\z &amp; v\\end{pmatrix}\\qquad\\bigl( \\begin{smallmatrix}a&amp;b\\\\c&amp;d\\end{smallmatrix} \\bigr) 数组（Array 环境）: 12345678\\begin{array}{|c||c|||c||||}a &amp; b &amp; S \\\\\\hline0&amp;0&amp;1\\\\0&amp;1&amp;1\\\\1&amp;0&amp;1\\\\1&amp;1&amp;0\\end{array} 方程组（Cases 环境）: 12345\\begin{cases}3x + 5y + z &amp;= 1 \\\\7x - 2y + 4z &amp;= 2 \\\\-6x + 3y + 2z &amp;= 3\\end{cases} 多行公式（Align 环境）: 1234\\begin{align}f(x) &amp; = (a+b)^2 \\\\&amp; = a^2+2ab+b^2\\end{align} 从指定编号开始方程组（Alignat 环境） 1234\\begin{alignat}{2}f(x) &amp; = (a-b)^2 \\\\&amp; = a^2-2ab+b^2\\end{alignat} 注：若想去掉公式编号，使用 align* 环境 多行公式（左对齐）: 1234\\begin{array}{lcl}z &amp; = &amp; a \\\\f(x,y,z) &amp; = &amp; x + y + z\\end{array} 多行公式（右对齐）: 1234\\begin{array}{lcr}z &amp; = &amp; a \\\\f(x,y,z) &amp; = &amp; x + y + z\\end{array} extarrows 宏包 等号上有条件：\\xlongequal{xyz} : 等号下有条件：\\xlongequal[sub]{} cancel 宏包 大大的叉：\\xcancel{\\frac{abc}{def}} : 注：此命令只能在数学模式中使用（即用$$包裹时） xcolor 宏包 变色：\\textcolor{green}{abcdef} : 半色调：\\textcolor{&lt;颜色&gt;!&lt;百分数&gt;} 混合色：\\textcolor{&lt;颜色&gt;!&lt;百分数&gt;!&lt;颜色&gt;} bm 宏包 公式中加粗：\\bm{abc} mhchem, chemfig 宏包 mhchem 宏包主要用来书写较为简单常见的化学方程式，化学方程式主体必须用 \\ce{} 包裹。并且在该环境下上下标规则与普通的 语法略有不同。 化学式&amp;物态 化学式（水）： \\ce{H2O} 化学式（明矾）： \\ce{KAl(SO4)3\\cdot12H2O} 离子（铁离子）： \\ce{Fe^{3+}} 元素化合价（阿拉伯数字）： \\ce{\\overset{+3}{Fe}_2O3} 元素化合价（罗马字母）： \\ce{Cr^{VI}} 核素（铀-235）： \\ce{^235_98U} 沉淀（硫酸钡）： \\ce{BaSO4 v} 气体（氧气）： \\ce{O2 ^} 在 mhchem 中，括号和字母后边的连续多位数字默认为下标形式、加减号默认为上标形式，若想使用正常显示的数字，需要加入空格，例如： 对应 H2O+； 对应 \\ce{H2O +} （注意空格）。特殊情况可以使用一般 LaTeX 中的上下标格式强制转换，例如 对应 \\ce{Fe3+}； 对应 \\ce{Fe^{3+}}。 为压缩文章体积，后文所有的 LaTeX 代码均会省略 \\ce{}。 化学方程式 mhchem 提供了常见的箭头符号，例如： 对应 &lt;=&gt;，即可逆符号。在箭头上添加上下标条件，一般是在箭头后方紧跟一个 T[上标][下标]，例如：催化剂高温 对应 &lt;=&gt;T[催化剂][高温]。除开可逆符号外，还有单向箭头、长等号（属于 extarrows 宏包内容）等……具体见下。 简单的方程式（湿法炼铜）： Fe +CuSO4=FeSO4 +Cu 有机化学方程式（乙烯与溴的加成反应）： C2H4 +Br2-&gt;CH2BrCH2Br 带条件的有机方程式（制备乙酸乙酯）：浓硫酸 CH3COOH +CH3CH2OH-&gt;T[浓硫酸][\\triangle] CH3COOCH2CH3 +H2O 带条件的无机方程式（氨气催化氧化）： 4NH3 +5O2\\xlongequal[\\triangle]{Pt} 4NO +6H2O 可逆反应（氯气部分溶于水）： CL2 +H2O&lt;=&gt;HClO +HCl 可逆反应带条件（制氨气）：催化剂高温高压 N2 + 3H2 &lt;=&gt;T[催化剂][高温高压] 2NH3 生成同分异构体的方程式（蔗糖水解）： C12H22O11 +H2O-&gt;\\underset{Glucose}{C6H12O6} +\\underset{Fructose}{C6H12O6} 简单的结构式 mhchem 仅对结构式提供较为简单的支持，若想绘制诸如苯环、异丁烷、卟啉这样的复杂结构。则需要引入后文将要介绍的 chemfig 宏包。mhchem 支持的具体如下： 丙烷： CH3-CH2-CH3 乙烯： CH2=CH2 乙炔： CH#CH 内嵌公式 在 ce 环境中，允许嵌入一层公式，用美元符号包裹。通常在含参方程式中使用。 锂离子二次电池反应式： 充电放电 \\ce{LiCoO2 +C&lt;=&gt;T[充电][放电] Li_{1-$x$}CoO2 +Li_{$x$}C} 环结构&amp;复杂的结构式 mhchem 提供的简单支持无法满足这类绘制的需求，因此我们引入一个新宏包 chemfig。与前文相同，仍然需要用 chemfig 标签将你想要绘制的化学式包裹起来，为了压缩文章（编辑器已经开始卡了），后文所有的 chemfig 代码均会省略 \\chemfig{}。 苯环：","categories":[],"tags":[{"name":"latex","slug":"latex","permalink":"https://justpureh2o.cn/tags/latex/"}]},{"title":"《原神》枫丹语言考究","slug":"fontainish-research","date":"2023-11-05T02:59:02.000Z","updated":"2025-02-02T11:02:21.013Z","comments":true,"path":"articles/44495/","link":"","permalink":"https://justpureh2o.cn/articles/44495/","excerpt":"","text":"起因 这天月假，当我正为即将到来的水神池子疯狂做任务屯原石时，在列表里看到了一个悬赏整整30原石的世界任务。本着不放过任何一个给原石的任务的宗旨，我来到了秋分山西侧，白淞镇东北方向的海边房屋处。只见一位男子全身掩埋在海沙之下、动弹不得，面前摆放着一只散发香味的甜甜花酿鸡。我看他精神失常，满嘴都是“新型美容方式”的胡话又哭又闹，呜呜呜呜，好可怜呀。于是我决定帮他一把……找出了幕后黑手，此时他举起一个木牌，只见上面用老米祖传的架空文字写了一些东西，随着剧情推进，我们得知这是“抗议”（protest）。枫丹作为两个月前才开放的新国家，其文学文化充满乐子的xxs神明固然吸引了我。于是我决定用手头上有限的图片资料，整理出一份类似于枫丹语言图鉴的资料来。以便后期深入探究枫丹的风土人情。 初探 这是在上一部分中提到的，写有“抗议”（protest）的木牌，其中各个字母的对应关系已经标注出来了（相信不用标注也看得出来）。不难发现，最后一个字母与倒数第四个字母是相同的，恰巧对应上protest中字母t的位置。某种方面上证明了这一猜测的正确性，但是鉴于这抽象到与原英文字母完全不搭边的枫丹字体（很水体）实在是太过亮眼，我的内心还是有一点怀疑和否定的。那么我们将这七个字母挨个抽取出来，放到别的语境中去转译，不就可以验证它的准确性了吗？ 其实也无需这么麻烦，读完前面的大佬对提瓦特通用语的解析。我们惊奇地发现，这很水体居然与提瓦特通用语的字母如出一辙： 图片来源于：哔哩哔哩，语颂源，【原神考据】提瓦特通用文 当然也有一些变化，比如哪里可能突然多出来一横、又或者是将圆弧形的笔画变得棱角分明。图中的S和E就是两个典型例子。考虑到可能是手写体带来的美化、钝化等，我接下来去到了枫丹的主城区中，分别在蒸汽鸟报社、卡郎代沙龙前拍下了这几张图片（因为他们离锚点非常的近，不需要跑图）。 蒸气鸟报社——板报 蒸气鸟报社——招牌 卡郎代沙龙——招牌 我们根据已经解译出来的提瓦特通用语字母进行对拍，发现蒸汽鸟报社的招牌上写着：LOISEAU DE VAPEUR。明显是法语，但是其中的VAPEUR和英语的VAPOR（蒸气）非常相似，因此对拍基本无误。但是由于我本人不懂法语，解释不了第一个词，只能求助于度娘。度娘也是给我甩了一个解释：鸟。并纠正了一个小错误：LOISEAU应为L'OISEAU。完美契合蒸汽鸟报社的招牌。 同理，卡郎代沙龙的门牌上写着：CARITAT。推测其原型是18世纪的姓氏德·卡里塔，孔多塞侯爵（Nicolas de Caritat）的妻子便是18世纪的一位著名沙龙主人。 最后放出蒸汽鸟报社门前牌子上的翻译： Exploring the manufacture of security machinery 探秘发条机关（守卫机器）的制造流程 Joyous tour through the aquatic workshop 水下工坊快乐一日游游记 Exclusive compilation of the past top duellists 旧时顶级决斗代理人的独家专访合集 Interview with the deboard restaurant artists 采访德波饭店的艺术家们 Iridescene tour and the new trend of music 虹彩巡游之旅，以及新派音乐","categories":[],"tags":[{"name":"原神","slug":"原神","permalink":"https://justpureh2o.cn/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"枫丹","slug":"枫丹","permalink":"https://justpureh2o.cn/tags/%E6%9E%AB%E4%B8%B9/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.cn/tags/%E5%AD%A6%E6%9C%AF/"}]},{"title":"国祯文集","slug":"gz-articles","date":"2023-10-26T01:29:45.000Z","updated":"2024-04-10T03:57:05.089Z","comments":true,"path":"articles/18935/","link":"","permalink":"https://justpureh2o.cn/articles/18935/","excerpt":"","text":"曾茂华到底有多六 ——By 国祯 曾茂华是中国当代著名的科学家和教育家，他以“慈父”、“良师”、“学者”等称号闻名于世。 1：曾茂华的蠢行为 曾茂华的蠢行为: 他在大学期间参加了一个乐队，并担任主唱。然而，不幸的是，由于自己的疏忽，他犯下了一件愚蠢的事情——用刀砍掉了对方的手指头。这件事让他成了学校里的头号人物之一。从那以后，他再也不敢做任何愚蠢的事情了。这是因为他害怕自己会被开除出乐队或者成为众矢之的的对象。如果他继续做出这些错误的举动，那么他会失去自己的乐队成员资格，甚至还会遭到开除。所以，为了避免发生这样的悲剧，他必须要记住：永远不要犯错！ 2：为什么他会做出这种愚蠢的事情? 曾茂华的蠢行为发生在他身上，是因为他自己没有意识到他自己的愚蠢。他不知道怎么做才能让事情变得更好，他只想走捷径，而不是去努力做好事情。这种心态会导致他做出错误的决定，因为他会忽略一些重要的信息，或者选择性地记住某些信息。当我们看到一个人犯了下述三种类型的罪时，我们通常就能预测到这个人会再犯同样的问题：1. 根本不会思考问题2. 一味追求便利3. 盲目模仿别人 3: 该如何面对这个问题? 要想解决问题,首先要认识到自己的行为是愚蠢的。只有当你明白自己做了什么蠢事时,才能够改变你的行为来避免这种错误。其次，不要让别人知道你所犯下的错误。这并不是因为你不想坦白自己所犯错误,而是因为这样会给别人带来困扰。最后,如果你真的想要解决这个问题,可以尝试通过一些有趣的方式来实现它。例如,你可以去找一位专业人士帮助你分析一下这件事情,或者试着去找到一个愿意与你分享观点和建议的人。总之,如果你认为自己的行为很蠢,那么就要大胆地承认出来。只有敢于直面自己的无知,才能真正地改善自己的生活。 曾茂华先生不仅对科学领域做出了巨大贡献，而且为国家培养出一批优秀的人才。这些人中不乏有牛顿这样伟大的人物，也有王选这样杰出的人物。 你们见过格局最小的老师能有多离谱 升入高一给人第一印象还可以，到后面做事越来越离谱。 我们发现这个出生就是个权力控，还是个金钱控，不管做什么事情，先维护自己利益，再维护一下领导，特别好面子。做事只管结果，不管过程多努力，他都看不到。做什么事都是一副领导架子，在真正的领导面前跟狗一样老实。 看到我们就流露出他那个油腻又小丑的笑容，本来他长得还算端庄，给人一种当过兵才有的正气，但天天干些出生事情，举几个例子： 有一次他在教师，听到了同学谈论低俗内容，但说的很隐晦，他听出来了，但他为了维护自己“庄严”的形象，就装作没有听到的样子，要多恶心就有多恶心。 在他的班上根本不可能请假，他说我们班“没有请家，只有停学”，我们班的同学好几个生病了都是在学校硬抗。别的班生病回家老师还要开一下腾讯会议，让没来的学生听一下，这个出生开都不开（我们是竞赛班进度本来拉的就快，却一节课很难补）。 他还不允许迟到，他甚至说出迟到就让”家长到学校写检讨“这种逆天言论。有一次我们班一个女生迟到了，就是偶然的一次，结果他说她天天迟到，不配合教学，还把她骂哭了，后来就说”啊，其实我不是故意骂你的，其实我一点都不想骂人“，这跟他发脾气时的样子比起来，简直可笑。 他还特别看重操行分。别的班都是象征性的弄一下，主要看成绩，他倒好，整天闲的没事天天管操行分，这也要扣分那也要扣分，扣了分的还要请家长。吃饱撑的没事干。本来我们是整个学校的最强班级，一学期下来，直接报废。 他还特别喜欢请家长。除了以上提到的两点，他基本上犯什么错都要请家长，好像请家长是万能的一样，其实就是为了维护自己的形象和欲望，恶意整人的行为。就算这样，他还要学生面前一套，家长领导面前一套，装的贼虚伪。当着学生就口吐芬芳，拳打脚踢。面对家长就装做沉稳，说什么维护学校，一切都是为了学生发展（跟学生犯错没有任何关系的内容，一切都是为了做给家长和领导看，顺带侠义吓一下学生），6，家长请来你TM就说这些。 这一点是我最想说的。有一次外出，我和我的朋友对一个同学说你要站的直一点，像XX一样（就是那个出生，他本来站的就很直），因为这个同学名字里带一个“思”，结果就被那个出生听成了“你看这坨屎，跟XX一样”（我只能说，还挺有自知之明），当时我和我的朋友就一人挨了他一脚，我当时以为这事就这么过了，结果过了一个周末，他把我和我的朋友拉到办公室（他早就不教我了），让我们趴在地上做了一个小时平板支撑，期间还用棍子抽打我们，还时不时往我们身上踹几脚，关键他还侮辱我们，说我们心术不正，三观有问题，最可笑的是他说：“我这么大度的人，我都没有在外出的时候当着众人的面处罚你们，我都是回来后在跟你们计较这些”。我只能说，6翻了。 还有他上课，就跟没上一样。上课就让我们读 Global Reading 课本内容一点都不管，犯错也是让我们背书要么就做平板支撑 反正这种出生老师，我是没办法了，幸好他这学期被调去祸害隔壁班了，不然我感觉我们班真的要毁在他手上 原文链接——知乎","categories":[],"tags":[{"name":"整活","slug":"整活","permalink":"https://justpureh2o.cn/tags/%E6%95%B4%E6%B4%BB/"},{"name":"国祯","slug":"国祯","permalink":"https://justpureh2o.cn/tags/%E5%9B%BD%E7%A5%AF/"},{"name":"文章","slug":"文章","permalink":"https://justpureh2o.cn/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"CSP-J 2023 游记","slug":"journey-to-the-cspj2023","date":"2023-10-24T00:21:36.000Z","updated":"2024-11-16T01:32:16.000Z","comments":true,"path":"articles/13587/","link":"","permalink":"https://justpureh2o.cn/articles/13587/","excerpt":"","text":"又名：《第一次考就被小学生薄纱的一集》 本次考场：绵阳东辰国际学校 第一节 赛前准备 插一句：CSP-J 2023没有设置赛前试机环节（包括CSP-S，成都绵阳都这样），个人推测可能是由于开放自选Windows和Linux系统带来的结果。如果你听见诸如：不要操作电脑，违者将作作弊处理 的话时，请将你按捺不住的双手安稳的放在双腿上，避免出现意料之外的事来。 然而赛前试机仍然是必要的一环（但是如果考场纪律有要求那就算了），因为这样可以让选手对机器有一个初步的了解。因为我本人习惯使用Win+E打开文件系统管理器，用Win+V记录剪切板数据，可是这些功能在考场电脑上都无法使用，进行赛前试机不仅可以避免因赛时临时发现无法使用某些功能而带来的苦恼心态爆炸点+1，而且还可以将IDE环境调整到个人喜欢的状态（例如缺省源代码，相当于每次新建代码不用重新打头文件）。选手可以不占用正式比赛时间完成一些个性化操作，方便赛时操作，其重要性不言而喻。 当然，开赛前乱猜试题PDF密码是极其无意义且几乎不可能成功的一件事，更不要使用暴力破解密码工具破解文件（相信守规矩的你也不会将这种工具带进考场里来），这么做不仅会被当做作弊者处理，而且造成的数据丢失也只能由你自己负责。 第二节 开赛之初 考场下发的PDF文件带有密码保护，输入时请务必瞪大眼睛区分大小写字母O、o与数字0；小写字母l、大写字母I与数字1，并且将其中的特殊字符认真核对一遍。本次考试，我有幸将密码中的数字0写成了小写字母o，于是浪费了宝贵的2分钟时间改正密码（真实情况是监考老师在黑板上书写密码时字迹不规范导致的混淆）。因此需要认真看好你的密码。 就我认为：在一开始就仔细写好文件重定向输入输出是极其重要的，因为随着考试时间的推进，你的思考重点将从细节性问题变为如何拿到更多的分数上骗分。你就会忽略重新写上两行重定向IO的代码，因而可能Au-&gt;Cu，光荣AFO。为了引起你的注意，使用极长的注释双斜线是可行的，我本人习惯打上断点。例如： 12//////////////////////////////////////////////// freopen(\"uqe.in\", \"r\", stdin);//////////////////////////////////////////////// freopen(\"uqe.out\", \"w\", stdout); 将比 12//freopen(\"uqe.in\", \"r\", stdin);//freopen(\"uqe.out\", \"w\", stdout); 显眼得多——尤其是当你喜欢为每行代码写上包含心血的易懂注释时。事后你可以通过长按Ctrl+逗号（Dev-C++）的方式快速且安全的删除这些斜线。 不仅如此，看好输入输出文件名也是一个非常重要的细节，建议直接复制粘贴。对于标准样例，直接选中PDF文字再复制一般都不是一个明智的做法，手动输入也是可行的，但是对拍有时会比较繁琐（例如普及组T3的样例）。这边传授一个方便的做法：选中代码左侧序号，在WPS中直接右键菜单点击消除文字即可（本次考试我就是使用的这个方便技巧快捷复制样例数据）。最好找张纸记下来，后面会讲到原因。 顺利解锁了PDF文件，你要做的第一件事就是将四道题全部读熟。对整场比赛的题目有大致的规划，有可能你先前做题时做过与T4极其相似的题目，那么放弃显然是一个很不划算的决策。将题目读熟，大概判断一下算法实现，评估自己哪些题能做好，哪些题要放一放/完全放弃。知己知彼方能百战百胜。 赛初的状态基本上决定了你整场比赛的表现，因此在赛初就做好一切细节方面的完全准备，对你的信心增长是非常重要的！ 第三节 赛中时期 那么你现在拿到了第一题（信心题）。一般来说，CSP的复赛，算法很少裸露地出现在题目之中，前两题近似看作数学题。保证你的数学思维在线，因为第一题的思路可能千奇百怪，如果你一段时间没有思路（对于第一题大概是5~15分钟），可以考虑先做其他题目。刷新一下思维定势，有可能T1的灵感就乍现于其他题目之中。 在符合时间规划的前提下尽可能多去造hack数据，写出一段代码（尤其是T3放大模拟时）后，千万保证没有任何逻辑问题。当然，不是所有人都能只看代码就能检查的出其中的逻辑漏洞。因此你需要多造hack数据。hack数据多数情况下包括这几个要素：方程的特殊解、极端值/边界值、大数据（int越界）。在规划好的时间内想尽办法为你的代码多挑几根刺出来，你的代码才能更加趋近于满分解。 千万不要看你旁边的人！！！ 除非S组巨佬闯进了J组蒟蒻区，否则千万不要在比赛中途去看任何人的任何行为。一方面，你的行为可能被视作交谈作弊喜提CCF全国通报、禁赛3年大礼包；另一方面，如果你抱着嘲笑别人的心态去观察别人，那么你的脸很可能就会被你自己打烂。我在考试时因为瞧不起隔壁的一位小学生，当他开始疯狂敲代码时，我自己的心态就爆炸了——把所有人，不分男女、年龄高低，都当作你的敌人，轻视则死。同时这也给你带来一部分紧张感，会使你的发挥更佳。 给自己适当的放松与勉励，要相信，上天不是无故给你这个周末不用冒着风雨大太阳上补习班的珍贵机会（对于高中生，则是周六不用坐在教室里上正课的机会）。当你完全确认你的代码已经完美无瑕时，告诉自己：同学们都还在悲催的上着课，我却在外边快乐的敲着代码。如此一来可以起到调整心态的作用。 别激动到顺手关了PDF文件。如果你还记得或者是在草稿纸上写了密码，那无所谓；但是如果你没写，你的处境就非常尴尬，这时你可以举手找老师再要，但这绝对对你的心态是一个不小的打击。 第四节 赛末时期 经历三个半小时的不懈奋斗，比赛终于迎来最后的半小时。无论你的完成情况如何，一定要用这最后的时间好好检查一下你的代码。瞄一眼你是否有与下面类似的代码： 12freopen(\"uqe2.in\", \"r\", stdin); // 危freopen(\"uqe2.out\", \"w\", stdout); // 爆零警告 这段代码的主人是个懒人无疑了，如果你把CCF提供的附加样例复制了出来。切记最后把文件名里的序号删除，否则你就可以AFO了。 或者以下的代码： 1234#include &lt;Windows.h&gt;//其他的代码if (system(\"fc uqe.out uqe.ans\")) cout&lt;&lt;\"WA\"&lt;&lt;endl;else cout&lt;&lt;\"AC\"&lt;&lt;endl; 这位同学也是个Windows爱好者受害者无疑了，CCF明文规定了测试用系统为NOI Linux。因此不存在Windows.h这个头文件，如果你忘记删除了，那一定是个大大滴CE。正式比赛时，用bits/stdc++.h万能头即可(Windows和Linux通用）。我有一个考S组的朋友，因为忘记删除这个对拍头文件而喜提一个0分，直接亏大发。 不要忘记将你的重定向取消注释。你连读入输出都没有了，属实是可以AFO了。最后三分钟，请将你的蹄子挪开键盘鼠标。否则可能会越改越慌，不妨好好回想一下这周老师留了什么作业，你缺了哪些课需要去补，总之不要再动你的鼠标键盘了！如果实在是不放心编译问题，按一下F11，通过即可。保证你的工作目录下只留.cpp文件，所以将你复制的样例文件和编译的exe文件全部删除。 第五节 考试结束 请你千万保持冷静，不要习惯性地把机器关机了。CCF明文规定：由关机造成的数据损失，责任由考生自负。只需要把你的IDE关闭就好。 回家后，把周一要交的作业补好。别再谈考试的事情了，让你自己有个好心情。毕竟不管你的表现怎么样，它都过去了不是吗？","categories":[{"name":"鲜花","slug":"鲜花","permalink":"https://justpureh2o.cn/categories/%E9%B2%9C%E8%8A%B1/"}],"tags":[{"name":"CSP-J","slug":"CSP-J","permalink":"https://justpureh2o.cn/tags/CSP-J/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.cn/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]}],"categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"文化课","slug":"文化课","permalink":"https://justpureh2o.cn/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"鲜花","slug":"鲜花","permalink":"https://justpureh2o.cn/categories/%E9%B2%9C%E8%8A%B1/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/categories/%E9%A2%98%E8%A7%A3/"},{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/categories/oi%E7%AE%97%E6%B3%95/"},{"name":"API","slug":"API","permalink":"https://justpureh2o.cn/categories/API/"},{"name":"闲话杂谈","slug":"闲话杂谈","permalink":"https://justpureh2o.cn/categories/%E9%97%B2%E8%AF%9D%E6%9D%82%E8%B0%88/"},{"name":"转载","slug":"转载","permalink":"https://justpureh2o.cn/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"开发记录","slug":"开发记录","permalink":"https://justpureh2o.cn/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://justpureh2o.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://justpureh2o.cn/tags/%E6%95%99%E7%A8%8B/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://justpureh2o.cn/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"公告","slug":"公告","permalink":"https://justpureh2o.cn/tags/%E5%85%AC%E5%91%8A/"},{"name":"数学","slug":"数学","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"文化课","slug":"文化课","permalink":"https://justpureh2o.cn/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"鲜花","slug":"鲜花","permalink":"https://justpureh2o.cn/tags/%E9%B2%9C%E8%8A%B1/"},{"name":"oi","slug":"oi","permalink":"https://justpureh2o.cn/tags/oi/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://justpureh2o.cn/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"},{"name":"NOIp","slug":"NOIp","permalink":"https://justpureh2o.cn/tags/NOIp/"},{"name":"算法","slug":"算法","permalink":"https://justpureh2o.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"题解","slug":"题解","permalink":"https://justpureh2o.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"搜索算法","slug":"搜索算法","permalink":"https://justpureh2o.cn/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"线性代数","permalink":"https://justpureh2o.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"动态规划","slug":"动态规划","permalink":"https://justpureh2o.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"博弈论","slug":"博弈论","permalink":"https://justpureh2o.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"csp-s","slug":"csp-s","permalink":"https://justpureh2o.cn/tags/csp-s/"},{"name":"图论","slug":"图论","permalink":"https://justpureh2o.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数论","slug":"数论","permalink":"https://justpureh2o.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"API","slug":"API","permalink":"https://justpureh2o.cn/tags/API/"},{"name":"随机化","slug":"随机化","permalink":"https://justpureh2o.cn/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"},{"name":"成都东辰","slug":"成都东辰","permalink":"https://justpureh2o.cn/tags/%E6%88%90%E9%83%BD%E4%B8%9C%E8%BE%B0/"},{"name":"整活","slug":"整活","permalink":"https://justpureh2o.cn/tags/%E6%95%B4%E6%B4%BB/"},{"name":"历史资料","slug":"历史资料","permalink":"https://justpureh2o.cn/tags/%E5%8E%86%E5%8F%B2%E8%B5%84%E6%96%99/"},{"name":"计算几何","slug":"计算几何","permalink":"https://justpureh2o.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"差分约束","slug":"差分约束","permalink":"https://justpureh2o.cn/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"分数规划","slug":"分数规划","permalink":"https://justpureh2o.cn/tags/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"},{"name":"最短路算法","slug":"最短路算法","permalink":"https://justpureh2o.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/"},{"name":"生成树","slug":"生成树","permalink":"https://justpureh2o.cn/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"游记","slug":"游记","permalink":"https://justpureh2o.cn/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"闲话杂谈","slug":"闲话杂谈","permalink":"https://justpureh2o.cn/tags/%E9%97%B2%E8%AF%9D%E6%9D%82%E8%B0%88/"},{"name":"oi算法","slug":"oi算法","permalink":"https://justpureh2o.cn/tags/oi%E7%AE%97%E6%B3%95/"},{"name":"高中数学","slug":"高中数学","permalink":"https://justpureh2o.cn/tags/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6/"},{"name":"转载","slug":"转载","permalink":"https://justpureh2o.cn/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"学术","slug":"学术","permalink":"https://justpureh2o.cn/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"dp","slug":"dp","permalink":"https://justpureh2o.cn/tags/dp/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://justpureh2o.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"博客","slug":"博客","permalink":"https://justpureh2o.cn/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://justpureh2o.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"https://justpureh2o.cn/tags/%E5%90%8E%E7%AB%AF/"},{"name":"开发记录","slug":"开发记录","permalink":"https://justpureh2o.cn/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"name":"qexo","slug":"qexo","permalink":"https://justpureh2o.cn/tags/qexo/"},{"name":"OI","slug":"OI","permalink":"https://justpureh2o.cn/tags/OI/"},{"name":"原神","slug":"原神","permalink":"https://justpureh2o.cn/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"latex","slug":"latex","permalink":"https://justpureh2o.cn/tags/latex/"},{"name":"枫丹","slug":"枫丹","permalink":"https://justpureh2o.cn/tags/%E6%9E%AB%E4%B8%B9/"},{"name":"国祯","slug":"国祯","permalink":"https://justpureh2o.cn/tags/%E5%9B%BD%E7%A5%AF/"},{"name":"文章","slug":"文章","permalink":"https://justpureh2o.cn/tags/%E6%96%87%E7%AB%A0/"},{"name":"CSP-J","slug":"CSP-J","permalink":"https://justpureh2o.cn/tags/CSP-J/"}]}